<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Promised Dawn: A Game for Noah's Friends</title>

<!-- PASTE THESE 4 LINES HERE: -->
    <meta name="description" content="A game designed by Noah. Hope you enjoy it.">
    <meta property="og:title" content="The Promised Dawn">
    <meta property="og:description" content="A game designed by Noah. Hope you enjoy it.">
    <meta name="author" content="Noah">
    <!-- -------------------------- -->

    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>



       /* 1. FIXED CONSOLE LAYOUT */
        body { 
            margin: 0; overflow: hidden; background: #111; 
            font-family: 'VT323', monospace; user-select: none; 
            /* CENTER THE CONSOLE */
            display: flex; justify-content: center; align-items: center; height: 100vh; 
        }
        
        #game-wrapper { 
            position: relative; 
            /* FIXED RESOLUTION (Matches Canvas) */
            width: 960px; height: 720px; 
            background: #000; 
            box-shadow: 0 0 50px #000; 
            border: 4px solid #333;
            overflow: hidden; 
        }

        canvas { display: block; image-rendering: pixelated; background: #080808; }
        
        /* 2. UI LAYER FIX (Crucial for visibility) */
        .ui-layer { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            display: flex; flex-direction: column; justify-content: space-between; 
            z-index: 500; /* Ensure it sits ON TOP of the canvas */
        }
        
        #hud-top { padding: 15px; display: flex; gap: 15px; align-items: flex-start; }
}
        .stat-col { display: flex; flex-direction: column; gap: 5px; }
        .stat-box { background: rgba(0,0,0,0.85); border: 2px solid #888; padding: 5px 15px; color: #fff; font-size: 26px; display: flex; align-items: center; gap: 10px; border-radius: 8px; box-shadow: 0 4px 0 #111; }
        
        .bar-w { width: 200px; height: 24px; background: #222; position: relative; border: 2px solid #555; border-radius: 4px; overflow: hidden; }
        .bar-f { height: 100%; transition: width 0.2s; }
        
        .xp-w { width: 200px; height: 12px; background: #222; position: relative; border: 2px solid #555; border-radius: 4px; overflow: hidden; margin-top: 5px; }
        .xp-f { height: 100%; background: #ffd700; width: 0%; transition: width 0.2s; }

        /* --- NEW PIXEL ART MINIMAP --- */
    /* --- NEW PIXEL ART MINIMAP --- */
   /* --- NEW PIXEL ART MINIMAP --- */
    
   /* --- NEW PIXEL ART MINIMAP --- */
    
    /* Keep the Pulse Animation for the Red Dot */
    @keyframes playerPulse {
        0% { transform: translate(calc(-50% + 8px), calc(-50% + 8px)) scale(1); box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
        70% { transform: translate(calc(-50% + 8px), calc(-50% + 8px)) scale(1.1); box-shadow: 0 0 0 6px rgba(255, 0, 0, 0); }
        100% { transform: translate(calc(-50% + 8px), calc(-50% + 8px)) scale(1); box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
    }

    #minimap-container { 
        width: 180px;  /* RESTORED */
        height: 180px; /* RESTORED */
        margin-left: auto;
        
        /* BOTTOM LAYER: Original Semi-Transparent Black */
        background: rgba(0, 0, 0, 0.5); 
        
        /* Frame Styles */
        border: none;       
        outline: 4px solid #8d6e63;
        box-sizing: border-box;
        
        box-shadow: 
            0 0 0 2px #000,              
            0 0 0 6px #5d4037,           
            0 10px 20px rgba(0,0,0,0.8); 
        
        position: relative; 
    }

    /* MIDDLE LAYER (The Map Canvas) */
    #minimap {
        display: block;        
        width: 150px;  /* CHANGED FROM 180px */
        height: 150px; /* CHANGED FROM 180px */    
        
        border: none !important;      
        background: transparent !important; 
        box-shadow: none !important;
        margin: 0; padding: 0;
        
        image-rendering: pixelated;
        transform: translate(8px, 8px); /* Alignment Fix */
    }

    /* TOP LAYER (The Player Dot - NEW STYLE) */
    #mini-player {
        position: absolute;
        width: 6px; height: 6px; 
        background: #ff0000;
        border-radius: 50%;      /* Round Dot */
        
        /* White border */
        border: 2px solid #fff;
        
        z-index: 10;
        pointer-events: none;

        /* Pulse Animation + Alignment */
        transform: translate(calc(-50% + 8px), calc(-50% + 8px));
        animation: playerPulse 1.5s infinite;
    }





    /* The Red Player Dot */
    #mini-player {
        position: absolute;
        width: 6px; height: 6px;
        background: #ff0000;
        border: 2px solid #fff;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 5px #ff0000;
        z-index: 10;
        pointer-events: none;
    }

    /* Optional: A faint grid overlay for texture */
    #minimap-overlay {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
        background-size: 100% 4px, 6px 100%;
        pointer-events: none;
        z-index: 5;
    }





#quest-panel { 
        /* HIDE ON START */
        display: none; 

        position: absolute !important;
        
        /* POSITION: Top Right (Under Minimap) */
        top: 230px !important; 
        right: 15px !important;
        left: auto !important;
        bottom: auto !important;
        
        /* SIZE */
        width: 180px !important;
        height: auto !important;
        
        /* VISUALS */
        background: rgba(0, 0, 0, 0.6) !important; 
        border: 2px solid rgba(241, 196, 15, 0.6) !important;
        border-radius: 8px !important;
        padding: 10px !important;
        
        /* TEXT RESTORED */
        color: #eee !important;
        font-family: 'VT323', monospace !important;
        font-size: 24px !important;  /* Increased from 20px -> 24px */
        line-height: 1.1 !important;
        text-shadow: 2px 2px 0 #000 !important; /* Stronger shadow for contrast */
        
        box-shadow: 0 4px 10px rgba(0,0,0,0.5) !important; 
        pointer-events: none !important;
        z-index: 1000 !important;
    }
 #skill-bar { display: flex; justify-content: center; gap: 12px; padding-bottom: 25px; pointer-events: auto; }
      


.slot { 
            width: 65px; height: 65px; background: #1a1a1a; border: 3px solid #555; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;



            position: relative; color: #fff; 
            
            /* CHANGED HERE: Disable Mouse */
            cursor: default; 
            pointer-events: none;

            border-radius: 10px; transition: 0.1s;
            box-shadow: 0 5px 0 #111;
        }




        .slot:hover { border-color: #ffd700; background: #333; transform: translateY(-3px); }
        .slot:active { transform: translateY(2px); box-shadow: 0 0 0 #000; }
        .slot.locked { filter: grayscale(100%); opacity: 0.6; cursor: not-allowed; border-color: #333; }
        .slot.locked::after { content: "üîí"; font-size: 30px; position: absolute; top: 15px; text-shadow: 0 0 5px #000; }
        
        .slot.active-tool { border-color: #00e676; box-shadow: 0 0 15px #00e676; transform: translateY(-5px); background: #222; }

        .key-hint { position: absolute; top: 2px; left: 5px; color: #ffd700; font-weight: bold; font-size: 16px; text-shadow: 1px 1px 0 #000; }





/* --- NEW: LEVEL UP KEY FLASH (Letters pop out) --- */
        @keyframes keyPop {
            0%   { transform: scale(1); color: #ffd700; text-shadow: 0 0 0 transparent; }
            15%  { transform: scale(2.5); color: #ffffff; text-shadow: 0 0 15px #ffffff; } /* Big & White */
            100% { transform: scale(1); color: #ffd700; text-shadow: 1px 1px 0 #000; }
        }

        .key-flash {
            animation: keyPop 0.8s ease-out !important;
        }






        .icon { font-size: 32px; margin-top: 5px; filter: drop-shadow(0 3px 0 #000); }
        /* Removed 'transition' to fix the visual lag when cooldown starts */
        .cd { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0,0,0,0.8); height: 0%; border-radius: 0 0 8px 8px; }

        #rpg-chat {
            position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%);
            width: 700px; min-height: 100px;
            overflow: visible; /* ALLOWS PORTRAITS TO STICK OUT */
            background: rgba(10, 10, 10, 0.95);
            border: 4px double #888;
            border-radius: 12px;
            display: flex; flex-direction: column; justify-content: flex-start;
            padding: 15px 25px; pointer-events: none;
            transition: opacity 0.2s; opacity: 0;
            z-index: 500;
            box-shadow: 0 10px 30px #000;
        }
	/* NEW: Space-to-finish indicator (standard chat) */
#rpg-chat::after{
    content: "[SPACE] Finish";
    position: absolute;
    right: 18px;
    bottom: 10px;
    font-size: 20px;
    color: #bbb;
    opacity: 0.85;
    text-shadow: 1px 1px 0 #000;
}
/* --- HIDE PROMPT WHEN REQUESTED --- */
#rpg-chat.no-prompt::after {
    display: none !important;
}



/* --- RESTORED STANDARD CHAT STYLES --- */
#chat-name { 
    color: #f1c40f; 
    font-size: 26px; 
    font-weight: bold; 
    margin-bottom: 8px; 
    text-transform: uppercase; 
    border-bottom: 2px solid #444; 
    display: inline-block; 
    letter-spacing: 1px; 
}

#chat-text { 
    color: #fff; 
    font-size: 24px; 
    line-height: 1.3; 
    white-space: pre-wrap; 
    text-shadow: 1px 1px 0 #000; 
}




/* --- SPECIAL PREMIUM CHAT BOX --- */
/* ========================================= */
/*  "VINTAGE SKETCHBOOK" CHAT DESIGN         */
/* ========================================= */
/* ========================================= */
/*  "ANCIENT PARCHMENT" CHAT DESIGN          */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

#special-chat {
    position: absolute; 
    
    /* 1. MOVED UP (Was 70px -> Now 85px) */
    bottom: 85px; 
    
    left: 50%; transform: translateX(-50%);
    
    /* SIZE */
    width: 540px; 
    min-height: 140px;
    
    /* PARCHMENT TEXTURE */
    background-color: #f3e5ab; 
    background-image: radial-gradient(circle, transparent 40%, rgba(161, 136, 127, 0.2) 100%);
    
    /* RIPPED EDGES & BORDER */
    border-radius: 5px 255px 5px 25px / 255px 5px 225px 5px;
    border: 3px solid #5d4037; 
    
    box-shadow: 
        inset 0 0 80px rgba(141, 110, 99, 0.25), 
        0 20px 40px rgba(0,0,0,0.6); 

    display: none; 
    flex-direction: column; justify-content: center;
    
    /* 2. PADDING ADJUSTMENT (Push text slightly higher inside the box) */
    padding: 25px; 
    padding-bottom: 35px; /* Added extra bottom padding */
    
    pointer-events: none;
    z-index: 600; 
}


/* SPACE indicator for special chat */
#special-chat::after {
    content: "[SPACE] Finish";
    position: absolute;
    right: 18px;
    bottom: 12px;
    font-size: 18px;
    color: #5d4037;
    opacity: 0.9;
}




/* --- DYNAMIC ALIGNMENT --- */

/* NOAH: Image Left, Text Pushed Right */
#special-chat.talk-noah {
    padding-left: 200px !important; /* Adjusted for smaller image */
    padding-right: 30px !important;
    align-items: flex-start; 
    text-align: left;
}

/* DORIS: Image Right, Text Pushed Left */
#special-chat.talk-doris {
    padding-right: 200px !important; /* Adjusted for smaller image */
    padding-left: 30px !important;
    
    /* Force text to align LEFT */
    align-items: flex-start !important; 
    text-align: left !important;
}

/* --- TYPOGRAPHY --- */

#sp-name {
    color: #8b0000; 
    font-size: 32px; /* Slightly smaller */
    font-weight: 900; 
    margin-bottom: 5px; 
    font-family: 'Georgia', 'Times New Roman', serif; 
    letter-spacing: 1px;
    text-transform: uppercase;
    border-bottom: 2px solid #8b0000; 
    display: inline-block;
    text-shadow: none;
}

#sp-text {
    color: #212121; 
    font-size: 22px; /* Slightly smaller for better fit */
    line-height: 1.2; 
    font-family: 'Georgia', serif; 
    font-weight: 600; 
    text-shadow: none;
}

/* --- PORTRAIT POSITIONING --- */
.portrait-canvas {
    position: absolute;
    bottom: 0;
    pointer-events: none;
    z-index: 605; 
    image-rendering: pixelated;
    background: transparent !important;
}

/* NOAH: Left, Bottom Aligned */
/* NOAH: Left, Bottom Aligned */
/* NOAH: Left, Bottom Aligned */
#canvas-noah {
    left: -175px; 
    
    /* MOVED UP SLIGHTLY (Was -80px -> Now -65px) */
    bottom: -65px; 
    
    width: 540px; 
    height: 540px;
    
    display: none;
    filter: drop-shadow(8px 8px 5px rgba(0,0,0,0.4));
    animation: slideInLeft 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards;
}


/* DORIS: Right, Bottom Aligned */
#canvas-doris {
    right: -80px; 
    
    /* CHANGE THIS LINE (Moved down another 10px) */
    bottom: -120px; 
    
    /* UNIFIED SIZE: 400px */
    width: 400px; height: 400px;
    
    display: none;
    filter: drop-shadow(-8px 8px 5px rgba(0,0,0,0.4));
    animation: slideInRight 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards;
}

@keyframes slideInLeft { from{opacity:0; transform:translateX(-40px)} to{opacity:1; transform:translateX(0)} }
@keyframes slideInRight { from{opacity:0; transform:translateX(40px)} to{opacity:1; transform:translateX(0)} }




        .float-txt { 
            position: absolute; font-weight: 900; font-size: 38px; pointer-events: none;
            animation: floatUp 0.8s forwards; 
            -webkit-text-stroke: 1.0px black; 
            text-shadow: 2px 2px 0 #000;
            z-index: 100; font-family: 'Arial Black', sans-serif;
        }
        @keyframes floatUp { 
            0% { transform: translate(-50%, 0) scale(0.5); opacity:0; } 
            20% { transform: translate(-50%, -30px) scale(1.2); opacity:1; }
            100% { transform: translate(-50%, -80px) scale(1.0); opacity:0; } 
        }

        #death-screen {
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: rgba(20, 0, 0, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            
            /* CHANGE: Make this higher than the text (6000) */
            z-index: 10000 !important; 
            
            color: #fff; text-align: center;
        }

        /* --- ALWAYS HIGHLIGHT WIN/DIE BUTTONS --- */
        #btn-win, #btn-die {
            border-color: #ffd700 !important; 
            color: #ffd700 !important;
            background: #222 !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5) !important;
            animation: btnPulse 1.5s infinite alternate;
        }
        
        @keyframes btnPulse {
            from { transform: scale(1.0); box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
            to { transform: scale(1.05); box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
        }

	

	  #win-screen {
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: rgba(0, 20, 0, 0.95);
            display: none; 
            flex-direction: column; justify-content: center; align-items: center;
            
            /* CHANGE: Make this higher than the text (6000) */
            z-index: 10000 !important; 
            
            color: #fff; text-align: center;
        }




        .cert-card { border: 8px double #ffd700; background: #111; padding: 40px; border-radius: 10px; box-shadow: 0 0 50px #ffd700; max-width: 750px; animation: popIn 0.5s; }
        @keyframes popIn { from {transform:scale(0);} to {transform:scale(1);} }

        #start-menu { position: absolute; top:0; left:0; width:100%; height:100%; background: #080808; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; pointer-events: auto; }
        .cls-btn { width: 240px; padding: 25px; margin: 15px; background: #222; border: 3px solid #555; color: #fff; text-align: center; cursor: pointer; transition: 0.2s; font-size: 28px; display: inline-block; border-radius: 8px; }
        .cls-btn:hover { border-color: #ffd700; background: #333; transform: scale(1.05); box-shadow: 0 0 20px #ffd700; }
        #title-txt { font-size:90px; color:#4fc3f7; text-shadow: 5px 5px #000, 0 0 30px #4fc3f7; cursor: pointer; margin-bottom: 20px; font-family: 'VT323'; letter-spacing: 5px; }

        /* --- CONFIRMATION MODAL --- */
        #confirm-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); z-index: 6000; /* Highest Priority */
            display: none; justify-content: center; align-items: center; pointer-events: auto;
        }
        /* Highlight state for Confirm Buttons */
        #conf-yes.selected { background: #c0392b; border-color: #fff; transform: scale(1.1); box-shadow: 0 0 20px #c0392b; }
        #conf-no.selected { background: #555; border-color: #fff; transform: scale(1.1); }
        
        /* --- REGION 9: FARM UI OVERLAYS --- */
        #farm-ui-layer { display:none; position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index: 1500; }
        
        .farm-menu {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #2e1a0b; border: 4px solid #a1887f; border-radius: 10px;
            padding: 20px; width: 600px; display: none; pointer-events: auto;
            color: #fff; box-shadow: 0 10px 50px #000;
        }
        .farm-menu h2 { margin-top:0; color: #ffd700; text-align: center; border-bottom: 2px solid #5d4037; }
        .farm-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .farm-btn { background: #5d4037; color:white; border:2px solid #8d6e63; padding:10px; cursor:pointer; font-family:'VT323'; font-size:20px; }
        .farm-btn:hover { background: #795548; border-color:#ffd700; }
        .close-btn { background: #c0392b; margin-top:15px; width:100%; }

        #farm-stats {
            position: absolute; top: 15px; left: 500px;
            background: rgba(46, 125, 50, 0.9); border: 2px solid #81c784; 
            padding: 10px 20px; color: #fff; font-size: 24px; border-radius: 8px;
            display: none;
        }




  /* --- EPIC HERO'S JOURNEY ART --- */
        /* --- AAA RPG COVER ART --- */
       /* --- AAA RPG COVER ART (Golden Hour Edition) --- */
        /* --- AAA RPG COVER ART (Golden Hour Edition) --- */
        #main-menu { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 3000; pointer-events: auto; 
            /* SKY: Cinematic Gradient (Deep Teal -> Sunset Gold) */
            background: linear-gradient(to bottom, #0f2027 0%, #203a43 40%, #ff7e5f 80%, #feb47b 100%);
            overflow: hidden;
        }

        /* SUN GLOW */
        .celestial-body {
            position: absolute; bottom: 30%; left: 50%; transform: translateX(-50%);
            width: 400px; height: 400px;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,200,100,0) 70%);
            border-radius: 50%; pointer-events: none; z-index: 1;
        }

        /* ATMOSPHERE: GOD RAYS */
        .god-rays {
            position: absolute; top: -50%; right: -20%; width: 100%; height: 200%;
            background: repeating-linear-gradient(
                -45deg, transparent, transparent 50px, 
                rgba(255, 255, 255, 0.03) 50px, rgba(255, 255, 255, 0.03) 80px
            );
            pointer-events: none; z-index: 20; opacity: 0.7;
        }

        /* LAYER 1: Distant Mountains (Purple/Blue) */
        .mnt-1 {
            position: absolute; bottom: 20%; left: 0; width: 100%; height: 40%;
            background: #2c3e50; opacity: 0.6;
            clip-path: polygon(0% 100%, 0% 40%, 10% 70%, 20% 40%, 35% 80%, 50% 20%, 65% 60%, 80% 30%, 100% 50%, 100% 100%);
            z-index: 2;
        }

        /* LAYER 2: The Ruins (Silhouetted Castle) */
        .scene-ruins {
            position: absolute; bottom: 32%; left: 45%; 
            width: 120px; height: 140px;
            background: #1a1a1a;
            clip-path: polygon(
                5% 100%, 10% 50%, 5% 50%, 5% 20%, 15% 0%, 25% 20%, 25% 50%, 
                35% 50%, 35% 30%, 65% 30%, 65% 50%, 
                75% 50%, 75% 15%, 85% 0%, 95% 20%, 95% 100%
            );
            z-index: 3; opacity: 0.8;
        }

        /* LAYER 3: Mid Hills (Hides the bottom of ruins) */
        .mnt-2 {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 40%;
            background: linear-gradient(to bottom, #3a2e2a, #231612);
            clip-path: ellipse(80% 50% at 50% 100%);
            z-index: 4;
        }

        /* LAYER 4: The Path (SVG Winding Road) */
        .scene-path-svg {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 45%;
            z-index: 5; pointer-events: none;
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.5));
        }

        /* LAYER 5: Foreground Cliff (Detailed Rock) */
        .cliff-foreground {
            position: absolute; bottom: -50px; right: -50px; 
            width: 60%; height: 50%; z-index: 10;
            background: linear-gradient(135deg, #1a1a1a 30%, #000 100%);
            clip-path: polygon(10% 100%, 0% 30%, 15% 25%, 25% 35%, 35% 20%, 50% 25%, 65% 10%, 80% 15%, 100% 0%, 100% 100%);
        }
        
        /* Cliff Rim Light (Golden Edge) */
        .cliff-highlight {
            position: absolute; bottom: -50px; right: -50px; 
            width: 60%; height: 50%; z-index: 11;
            background: rgba(255, 160, 0, 0.1);
            clip-path: polygon(
                10% 100%, 0% 30%, 15% 25%, 25% 35%, 35% 20%, 50% 25%, 65% 10%, 80% 15%, 100% 0%, 
                100% 5%, 80% 20%, 65% 15%, 50% 30%, 35% 25%, 0% 35%, 15% 100%
            );
            pointer-events: none;
        }

        /* LAYER 6: HERO */
        .hero-container {
            position: absolute; bottom: 22%; right: 18%;
            width: 80px; height: 140px; z-index: 15;
            transform: scale(0.9);
        }
        .hero-cape {
            position: absolute; top: 32px; left: -20px;
            width: 50px; height: 90px;
            background: #800000;
            transform-origin: top right; border-radius: 0 0 0 90%;
            animation: windBlow 3s ease-in-out infinite alternate;
        }
        @keyframes windBlow { 0% { transform: rotate(5deg) skewX(5deg); } 100% { transform: rotate(15deg) skewX(15deg) scaleX(1.1); } }
        .hero-leg { position: absolute; bottom: 0; width: 14px; height: 50px; background: #080808; z-index: 1; }
        .hero-body { position: absolute; bottom: 45px; left: 10px; width: 45px; height: 55px; background: #080808; clip-path: polygon(0 0, 100% 0, 85% 100%, 15% 100%); z-index: 2; }
        .hero-head { position: absolute; bottom: 100px; left: 20px; width: 25px; height: 30px; background: #080808; border-radius: 5px; z-index: 3; }
        .hero-sword {
            position: absolute; bottom: -10px; left: 35px; width: 6px; height: 130px;
            background: linear-gradient(to right, #222, #888, #222); z-index: 5;
        }
        .hero-arm { position: absolute; bottom: 85px; left: 35px; width: 12px; height: 35px; background: #080808; transform: rotate(-15deg); z-index: 4; }

        /* PARTICLES */
        .ember {
            position: absolute; width: 4px; height: 4px; background: #ffd700;
            border-radius: 50%; box-shadow: 0 0 10px #ff9800;
            animation: rise 5s linear infinite; opacity: 0; z-index: 30;
        }
        @keyframes rise { 0% { transform: translateY(0) scale(1); opacity: 0; } 50% { opacity: 1; } 100% { transform: translateY(-300px) scale(0); opacity: 0; } }












        /* MENU PAGES */
        .menu-page { position: absolute; top:0; left:0; width:100%; height:100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 10; animation: fadeIn 0.5s; }
        .menu-page.active { display: flex; }
        @keyframes fadeIn { from{opacity:0; transform:translateY(10px);} to{opacity:1; transform:translateY(0);} }

        /* TEXT & BUTTONS */
        h1.game-title { 
            font-size: 100px; 
            /* Metallic Gold Gradient */
            background: linear-gradient(to bottom, #fffbe3 20%, #ffd700 50%, #b8860b 80%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            /* Heavy Shadow for 3D effect */
            filter: drop-shadow(0px 5px 0px #000);
            margin-bottom: 5px; letter-spacing: 8px; text-align: center; 
            font-family: 'VT323'; cursor: pointer; text-transform: uppercase;
        }




        .subtitle { color: #aab; font-size: 24px; letter-spacing: 3px; margin-bottom: 50px; text-shadow: 2px 2px 0 #000; }
        
        .btn-main { 
            width: 300px; padding: 18px; margin: 12px; 
            background: rgba(46, 26, 11, 0.9); /* Dark Leather Brown */
            border: 2px solid #8d6e63; border-left: 6px solid #a1887f;



border-left: 6px solid #555; color: #fff; font-size: 28px; cursor: pointer; font-family: 'VT323'; text-align: left; padding-left: 40px; transition: 0.2s; position: relative; }
        


.btn-main:hover { 
            background: #3e2723; /* Lighter Brown */
            border-color: #ffd700; border-left-color: #ffd700; 
            padding-left: 55px; color: #ffd700; 
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); 
        }

        /* CLASS CARDS */
        .class-grid { display: flex; gap: 30px; margin-bottom: 40px; }
        .class-card { width: 200px; height: 320px; background: rgba(10, 10, 10, 0.9); border: 3px solid #444; border-radius: 8px; display: flex; flex-direction: column; align-items: center; cursor: pointer; transition: 0.3s; padding: 20px; position: relative; overflow: hidden; }
        .class-card:hover { transform: translateY(-10px); border-color: #fff; box-shadow: 0 0 25px rgba(255,255,255,0.2); }
        .class-card[data-cls="warrior"]:hover { border-color: #e53935; box-shadow: 0 0 25px #e53935; }
        .class-card[data-cls="mage"]:hover { border-color: #8e24aa; box-shadow: 0 0 25px #8e24aa; }


        .class-card[data-cls="rogue"]:hover { border-color: #fdd835; box-shadow: 0 0 25px #fdd835; }
        
        /* RESTORED ICONS */
        .cls-icon-lg { font-size: 50px; margin-bottom: 5px; filter: drop-shadow(0 4px 0 #000); }
        
        .cls-name { font-size: 24px; color: #fff; margin-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.2); width: 80%; text-align: center; font-weight: bold; letter-spacing: 2px; }
        
        .class-card canvas { margin-top: 10px; filter: drop-shadow(0 5px 5px rgba(0,0,0,0.5)); transition: 0.3s; }
        .class-card:hover canvas { transform: scale(1.1); filter: drop-shadow(0 10px 10px rgba(0,0,0,0.8)); }

        


/* CONTINUE SLOTS (Visual Only) */
/* KEYBOARD NAVIGATION & SLOTS */
        .btn-main.selected, .btn-main:hover { 
            background: #3e2723; border-color: #ffd700; border-left-color: #ffd700; 
            padding-left: 55px; color: #ffd700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); 
        }

        .class-card.selected, .class-card:hover { transform: translateY(-10px); border-color: #fff; box-shadow: 0 0 25px rgba(255,255,255,0.2); }
        .class-card[data-cls="warrior"].selected { border-color: #e53935; box-shadow: 0 0 25px #e53935; }
        .class-card[data-cls="mage"].selected { border-color: #8e24aa; box-shadow: 0 0 25px #8e24aa; }
        .class-card[data-cls="rogue"].selected { border-color: #fdd835; box-shadow: 0 0 25px #fdd835; }

        .save-slot { width: 600px; height: 80px; background: rgba(0,0,0,0.8); border: 2px dashed #555; margin: 10px; display: flex; align-items: center; justify-content: center; color: #777; font-size: 24px; transition: 0.2s; }
        .save-slot.selected, .save-slot:hover { border-color: #ffd700; transform: scale(1.02); box-shadow: 0 0 15px rgba(255,215,0,0.3); background: #222; }

        .btn-back.selected, .btn-back:hover { background: #e74c3c; box-shadow: 0 0 15px #e74c3c; transform: scale(1.05); }


        

.btn-back { margin-top: 30px; width: 200px; text-align: center; background: #c0392b; border: none; padding: 10px; color: white; cursor: pointer; font-size: 22px; font-family: inherit; }




        /* --- SYSTEM HINT (Bottom Right) --- */
        /* --- SYSTEM HINT (Bottom Right - REDESIGNED) --- */
        /* ========================================= */
    /* 1. SYSTEM HINT (Bottom Right - FINAL)     */
    /* ========================================= */
    #sys-hint {
        position: absolute; 
        bottom: 25px; right: 25px; 
        width: 70px; height: 70px; 
        
        display: flex; justify-content: center; align-items: center;
        
        cursor: pointer; pointer-events: auto;
        z-index: 1000;

        /* TRANSPARENCY SETTINGS */
        opacity: 0.4;  /* 40% visible by default (Ghost mode) */
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #sys-hint:hover { 
        opacity: 1; 
        transform: scale(1.15) rotate(-15deg); /* ORBIT EFFECT */
    }
    
    #sys-hint:active { transform: scale(0.95) rotate(-15deg); }
    
    /* ICON (Floppy Disk) */
    #sys-hint .icon { 
        font-size: 75px; 
        line-height: 1;
        filter: drop-shadow(0 5px 5px rgba(0,0,0,0.5)); 
        color: #fff;
    }

    /* BADGE ([S] Key) */
    #sys-hint .key { 
        position: absolute;
        top: 50%; left: 50%; 
        transform: translate(-50%, -40%); /* CENTERED */
        
        background: #c62828; /* RED */
        border: 2px solid #ffcdd2; 
        border-radius: 6px;
        
        color: #fff;
        font-family: 'VT323', monospace;
        font-size: 32px; 
        font-weight: bold;
        line-height: 1;
        padding: 2px 8px;
        
        box-shadow: 0 4px 8px rgba(0,0,0,0.8);
        text-shadow: 2px 2px 0 #000;
        z-index: 10;
    }
    
    #sys-hint:hover .key {
        background: #e53935; 
        border-color: #fff;
        box-shadow: 0 0 15px #e53935;
    }

    /* ========================================= */
    /* 2. PAUSE MENU OVERLAY (Restored Styles)   */
    /* ========================================= */
    #pause-menu {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        
        /* CHANGED: 0.5 (50% transparent) instead of 0.9 */
        background: rgba(0, 0, 0, 0.5); 
        
        /* CHANGED: Less blur so you can see details */
        backdrop-filter: blur(3px);
        
        z-index: 2000; pointer-events: auto;
        display: flex; justify-content: center; align-items: center;
    }

    .menu-panel {
        width: 550px; 
        background: linear-gradient(135deg, #1a1a1a 0%, #080808 100%);
        border: 4px solid #5d4037;
        border-top: 6px solid #ffd700;
        border-radius: 12px;
        box-shadow: 0 0 80px rgba(0,0,0,1);
        padding: 40px;
        text-align: center;
        animation: slideUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    }
    @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

    .menu-header {
        color: #ffd700; 
        font-size: 70px; 
        margin: 0 0 40px 0;
        font-family: 'Times New Roman', serif; 
        letter-spacing: 8px;
        border-bottom: 2px solid #333; padding-bottom: 20px;
        text-shadow: 0 5px 0 #000;
    }

    .menu-grid { display: flex; flex-direction: column; gap: 25px; }

    .m-btn {
        background: #222; border: 3px solid #444; padding: 25px;
        display: flex; align-items: center; gap: 30px;
        cursor: pointer; transition: 0.2s; position: relative;
        overflow: hidden; border-radius: 8px;
    }
    .m-btn.selected, .m-btn:hover { background: #333; border-color: #ffd700; transform: scale(1.05); box-shadow: 0 0 30px rgba(255, 215, 0, 0.3); }
    .m-btn:active { transform: scale(0.98); }
    
    .quit-btn.selected, .quit-btn:hover { opacity: 1; transform: scale(1.1); text-shadow: 0 0 10px #c0392b; background: rgba(192, 57, 43, 0.1); border-color: #c0392b; }
    .m-btn:active { transform: scale(0.98); }
    
    .m-btn::before { content:''; position: absolute; left: 0; top: 0; height: 100%; width: 10px; background: #ffd700; opacity: 0; transition: 0.2s; }
    .m-btn:hover::before { opacity: 1; }

    .m-icon { font-size: 55px; filter: drop-shadow(0 3px 0 #000); }
    .m-txt { font-size: 40px; color: #fff; font-weight: bold; letter-spacing: 2px; line-height: 1; text-transform:uppercase; font-family: 'VT323'; }
    .m-sub { font-size: 20px; color: #888; margin-top: 8px; font-style: italic; font-family:'Times New Roman'; }

    .quit-btn {
        margin-top: 40px; padding: 15px; color: #c0392b; 
        border: 2px solid transparent; cursor: pointer; 
        font-size: 32px; font-weight: bold; letter-spacing: 2px;
        transition: 0.2s; opacity: 0.8; font-family: 'VT323';
    }
    .quit-btn:hover { opacity: 1; transform: scale(1.1); text-shadow: 0 0 10px #c0392b; }


















/* --- NEW: Golden Floating Text (3 Seconds) --- */
    /* --- NEW: Metallic Gold Floating Text --- */
   /* --- NEW: Metallic Gold Floating Text (2.0s) --- */
    .ui-pop-txt {
        position: absolute; 
        font-family: 'VT323', monospace;
        font-size: 40px; 
        font-weight: 900; 
        z-index: 6000; 
        
        /* Gold Gradient */
        background: linear-gradient(to bottom, #ffffcc 0%, #ffd700 50%, #ff8f00 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        filter: drop-shadow(3px 3px 0 #000);
        
        text-align: center;
        width: 250px;
        pointer-events: none;
        
        /* Faster: 2 Seconds */
        animation: simpleFloat 2s ease-out forwards;
    }

    @keyframes simpleFloat {
        0%   { transform: translate(-50%, 0); opacity: 0; }
        15%  { transform: translate(-50%, -5px); opacity: 1; }
        70%  { transform: translate(-50%, -20px); opacity: 1; } /* Stay Solid */
        100% { transform: translate(-50%, -35px); opacity: 0; } /* Quick Fade */
    }

    /* --- NEW: Optimized White Flash (No Lag) --- */
    @keyframes whiteFlash {
        0% { box-shadow: 0 0 0 transparent; border-color: #555; }
        50% { box-shadow: 0 0 20px #fff; border-color: #fff; background-color: rgba(255,255,255,0.2); }
        100% { box-shadow: 0 0 0 transparent; border-color: #555; background-color: transparent; }
    }

    .shine-anim {
        animation: whiteFlash 0.5s ease-in-out;
        will-change: box-shadow, border-color; /* Prevents lag */
    }







    </style>


    </style>
</head>
<body>

<div id="game-wrapper">





    <canvas id="cvs" width="960" height="720"></canvas>
    
    <!-- REGION 9: Farm Menus -->
    
   




    <div class="ui-layer">
        <div id="hud-top">
            <div class="stat-col">
                <div class="stat-box">‚ù§Ô∏è 
   <div class="bar-w" id="hp-container">


        <div id="hp-bar" class="bar-f" style="background:#e74c3c; width:100%"></div>
    </div>
</div>

                <div class="xp-w"><div id="xp-bar" class="xp-f"></div></div>
            </div>
            <div class="stat-box">LVL <span id="lvl-val" style="color:#ffd700; margin-left:5px">1</span></div>
            <div id="minimap-container">
            <canvas id="minimap"></canvas>
            <div id="mini-player"></div>     <!-- The Red Dot -->
        </div>
        </div>
        <div id="quest-panel">
            <div style="color:#ffd700; font-weight:bold; border-bottom:1px solid #555; margin-bottom:5px;">CURRENT MISSION</div>
            <div id="quest-txt">Loading...</div>
        </div>


        <!-- 1. STANDARD BOX (For Elder Man, Intro, Mobs) -->
<div id="rpg-chat">
    <div id="chat-name"></div>
    <div id="chat-text"></div>
</div>

<!-- 2. SPECIAL BOX (Only for Noah & Doris) -->
<div id="special-chat">
    <div id="sp-name"></div>
    <div id="sp-text"></div>
    <!-- Portraits live here now -->
    <canvas id="canvas-noah" class="portrait-canvas" width="1500" height="1500"></canvas>
    <canvas id="canvas-doris" class="portrait-canvas" width="900" height="900"></canvas>
</div>
       




 <div id="skill-bar"></div>

        



        <!-- 1. THE CORNER HINT (Redesigned: Transparent & Corner) -->
    <div id="sys-hint" onclick="togglePauseMenu()">
        <div class="icon">üíæ</div>
        <div class="key">[S]</div>
    </div>

    <!-- 2. THE PAUSE MENU (No Settings, Big Text) -->
   <!-- 2. THE PAUSE MENU (Updated Labels) -->
    <div id="pause-menu" style="display:none;">
        <div class="menu-panel">
            <h2 class="menu-header">SYSTEM</h2>
            
            <div class="menu-grid">
                <!-- SAVE OPTION -->
                <div class="m-btn" onclick="triggerSaveUI()">
                    <span class="m-icon">üíæ</span>
                    <div style="display:flex; flex-direction:column; align-items:flex-start;">
                        <span class="m-txt">SAVE GAME</span>
                        <span class="m-sub">Record your progress</span>
                    </div>
                </div>

                <!-- CLOSE MENU (Formerly RESUME) -->
                <div class="m-btn" onclick="togglePauseMenu()">
                    <span class="m-icon" style="color: #00e676;">‚úñ</span>
                    <div style="display:flex; flex-direction:column; align-items:flex-start;">
                        <span class="m-txt" style="color: #00e676;">CLOSE MENU</span>
                        <span class="m-sub">Back to adventure</span>
                    </div>
                </div>
            </div>

           <!-- QUIT GAME (Formerly EXIT TO TITLE) -->
            <div class="quit-btn" onclick="returnToMenu(); togglePauseMenu();">
                QUIT GAME
            </div>

            <!-- KEYBOARD HINTS FOOTER -->
            <div style="margin-top: 25px; border-top: 2px solid #333; padding-top: 15px; display: flex; justify-content: space-between; font-size: 22px; color: #aaa; font-family: 'VT323';">
                <span><span style="color:#ffd700">[‚Üï]</span> MOVE</span>
                <span><span style="color:#2e7d32">[SPC]</span> SELECT</span>
                <span><span style="color:#c62828">[ESC]</span> CLOSE</span>
            </div>
        </div>
    </div>













    <!-- 4. THE SAVE SLOT MENU (With Delete) -->
   <!-- 3. THE SAVE SLOT MENU (With Delete) -->
    <div id="save-menu" style="display:none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 2100; justify-content: center; align-items: center; pointer-events: auto;">
        
        <div class="menu-panel" style="width: 550px; padding: 30px;">
            <h2 class="menu-header" style="margin-bottom: 20px; font-size: 60px;">SELECT SLOT</h2>
            
            <div class="menu-grid" style="gap: 15px;">
                
                <!-- SLOT 1 ROW -->
                <div style="display:flex; gap:10px; width:100%;">
                    <!-- Save Button -->
                    <div class="m-btn" onclick="finalSave('rpg_save_slot_1')" style="padding: 15px; flex-grow: 1;">
                        <span class="m-icon" style="font-size: 35px;">üíæ</span>
                        <div style="display:flex; flex-direction:column; align-items:flex-start;">
                            <span class="m-txt" style="font-size: 28px;">SLOT 1</span>
                            <span id="save-info-1" class="m-sub" style="font-size:16px; color:#888;">Checking...</span>
                        </div>
                    </div>
                    <!-- Delete Button -->
                    <div class="m-btn" onclick="deleteSlot('rpg_save_slot_1', 'save-info-1')" style="padding: 0; width: 70px; justify-content: center; border-color:#c0392b; background:#2c0b0b;">
                        <span style="font-size: 30px;">üóëÔ∏è</span>
                    </div>
                </div>

                <!-- SLOT 2 ROW -->
                <div style="display:flex; gap:10px; width:100%;">
                    <div class="m-btn" onclick="finalSave('rpg_save_slot_2')" style="padding: 15px; flex-grow: 1;">
                        <span class="m-icon" style="font-size: 35px;">üíæ</span>
                        <div style="display:flex; flex-direction:column; align-items:flex-start;">
                            <span class="m-txt" style="font-size: 28px;">SLOT 2</span>
                            <span id="save-info-2" class="m-sub" style="font-size:16px; color:#888;">Checking...</span>
                        </div>
                    </div>
                    <div class="m-btn" onclick="deleteSlot('rpg_save_slot_2', 'save-info-2')" style="padding: 0; width: 70px; justify-content: center; border-color:#c0392b; background:#2c0b0b;">
                        <span style="font-size: 30px;">üóëÔ∏è</span>
                    </div>
                </div>

                <!-- SLOT 3 ROW -->
                <div style="display:flex; gap:10px; width:100%;">
                    <div class="m-btn" onclick="finalSave('rpg_save_slot_3')" style="padding: 15px; flex-grow: 1;">
                        <span class="m-icon" style="font-size: 35px;">üíæ</span>
                        <div style="display:flex; flex-direction:column; align-items:flex-start;">
                            <span class="m-txt" style="font-size: 28px;">SLOT 3</span>
                            <span id="save-info-3" class="m-sub" style="font-size:16px; color:#888;">Checking...</span>
                        </div>
                    </div>
                    <div class="m-btn" onclick="deleteSlot('rpg_save_slot_3', 'save-info-3')" style="padding: 0; width: 70px; justify-content: center; border-color:#c0392b; background:#2c0b0b;">
                        <span style="font-size: 30px;">üóëÔ∏è</span>
                    </div>
                </div>

                <!-- Back Button -->
                <div class="m-btn" style="border-color:#555; padding: 10px; justify-content: center;" onclick="closeSaveMenu()">
                    <span class="m-icon" style="font-size: 24px;">‚Ü©Ô∏è</span>
                    <span class="m-txt" style="font-size: 24px;">BACK</span>
                </div>
            </div>
        </div>
    </div>





    </div>

    <div id="win-screen">




        <div class="cert-card">
            <h1 style="color:#ffd700; font-size:60px; margin:0; text-shadow:0 0 10px #ffd700;">JOURNEY COMPLETE</h1>
            <p style="font-size:24px; color:#aaa; margin-top:10px;">The world is safe.</p>
            <hr style="border-color:#444; margin: 20px 0;">
            <p style="font-size:32px; color:#fff;">To the bravest soul...</p>
            <h2 style="font-size:55px; color:#ffd700; margin:10px 0; text-shadow: 0 0 20px #ffd700;">NOAH'S LOYAL KNIGHT</h2>
            <div style="background:#222; padding:20px; border-radius:8px; margin-top:20px; text-align:center;">
                <p style="font-size:24px; color:#f1c40f; margin:5px;">‚ú® A SPECIAL MESSAGE ‚ú®</p>
                <p style="font-size:26px; color:#fff; font-style:italic;">"It is a blessing to have you in my life."</p>
                <p style="font-size:22px; color:#aaa;">Thank you for being here.</p>
            </div>
            <!-- WIN BUTTON (Added ID) -->


            <button id="btn-win" 
                onclick="S.audio.play('class_choose'); S.paused = false; document.getElementById('win-screen').style.display='none'" 
                style="padding:15px 40px; font-size:24px; cursor:pointer; background:#2e7d32; color:#fff; border:2px solid #fff; margin-top:30px; border-radius:5px;">
                Return to World
            </button>
            <div style="margin-top:15px; color:#aaa;">[SPACE] TO CONTINUE</div>
        </div>
    </div>







<!-- DEATH SCREEN -->
    <div id="death-screen" style="display:none;">
        <div class="cert-card" style="border-color:#c0392b; box-shadow: 0 0 50px #c0392b;">
            <h1 style="color:#e74c3c; font-size:60px; margin:0; text-shadow:0 0 10px #c0392b;">YOU HAVE FALLEN</h1>
            <p style="font-size:24px; color:#aaa; margin-top:10px;">Your journey ends here.</p>
            <hr style="border-color:#444; margin: 20px 0;">
            <p style="font-size:32px; color:#fff;">Defeated by...</p>
            <h2 id="death-msg" style="font-size:55px; color:#e74c3c; margin:10px 0; text-shadow: 0 0 20px #c0392b;">UNKNOWN</h2>
           
           <!-- DEATH BUTTON (Added ID) -->
           <button id="btn-die" onclick="returnToMenu()" 
                    style="padding:15px 40px; font-size:24px; cursor:pointer; background:#c0392b; color:#fff; border:2px solid #fff; margin-top:30px; border-radius:5px;">
                Return to Menu
            </button>
            <div style="margin-top:15px; color:#aaa;">[SPACE] TO CONTINUE</div>
        </div>
    </div>









<!-- MAIN MENU WRAPPER -->
    <div id="main-menu">
        <!-- 0. SKY & ATMOSPHERE -->
        <div class="celestial-body"></div> <!-- The glowing sun aura -->
        <div class="god-rays"></div>
        <div id="ember-layer"></div>

        <!-- 1. BACKGROUND (Far away) -->
        <div class="mnt-1"></div> <!-- Purple mountains -->
        
        <!-- 2. THE DESTINATION -->
        <!-- Placed here so it sits BEHIND the mid-hills -->
        <div class="scene-ruins"></div> 
        
        <!-- 3. MID GROUND (Hills that hide the bottom of ruins) -->
        <div class="mnt-2"></div>
        
        <!-- 4. THE WINDING PATH (SVG) -->
        <!-- Logic: Starts bottom-left, Curves S-shape, Ends top-center (480,100) behind hills -->
        <svg class="scene-path-svg" viewBox="0 0 960 360" preserveAspectRatio="none">
            <defs>
                <linearGradient id="pathGrad" x1="0%" y1="100%" x2="0%" y2="0%">
                    <stop offset="0%" style="stop-color:#5d4037;stop-opacity:1" />  <!-- Dark Dirt near camera -->
                    <stop offset="60%" style="stop-color:#8d6e63;stop-opacity:1" /> <!-- Lighter Dirt mid -->
                    <stop offset="100%" style="stop-color:#a1887f;stop-opacity:0" /> <!-- Fades out at horizon -->
                </linearGradient>
            </defs>
            <!-- 
               M 200,360 = Start at bottom left (Camera)
               C ...     = Bezier Curve
               Ends at 480,120 = The horizon line near ruins
            -->
            <path d="M 150,400 
                     C 300,300 600,300 500,180 
                     S 450,150 480,120 
                     L 520,120 
                     S 550,150 600,180
                     C 700,300 400,300 250,400 Z" 
                  fill="url(#pathGrad)" />
        </svg>

        <!-- 5. FOREGROUND (The Cliff) -->
        <div class="cliff-foreground"></div>
        <div class="cliff-highlight"></div> <!-- Adds the 3D rock edge detail -->

        <!-- 6. THE HERO (Standing on the Cliff) -->
        <div class="hero-container">
            <div class="hero-cape"></div>
            <div class="hero-leg" style="left:15px; transform:skewX(5deg)"></div>
            <div class="hero-leg" style="left:40px; transform:skewX(-5deg)"></div>
            <div class="hero-body"></div>
            <div class="hero-head"></div>
            <div class="hero-sword"></div>
            <div class="hero-arm"></div>
        </div>




        <!-- PAGE 1: HOME -->
        <div id="page-home" class="menu-page active">
            
            <!-- NEW TITLE CONTAINER -->
            <div style="text-align:center; position:relative; z-index:50; margin-bottom:30px;">
                
                <!-- Dedication Text -->
                <div style="font-size:16px; color:#aaa; letter-spacing:4px; margin-bottom:5px; text-transform:uppercase; font-family:'VT323';">
                    A GAME FOR NOAH'S FRIENDS
                </div>

                <!-- MAIN TITLE -->
                <h1 class="game-title" onclick="eggTitle()" style="
                    font-family: 'Times New Roman', serif;
                    font-weight: 900; 
                    font-size: 80px; 
                    letter-spacing: 10px; 
                    margin: 0;
                    text-transform: uppercase;
                    /* Cinematic Gold Gradient */
                    background: linear-gradient(to bottom, #fff 10%, #ffd700 50%, #d4af37 100%);
                    -webkit-background-clip: text; 
                    -webkit-text-fill-color: transparent;
                    /* Deep Shadow */
                    filter: drop-shadow(0 5px 0 rgba(0,0,0,0.8));
                ">
                    THE PROMISED DAWN
                </h1>

                <!-- Divider Line -->
                <div style="width: 300px; height: 3px; background: #ffd700; margin: 10px auto; opacity: 0.8; box-shadow: 0 0 10px #ffd700;"></div>
            </div>

            <!-- BUTTONS -->
            <div class="btn-main" onmouseenter="AudioSys.play('menu_scroll')" onclick="Menu.goto('classes')">START NEW GAME</div>
            <div class="btn-main" onmouseenter="AudioSys.play('menu_scroll')" onclick="Menu.goto('load')">CONTINUE</div>
            
            <!-- KEYBOARD HINT -->
            <div style="margin-top: 30px; color: #777; font-size: 20px; letter-spacing: 2px; text-shadow: 1px 1px 0 #000;">
                <span style="color:#ffd700">[ARROWS]</span> MOVE &nbsp;&nbsp; <span style="color:#ffd700">[SPACE]</span> SELECT
            </div>
        </div>




       <!-- PAGE 2: CLASS SELECTION -->
        <div id="page-classes" class="menu-page">
            <h2 style="color:#fff; font-size:40px; margin-bottom:30px; text-shadow:2px 2px 0 #000;">CHOOSE YOUR HERO</h2>
            
            <div class="class-grid">



                <!-- WARRIOR -->
<div class="class-card" data-cls="warrior" onclick="startNewGame('warrior')" onmouseenter="AudioSys.play('class_hover')">
    <div class="cls-icon-lg">‚öîÔ∏è</div>
    <div class="cls-name">WARRIOR</div>
    <!-- WIDER CANVAS -->
    <canvas id="preview-warrior" width="160" height="140"></canvas>
</div>
<!-- MAGE -->
<div class="class-card" data-cls="mage" onclick="startNewGame('mage')" onmouseenter="AudioSys.play('class_hover')">
    <div class="cls-icon-lg">üî•</div>
    <div class="cls-name">MAGE</div>
    <!-- WIDER CANVAS -->
    <canvas id="preview-mage" width="160" height="140"></canvas>
</div>
<!-- RANGER -->
<div class="class-card" data-cls="rogue" onclick="startNewGame('rogue')" onmouseenter="AudioSys.play('class_hover')">
    <div class="cls-icon-lg">üèπ</div>
    <div class="cls-name">RANGER</div>
    <!-- WIDER CANVAS -->
    <canvas id="preview-rogue" width="160" height="140"></canvas>
</div>
            </div>

            <button class="btn-back" onclick="Menu.goto('home')">BACK</button>
        </div>






      <!-- PAGE 3: CONTINUE (With Delete Options) -->
<div id="page-load" class="menu-page">
    <h2 style="color:#fff; font-size:40px; margin-bottom:30px; text-shadow:2px 2px 0 #000;">LOAD GAME</h2>
    
    <!-- SLOT 1 ROW -->
    <div style="display:flex; width:700px; gap:10px; margin:10px;">
        <div id="slot-btn-1" class="save-slot" onclick="loadGame('rpg_save_slot_1')" style="width:auto; flex-grow:1; margin:0; cursor:pointer;">
            <span>[ SLOT 1 - EMPTY ]</span>
        </div>
        <div id="del-btn-1" class="save-slot" onclick="deleteSlot('rpg_save_slot_1', 'slot-btn-1')" style="width:80px; margin:0; cursor:pointer; border-color:#c0392b; color:#c0392b;">
            üóëÔ∏è
        </div>
    </div>

    <!-- SLOT 2 ROW -->
    <div style="display:flex; width:700px; gap:10px; margin:10px;">
        <div id="slot-btn-2" class="save-slot" onclick="loadGame('rpg_save_slot_2')" style="width:auto; flex-grow:1; margin:0; cursor:pointer;">
            <span>[ SLOT 2 - EMPTY ]</span>
        </div>
        <div id="del-btn-2" class="save-slot" onclick="deleteSlot('rpg_save_slot_2', 'slot-btn-2')" style="width:80px; margin:0; cursor:pointer; border-color:#c0392b; color:#c0392b;">
            üóëÔ∏è
        </div>
    </div>

    <!-- SLOT 3 ROW -->
    <div style="display:flex; width:700px; gap:10px; margin:10px;">
        <div id="slot-btn-3" class="save-slot" onclick="loadGame('rpg_save_slot_3')" style="width:auto; flex-grow:1; margin:0; cursor:pointer;">
            <span>[ SLOT 3 - EMPTY ]</span>
        </div>
        <div id="del-btn-3" class="save-slot" onclick="deleteSlot('rpg_save_slot_3', 'slot-btn-3')" style="width:80px; margin:0; cursor:pointer; border-color:#c0392b; color:#c0392b;">
            üóëÔ∏è
        </div>
    </div>

    <button class="btn-back" onclick="Menu.goto('home')">BACK</button>
</div>





    </div>


</div>

    <!-- MOVED CONFIRMATION MODAL HERE (So it sits on top of Main Menu) -->
    <div id="confirm-modal" style="display:none;">
        <div class="menu-panel" style="border-color:#c0392b;">
            <h2 class="menu-header" style="font-size:50px; color:#c0392b; border-color:#555;">DELETE SAVE?</h2>
            <p style="font-size:24px; color:#ccc; margin-bottom:30px;">This cannot be undone.</p>
            
            <div style="display:flex; gap:20px; justify-content:center;">
                <!-- YES BUTTON -->
                <div id="conf-yes" class="m-btn" style="padding:15px; width:120px; justify-content:center; border-color:#444;" 
                     onclick="ConfirmBox.resolve(true)" onmouseenter="ConfirmBox.hover(0)">
                    <span class="m-txt">YES</span>
                </div>
                <!-- NO BUTTON -->
                <div id="conf-no" class="m-btn" style="padding:15px; width:120px; justify-content:center; border-color:#444;" 
                     onclick="ConfirmBox.resolve(false)" onmouseenter="ConfirmBox.hover(1)">
                    <span class="m-txt">NO</span>
                </div>
            </div>
            
            <!-- KEYBOARD HINT -->
            <div style="margin-top:20px; font-size:18px; color:#555;">
                [ARROWS] Choose &nbsp; [SPACE] Confirm
            </div>
        </div>
    </div>


<!-- LOAD FARM LOGIC MODULE -->
<script src="farm.js"></script>

<script>
// --- NEW MENU LOGIC ---


const Menu = {
    selIdx: 0, // Tracks which button is selected

    goto: function(pageId) {
        document.querySelectorAll('.menu-page').forEach(el => el.classList.remove('active'));
        const target = document.getElementById('page-' + pageId);
        if(target) target.classList.add('active');
        if(typeof AudioSys !== 'undefined') AudioSys.play('menu_tab');

        if(pageId === 'load') this.updateSlots();
        
        // RESET KEYBOARD SELECTION ON PAGE CHANGE
        this.selIdx = 0;
        setTimeout(() => this.updateSelection(null), 50); 
    },

    // --- KEYBOARD INPUT HANDLER ---
    handleInput: function(e) {
        // Only run if Main Menu is visible
        if(document.getElementById('main-menu').style.display === 'none') return;
        
        // 1. Wake Audio
        if(typeof AudioSys !== 'undefined' && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();

        const key = e.key.toLowerCase();
        const validKeys = ['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '];
        if(!validKeys.includes(key)) return;

        e.preventDefault(); // Stop page scrolling

        // Find clickable items on current page
        const page = document.querySelector('.menu-page.active');
        if(!page) return;
        
        // Get all buttons that are currently visible
        let targets = Array.from(page.querySelectorAll('.btn-main, .class-card, .save-slot, .btn-back'));
        targets = targets.filter(el => {
            const style = window.getComputedStyle(el);
            return style.display !== 'none' && style.visibility !== 'hidden' && el.offsetParent !== null;
        });

        if(targets.length === 0) return;

        // --- ARROW NAVIGATION (Spatial Search) ---
        if(key.includes('arrow')) {
            const cur = targets[this.selIdx] || targets[0];
            const r1 = cur.getBoundingClientRect();
            const c1 = { x: r1.left + r1.width/2, y: r1.top + r1.height/2 };

            let best = null, minDist = Infinity;

            targets.forEach((t, i) => {
                if(i === this.selIdx) return;
                const r2 = t.getBoundingClientRect();
                const c2 = { x: r2.left + r2.width/2, y: r2.top + r2.height/2 };
                
                const dx = c2.x - c1.x; // Horizontal difference
                const dy = c2.y - c1.y; // Vertical difference

                let isValid = false;
                let weightedDist = Infinity;

                // STRICT GRID NAVIGATION:
                // We add a huge "Penalty" (x10) if the item is not aligned in the direction you are pressing.
                // This ensures "Down" prefers buttons strictly below, and "Right" prefers buttons strictly to the right.

                // DOWN: Must be below (>10px). Penalty for Horizontal offset.
                if(key === 'arrowdown' && dy > 10) { 
                    isValid = true;
                    weightedDist = Math.abs(dy) + (Math.abs(dx) * 10); 
                }
                // UP: Must be above (<-10px). Penalty for Horizontal offset.
                if(key === 'arrowup' && dy < -10) { 
                    isValid = true;
                    weightedDist = Math.abs(dy) + (Math.abs(dx) * 10);
                }
                // RIGHT: Must be to right (>10px). Penalty for Vertical offset.
                if(key === 'arrowright' && dx > 10) { 
                    isValid = true;
                    weightedDist = Math.abs(dx) + (Math.abs(dy) * 10);
                }
                // LEFT: Must be to left (<-10px). Penalty for Vertical offset.
                if(key === 'arrowleft' && dx < -10) { 
                    isValid = true;
                    weightedDist = Math.abs(dx) + (Math.abs(dy) * 10);
                }

                if(isValid && weightedDist < minDist) { 
                    minDist = weightedDist; 
                    best = i; 
                }
            });



            if(best !== null) {
                this.selIdx = best;
                AudioSys.play('menu_scroll');
                this.updateSelection(targets);
            }
        }

        // --- SPACEBAR ACTION ---
        if(key === ' ') {
            if(targets[this.selIdx]) targets[this.selIdx].click();
        }
    },

    updateSelection: function(targets) {
        if(!targets) {
             const page = document.querySelector('.menu-page.active');
             if(!page) return;
             targets = Array.from(page.querySelectorAll('.btn-main, .class-card, .save-slot, .btn-back'));
             targets = targets.filter(el => el.style.visibility !== 'hidden' && el.style.display !== 'none');
        }
        document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
        if(targets[this.selIdx]) targets[this.selIdx].classList.add('selected');
        else { this.selIdx = 0; if(targets[0]) targets[0].classList.add('selected'); }
    },






    updateSlots: function() {        for (let i = 1; i <= 3; i++) {
            let slotKey = 'rpg_save_slot_' + i;
            let loadBtn = document.getElementById('slot-btn-' + i);
            let delBtn = document.getElementById('del-btn-' + i); // Find the trash can
            let raw = localStorage.getItem(slotKey);

            if (raw) {
                // FILE EXISTS
                try {
                    let data = JSON.parse(raw);
                    let meta = data.meta || {};
                    let desc = `${(meta.class||'?').toUpperCase()} (Lv.${meta.lvl||1}) - Day ${meta.day||1}`;
                    
                    loadBtn.innerHTML = `<span style="color:#ffd700; font-weight:bold;">${desc}</span>
                                         <div style="font-size:16px; color:#aaa;">${meta.date || ''}</div>`;
                    loadBtn.style.border = "2px solid #ffd700";
                    loadBtn.style.opacity = "1.0";
                    
                    // Show Delete Button
                    delBtn.style.visibility = "visible";
                    
                } catch(e) {
                    loadBtn.innerHTML = `<span>[ SLOT ${i} - CORRUPTED ]</span>`;
                    delBtn.style.visibility = "visible";
                }
            } else {
                // FILE EMPTY
                loadBtn.innerHTML = `<span>[ SLOT ${i} - EMPTY ]</span>`;
                loadBtn.style.border = "2px dashed #555";
                loadBtn.style.opacity = "0.5";
                
                // Hide Delete Button
                delBtn.style.visibility = "hidden";
            }
        }
    },






    initEmbers: function() {
        const container = document.getElementById('ember-layer');
        if(!container) return;
        container.innerHTML = ''; // Clear previous

        // Create 80 Visible Particles
        for(let i=0; i<80; i++) {
            let s = document.createElement('div');
            s.className = 'ember';
            
            // Random Position
            s.style.left = Math.random() * 100 + '%';
            s.style.bottom = Math.random() * 60 + '%'; // Keep low to ground
            
            // Random Size (Depth)
            let size = 2 + Math.random() * 3;
            s.style.width = size + 'px';
            s.style.height = size + 'px';
            
            // Random Speed
            s.style.animationDuration = (3 + Math.random() * 4) + 's';
            s.style.animationDelay = (Math.random() * 5) + 's';
            
            container.appendChild(s);
        }
    }
};






// --- MENU HERO RENDERER ---
Menu.drawHero = function(id, cls) {
    const ctx = document.getElementById(id).getContext('2d');
    ctx.imageSmoothingEnabled = false;
    
    // 1. CLEAR THE NEW WIDER AREA
    ctx.clearRect(0, 0, 160, 140);
    
    ctx.save();
    // 2. POSITIONING FIX
    // X=80 (Center of 160)
    // Y=100 (Lower down so head fits)
    ctx.translate(80, 130); 
    
    // 3. SCALE
    ctx.scale(2.2, 2.2); 

    // Define Colors

    // Define Colors
    let cMain, cSec, cAcc, cDark, cBoot, cHair, cHigh;
    if(cls === 'warrior') { cMain='#eceff1'; cSec='#1565c0'; cAcc='#ffd700'; cDark='#455a64'; cBoot='#37474f'; cHair='#3e2723'; cHigh='#ffffff'; }
    else if(cls === 'mage') { cMain='#4527a0'; cSec='#7c4dff'; cAcc='#00e5ff'; cDark='#311b92'; cBoot='#1a1a1a'; cHair='#ffe082'; cHigh='#b388ff'; }
    else { cMain='#37474f'; cSec='#ff6d00'; cAcc='#ffeb3b'; cDark='#263238'; cBoot='#212121'; cHair='#5d4037'; cHigh='#ff9e80'; }

    // 1. LEGS (Standing pose)
    const drawBoot = (bx, by, w, h, color) => {
        ctx.fillStyle = color; ctx.fillRect(bx, by, w, h); 
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(bx, by + h - 2, w, 2);
    };
    drawBoot(-7, -12, 5, 12, cBoot); // Left
    drawBoot(2, -12, 5, 12, cBoot);  // Right

    // 2. BODY
    let bodyY = -24;
    // Cape
    ctx.fillStyle = (cls==='mage') ? cDark : cSec; 
    ctx.fillRect(-10, bodyY+10, 20, 10);
    
    // Torso
    ctx.fillStyle = cMain;
    ctx.fillRect(-9, bodyY, 18, 14);
    ctx.fillStyle = cDark; ctx.fillRect(-9, bodyY+10, 18, 3); // Belt
    ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(-5, bodyY, 10, 2); // Neck

    // Chest Details
    if(cls==='warrior') { ctx.fillStyle = cSec; ctx.fillRect(-3, bodyY+2, 6, 8); ctx.fillRect(-6, bodyY+4, 12, 4); }
    if(cls==='mage') { ctx.fillStyle = cAcc; ctx.fillRect(-2, bodyY, 4, 14); }
    if(cls==='rogue') { ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.moveTo(-9, bodyY); ctx.lineTo(-6, bodyY); ctx.lineTo(9, bodyY+14); ctx.lineTo(6, bodyY+14); ctx.fill(); }

    // 3. HEAD
    let headY = bodyY - 14;
    ctx.fillStyle = '#ffe0bd'; ctx.fillRect(-8, headY, 16, 16); // Skin
    
    // Hair
    ctx.fillStyle = cHair;
    if(cls==='warrior') ctx.fillRect(-8, headY, 16, 4);
    if(cls==='mage') { ctx.fillRect(-11, headY-2, 5, 20); ctx.fillRect(6, headY-2, 5, 20); }
    if(cls==='rogue') { ctx.fillRect(-9, headY, 18, 4); }

    // Hat/Helm
    if(cls === 'warrior') { 
        ctx.fillStyle = cMain; ctx.fillRect(-9, headY-5, 18, 10);
        ctx.fillStyle = cHigh; ctx.fillRect(-6, headY-4, 4, 3); // Shine
        ctx.fillStyle = cMain; ctx.fillRect(-10, headY-2, 2, 14); ctx.fillRect(8, headY-2, 2, 14);
        ctx.fillStyle = cSec; ctx.fillRect(-2, headY-8, 4, 16); // Crest
    } 
    else if(cls === 'mage') { 
        ctx.fillStyle = cMain; 
        ctx.beginPath(); ctx.moveTo(-14, headY); ctx.lineTo(14, headY); ctx.lineTo(0, headY-20); ctx.fill();
        ctx.fillStyle = cAcc; ctx.fillRect(-8, headY-2, 16, 2);
    } 
    else { // Rogue Hood
        ctx.fillStyle = cSec; 
        ctx.beginPath(); ctx.moveTo(-10, headY); ctx.lineTo(10, headY); ctx.lineTo(6, headY-5); ctx.lineTo(-8, headY-5); ctx.fill();
        ctx.strokeStyle = cAcc; ctx.lineWidth = 3; 
        ctx.beginPath(); ctx.moveTo(0, headY-3); ctx.quadraticCurveTo(-10, headY-8, -14, headY-2); ctx.stroke();
    }

    // Eyes
    ctx.fillStyle = (cls==='mage') ? cAcc : '#111';
    ctx.fillRect(-5, headY+6, 3, 3); ctx.fillRect(2, headY+6, 3, 3);

    // 4. ARMS (Idle)
    ctx.fillStyle = (cls==='warrior') ? cMain : cSec; 
    ctx.fillRect(-14, bodyY, 5, 5); ctx.fillRect(9, bodyY, 5, 5);
    ctx.fillStyle = '#ffe0bd'; 
    ctx.fillRect(-13, bodyY + 5, 4, 7); ctx.fillRect(9, bodyY + 5, 4, 7);

    ctx.restore();
};

window.addEventListener('load', () => {
    // 1. Preload all sounds immediately
    AudioSys.init(); 

    // 2. Draw Menu Heroes
    Menu.initEmbers(); 
    Menu.drawHero('preview-warrior', 'warrior');
    Menu.drawHero('preview-mage', 'mage');
    Menu.drawHero('preview-rogue', 'rogue');

    // 3. Try to play music (might get blocked by browser initially)
    AudioSys.playBGM('home');

    // 4. THE MAC FIX: Force Audio Engine to Wake Up on First Click
    const wakeUpAudio = () => {
        if (AudioSys.ctx.state === 'suspended') {
            AudioSys.ctx.resume().then(() => {
                console.log("Audio Engine Woken Up!");
            });
        }
        // Play music if it was blocked
        if (AudioSys.bgm && AudioSys.bgm.paused) AudioSys.bgm.play().catch(e=>{});
    };

    // Listen for ANY click or keypress to wake up the engine
    document.body.addEventListener('click', wakeUpAudio, { once: true });
    document.body.addEventListener('keydown', wakeUpAudio, { once: true });

    // 5. Update Menu Selection
    setTimeout(() => {
        if(typeof Menu !== 'undefined') Menu.updateSelection();
    }, 100);
});






const cvs = document.getElementById('cvs');
const ctx = cvs.getContext('2d');
const miniCtx = document.getElementById('minimap').getContext('2d');

// --- AUDIO ENGINE START ---
// --- OPTIMIZED AUDIO SYSTEM (Mac Lag Fix) ---
const AudioSys = {
    // 1. Create the Audio Context (The engine)
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    bgm: null,
    currentBgmKey: null,
    
    // 2. Storage for preloaded sounds
    cache: {}, 

    srcs: {
        // --- BGM ---
        home: "audio/Home.mp3", 
        adventure: "audio/Adventure_Theme.mp3",
        adventure_new: "audio/New_adventure.mp3",
        farm_day: "audio/Relaxing_Theme.mp3",
        farm_night: "audio/night_ambience.mp3",
        

// --- NEW AMBIENCE ---
        rain_loop: "audio/Rain_Sound_Effect.mp3",
        ocean_loop: "audio/Ocean_Sound_of_Waves.mp3",
        fire_loop: "audio/Campfire_Sound_Effect.mp3",
        row_boat: "audio/Row_Boat_Sound_Effect.mp3",
        // --------------------


        // --- SYSTEM / UI ---
        bag: "audio/bag_open.mp3",
        error: "audio/error.mp3",
        save: "audio/save.mp3",
        over: "audio/game_over.mp3",
        equip: "audio/item_equip.mp3",
        tool_swap: "audio/equip.mp3",   
        lvlup: "audio/lvlup.mp3",
        hover: "audio/Menu_Hover.mp3",
        buy: "audio/SelectBuy.mp3",
        class_hover: "audio/Class_Hover.mp3",
        class_choose: "audio/Class_chosen.mp3",
        esc: "audio/ESC.mp3", 
        reminder: "audio/reminder.mp3",
        npc: "audio/npc.mp3", 
        success: "audio/Success.mp3", 
        victory: "audio/Victory.mp3", 
        tele: "audio/teleport.mp3",
        pop: "audio/Pop_Sound_Effect.mp3",
        btn_click: "audio/button.mp3",
        item_found: "audio/item.mp3", 
        menu_scroll: "audio/menu_button.mp3",
        menu_tab: "audio/menu_change.mp3",
        gate: "audio/unlockGate.mp3",

        // --- FARMING ---
        break: "audio/Break.mp3",
        chop: "audio/Chop.mp3",
        hoe: "audio/Hoe_Dig.mp3",
        rock: "audio/Rock_Smash_Sound_Effect.mp3",
        sickle: "audio/sickle.mp3",
        rooster: "audio/rooster_crow.mp3",
        water: "audio/Watering.mp3",
        well: "audio/well_water.mp3",
        plant: "audio/plant.mp3",
        sell: "audio/sell.mp3",
        put: "audio/put.mp3",
        put_animal: "audio/put_animal.mp3",
        fishing: "audio/fishing.mp3",
        pet_anim: "audio/Pet.mp3",
        
        // --- MOVEMENT ---
        step: "audio/Footstep.mp3",
        horse: "audio/horse_gallop.mp3",
        horse_walk: "audio/horse_walk.mp3",

        // --- COMBAT ---
        bow: "audio/Bow_Shot.mp3",
        explode: "audio/Explosion.mp3",
        magic: "audio/Magic_Cast.mp3",
        swing: "audio/Melee_Swing.mp3",
        thud: "audio/thud_sound_effect.mp3",
        hurt: "audio/Player_Hurt.mp3",
        grasp_cast: "audio/Abyssal_Cast.mp3",
        grasp_hit: "audio/Abyssal_Hit.mp3",
        starfall: "audio/Starfall.mp3",
        poison: "audio/Poison_Cloud.mp3",
        // --- ADD THIS LINE HERE ---
    hydra_shoot: "audio/Hydra_attack.mp3", 
    // --------------------------
		trap: "audio/Trap.mp3",
        shoot: "audio/Shoot.mp3",
        quake: "audio/Quake.mp3",
        tornado: "audio/Tornado.mp3",
        wstomp: "audio/War_Stomp.mp3",
        heal: "audio/Heal.mp3", 
        ice: "audio/Glacial_Spike.mp3",
        fairy: "audio/Fairy_Bomb.mp3",
        rush: "audio/Rush.mp3",
        yaka_cast: "audio/Yaka_Cast.mp3",
        yaka_hit: "audio/Yaka_Hit.mp3",
        arrow_storm: "audio/ArrowStorm.mp3",
        bash: "audio/Bash.mp3",
        thunder: "audio/Thunder.mp3" 
    },

    // 3. PRELOAD FUNCTION (Crucial for Speed)
    init: function() {
        for (let key in this.srcs) {
            let a = new Audio(this.srcs[key]);
            a.preload = 'auto'; // Tell browser to load it NOW
            this.cache[key] = a;
        }
    },

    play: function(key) {
        if(!this.cache[key]) return;
        
        // 4. CLONE NODE (Fastest way to play SFX without delay)
        // This allows multiple sounds (like arrow hits) to overlap.
        let sound = this.cache[key].cloneNode(); 
        sound.volume = 0.4;
        sound.play().catch(e=>{});
    },








   // --- BGM CROSS-FADE SYSTEM ---
    fadeTimer: null, // Track the interval so we don't overlap fades







    playBGM: function(key) {
        if(this.currentBgmKey === key) return; // Already playing this track

        // 1. HARD STOP THE OLD TRACK (Crucial for iOS)
        // iOS ignores volume changes via script, so we must PAUSE explicitly.
        if (this.bgm) {
            this.bgm.pause();
            this.bgm.currentTime = 0;
        }

        // 2. Clear any lingering fade timers
        if (this.fadeTimer) {
            clearInterval(this.fadeTimer);
            this.fadeTimer = null;
        }

        // 3. Prepare New Track
        let newTrack = this.cache[key];
        if(!newTrack) return;

        // 4. Setup and Play
        newTrack.currentTime = 0;
        newTrack.volume = 0.4; // Static volume (iOS ignores this, but good for PC)
        newTrack.loop = true;
        
        let promise = newTrack.play();
        if (promise !== undefined) {
            promise.catch(e => console.log("Audio blocked by browser config"));
        }

        // 5. Update Reference
        this.bgm = newTrack;
        this.currentBgmKey = key;
    },




// --- AMBIENCE LAYER MANAGER ---
    ambience: { rain: null, ocean: null, fire: null },



     // --- REPLACE FROM HERE ---
    isAmbienceLocked: false, // 1. New Flag

    updateAmbience: function(isRain, isOcean, isFire) {
        // 2. Security Check: If locked, force stop everything and exit
        if (this.isAmbienceLocked) { 
            this.stopAmbience(); 
            return; 
        }

        const check = (key, active, vol) => {
            if (!this.ambience[key]) {
                if (this.cache[key + '_loop']) {
                    this.ambience[key] = this.cache[key + '_loop'].cloneNode();
                    this.ambience[key].loop = true;
                    this.ambience[key].volume = vol;
                } else return;
            }
            let s = this.ambience[key];
            if (active) {
                if (s.paused) s.play().catch(e => {});
            } else {
                if (!s.paused) { s.pause(); s.currentTime = 0; }
            }
        };

        check('rain', isRain, 0.4);   
        check('ocean', isOcean, 0.3); 
        check('fire', isFire, 0.6);   
    },

    stopAmbience: function() {
        this.isAmbienceLocked = true; // 3. Engage Lock
        ['rain', 'ocean', 'fire'].forEach(key => {
            if (this.ambience[key]) {
                this.ambience[key].pause();
                this.ambience[key].currentTime = 0;
            }
        });
    },
    
    unlockAmbience: function() { // 4. New Helper to Reset
        this.isAmbienceLocked = false;
    },
    // --- END REPLACEMENT ---





    // --- MAC AUDIO WARM-UP FIX ---
    warmUp: function() {
        const critical = ['swing', 'bow', 'magic', 'explode', 'step', 'hurt', 'thud'];
        
        critical.forEach(k => {
            // Check if sound exists in cache
            if(this.cache && this.cache[k]) {
                let s = this.cache[k].cloneNode();
                s.volume = 0; // Silent
                // Force browser to "wake up" this sound
                s.play().catch(e => {}); 
            }
        });
        console.log("Audio Warmed Up");
    }
};

// --- AUDIO ENGINE END ---


const TILE = 50; 
const MAP_S = 300; // Logic Size: 300 (Keeps the Big Ocean working)

// --- MINIMAP VISUAL FIX ---
// Canvas Size: 200 (Forces the Island Art to fill the frame again)
const miniCanvas = document.getElementById('minimap');
miniCanvas.width = 150; 
miniCanvas.height = 150;



const T = { WATER:0, GRASS:1, FOREST:2, SAND:3, RUINS:4, SWAMP:5, SNOW:6, LAVA:7, VOID:8, ROAD:9, BRIDGE:10, LOCK:11, BEDROCK:12, BLOCK:13 };
const C = { 
    WATER:'#050505', GRASS:'#2e7d32', FOREST:'#1b5e20', SAND:'#f9e79f', 
    RUINS:'#616161', SWAMP:'#3e2723', SNOW:'#b0bec5', 
    LAVA:'#3e2723', VOID:'#1a0b2e', ROAD:'#78909c', BRIDGE:'#5d4037', 
    LOCK:'#c0392b', BEDROCK:'#111', BLOCK:'#000'
};

const CLASSES = {
    // Warrior: Tanky (750 HP)
    warrior: { hp:750, spd:0.12, color:'#2196f3', skills:['Slash','Bash','War Stomp','Rally','Quake', 'Tornado'] },
    
    // Mage: Glass Cannon (300 HP)
    mage:    { hp:300, spd:0.13, color:'#9c27b0', skills:['Inferno','Glacial Spike','Thunderstorm','Heal','AbyssalGrasp', 'Starfall'] },
    
    // Ranger: Buffed slightly (350 -> 420) to survive one extra boss hit
    rogue:   { hp:420, spd:0.15, color:'#ffb300', skills:['Shoot','PoisonCloud','Trap','Rush','ArrowStorm', 'FairyBombs'] }
};



const SKILLS = {
    // --- WARRIOR ---
   // FIX: Slash Range 3.5 -> 5.0 (Hit enemies before they hit you)
'Slash':     { k:'Z', cd:400,  icon:'‚öîÔ∏è', dmg:35, range:5.0, vfx:'slash', scale:1.0 }, 

// FIX: Bash CD 4s -> 2.5s (Stun more often)
'Bash':      { k:'X', cd:2500, icon:'üõ°Ô∏è', dmg:80, range:4, stun:2000, knock:4.0, vfx:'bash', scale:1.5 }, 

'War Stomp': { k:'C', cd:5000, icon:'‚ò¢Ô∏è', dmg:120, range:5.0, knock:3.0, stomp:true, scale:1.2 }, 

// FIX: Rally CD 12s -> 8s, Heal 200 -> 300 (Stay alive!)
'Rally':     { k:'V', cd:8000, icon:'‚ù§Ô∏è', heal:300 },
    'Quake':     { k:'B', cd:15000, icon:'üåã', dmg:220, range:10, stun:3000, ult:true, quake:true, scale:2.0 },
   // WARRIOR N: TORNADO (Buffed: 15 -> 28)
    // Strong enough to wipe a wave of mobs, but won't instant-kill a boss.
    // WARRIOR N: TORNADO (Buffed: 15 -> 45 damage per tick)
    'Tornado': { k:'N', cd:6000, icon:'üåÄ', dmg:45, range:12, tornado:true, locked:true, count:5, scale:0.15 },

    // MAGE N: STARFALL (Buffed: 8 -> 25 damage per star)
    // With 100 stars, this deals massive total damage now.
    'Starfall': { k:'N', cd:10000, icon:'‚ú®', dmg:25, range:9, type:'stars', count:100, locked:true, scale:0.05 },

    // --- MAGE ---
    'Inferno':       { k:'Z', cd:1200, icon:'üî•', proj:true, dmg:25, spd:0.8, color:'#ff5722', burn:3000, count:5, spread:0.4, inferno:true, scale:0.25 }, // 5 hits
    'Glacial Spike': { k:'X', cd:6000, icon:'‚ùÑÔ∏è', dmg:100, range:8.0, freeze:2500, spike:true, scale:1.5 }, // CD > Freeze
    'Thunderstorm':  { k:'C', cd:7000, icon:'‚ö°', dmg:120, range:9, stun:800, storm:true, scale:1.5 }, // Short stun
    'Heal':          { k:'V', cd:12000, icon:'üíö', heal:150 },
    'AbyssalGrasp':  { k:'B', cd:7000, icon:'üñêÔ∏è', dmg:300, range:9, ult:true, grasp:true, scale:2.0 },
   // MAGE N: STARFALL (Buffed: 8 -> 25 damage per star)
    // With 100 stars, this deals massive total damage now.
    'Starfall': { k:'N', cd:10000, icon:'‚ú®', dmg:32, range:9, type:'stars', count:150, locked:true, scale:0.17 },

    // --- RANGER ---
    // Scale 0.06 keeps the damage balanced (15 hits x low dmg)
// BUFFED: Damage 12 -> 20, Scale 0.06 -> 0.1 (Now hits harder)
    'Shoot':       { k:'Z', cd:500,  icon:'üèπ', dmg:20, range:10, arrow:true, scale:0.1 },
    // FIX: Base 10 dmg (Stronger). We will apply 4x Multiplier for Bosses in code.
'PoisonCloud': { k:'X', cd:6000,  icon:'‚ò†Ô∏è', dmg:10, range:8, poison:200, type:'zone', scale:0.23 },

// Buffed Trap CD (10s -> 6s)
'Trap':        { k:'C', cd:6000,  icon:'üï∏Ô∏è', dmg:50, range:6, type:'web', stun:3000, scale:1.0 },

'Rush':        { k:'V', cd:10000, icon:'üëü', speed:true },


// --- [SANDWICH START] ---
    // Change dmg to 18 (Total 648) - Kills Goblins/Slimes in one Ult
   'ArrowStorm':  { k:'B', cd:15000, icon:'üü¢', ult:true, type:'execution', dmg:12 }, 
    // --- [SANDWICH END] --- 
    'FairyBombs':  { k:'N', cd:5000, icon:'üßö', dmg:35, range:12, locked:true, type:'fairy', scale:0.3 }
};



const QUESTS = [
    { type:'talk', txt: "Talk to Elder Man (Village)", target: "Elder Man", id:0 },
    { type:'kill', txt: "Defeat Slime King (Grass)", target: "Slime King", lock:0 }, 
    { type:'collect', txt: "Gather 3 Herbs (Forest)", target: "Medic Herb", count:3, lock:1 },
    { type:'kill', txt: "Slay Scorpion King (Sand)", target: "Scorpion King", lock:2 },
    // CHANGE THIS LINE:
// Find QUESTS = [...]
{ type:'activate', txt: "Polish 3 Angel Statues (Ruins)", target: "Angel Statue", count:3, lock:3 },
    // Make sure it says "Hydra"
{ type:'kill', txt: "Slay the Hydra (Swamp)", target: "Hydra", lock:4 }, 
    { type:'activate', txt: "Free 3 Frozen Friends (Snow)", target: "Frozen Friend", count:3, lock:5 },
    { type:'kill', txt: "Slay Red Dragon (Lava)", target: "Red Dragon", lock:6 }, 
    { type:'kill', txt: "Defeat Chaos Titan", target: "Chaos Titan" }
];

let S = {
    gameOver: false, // New flag
    run: false, map: [], cam: {x:0, y:0}, shake:0,
    p: { x:0, y:0, hp:100, maxHp:100, xp:0, lvl:1, cds:{}, buffs:{}, dir:2, killLog:[], actLog:{} },
    ents: [], parts: [], lighting: [], shockwaves:[], vfxs:[], qStep: 0, qProg:0, locks: [],
    wordData: [], 
    input: { keys:{} },
    world: "main",
    unlockedRegion9: false,
    farm: {
        day: 1, money: 5000, houseLevel: 1, fieldLevel: 1, 
        time: 360, water: 30,
        
        // These are the "Pockets" the farm needs:
        plots: {}, debris: {}, fences: {}, structures: {}, letterData: {},
        
        inventory: { 
            carrot_seeds: 5, wood: 0, stake: 0, fish: 0, 
            carrot: 0, potato: 0, corn: 0, tomato: 0,
            rose: 0, sunflower: 0, tulip: 0, lavender: 0,
            brick: 0
        },
        storage: { wood: 0, stake: 0, fish: 0 },
        tools: { hoe: 1, sickle: 1, axe: 1, hammer: 1, water: 1, rod: 1 },
        toolNames: ['Hand','Hoe','Hammer','Axe','Sickle','Water','Rod',''], 
        toolIcons: ['‚úã','‚õèÔ∏è','üî®','ü™ì','‚úÇÔ∏è','üöø','üé£',''],
        keyMap:    ['1','2','3','4','Q','W','E','R'],
        toolIndex: 0
    }
};




// --- SYSTEM MENU LOGIC ---
S.paused = false; 

function togglePauseMenu() {
    S.paused = !S.paused;
    const menu = document.getElementById('pause-menu');
    menu.style.display = S.paused ? 'flex' : 'none';
    
    if(S.paused) {
        AudioSys.play('bag');
        GameMenuNav.reset(); // Reset selection to top
    } else {
        AudioSys.play('btn_click');
    }
}

// --- SAVE SYSTEM LOGIC ---



function saveGame(slotId) {
    try {
        // 1. FILTER ENTITIES
        // We only save "Real" things.
        let persistentEnts = S.ents.filter(e => {
            // Keep these types:
            const keep = [
                'mob', 'npc', 'struct', 'item', 'obj', 'pet', 
                'chicken', 'cow', 'horse', 'farm_mob', 'struct_item',
                'env', // <--- FIX: Trees, Flowers, Cactus
                'obs'  // <--- FIX: Boulders, Stumps
            ];
            
            // Discard 'proj', 'zone', 'tornado', 'shadow_hand', etc.
            return keep.includes(e.type) && !e.dead; 
        });

        // 2. CONSTRUCT THE SNAPSHOT
        let payload = {
            // A. The Map (Crucial: Convert Uint8Array to normal Array for JSON)
            mapData: Array.from(S.map), 
            
            // B. The World State
            p: S.p,
            ents: persistentEnts,
            farm: S.farm,         // This includes inventory, plots, and 'generated' flag
            locks: S.locks,       // Remember which gates are open
            wordData: S.wordData, // The text blocks on the floor
            
            // C. The Story Flags
            qStep: S.qStep,
            qProg: S.qProg,
            unlockedRegion9: S.unlockedRegion9,
            bossDead: S.bossDead,
            world: S.world,       // Remember if we are in 'farm' or 'main'
            
            // D. Meta Data (For the "Load Game" menu later)
            meta: {
                date: new Date().toLocaleString(),
                class: S.p.class,
                lvl: S.p.lvl,
                day: S.farm.day
            }
        };

        // 3. WRITE TO BROWSER STORAGE
        localStorage.setItem(slotId, JSON.stringify(payload));

        // 4. FEEDBACK
        S.audio.play('save'); 
        popText(S.p.x, S.p.y, "GAME SAVED", "#0f0");
        
        // (Optional) Update the "Load Game" menu visuals immediately if we were on that screen
        // renderSaveSlots(); 

    } catch (err) {
        console.error("Save Failed:", err);
        popText(S.p.x, S.p.y, "SAVE ERROR", "#f00");
    }
}











// --- LOAD SYSTEM LOGIC ---

function loadGame(slotId) {
    try {
        // 1. SET ACTIVE SLOT (Important: Remember which button was clicked)
        S.curSlot = slotId;

        // 2. GET RAW DATA
        const raw = localStorage.getItem(slotId);

        // --- NEW LOGIC: IF EMPTY, START NEW GAME ---
        if (!raw) {
            console.log("Slot is empty. Starting new game on " + slotId);
            // Go to Class Selection
            Menu.goto('classes'); 
            return; // Stop loading, start creating
        }
        // -------------------------------------------

        
        const data = JSON.parse(raw);
	AudioSys.warmUp();

  // --- PASTE THIS NEW LINE HERE ---
        if(AudioSys.unlockAmbience) AudioSys.unlockAmbience();
        // --------------------------------



        // 2. INIT ENGINE (Audio, Inputs - Shared Setup)
        // We use the function created in Step 1 to prepare the engine
        initSharedState();

        // 3. INJECT SAVED DATA (Overwriting default state)
        
        // A. REHYDRATE MAP (Fixes "Water/Void" bug)
        // We convert the saved array back into the format the game engine reads (Uint8Array)
        S.map = new Uint8Array(data.mapData);

        // B. RESTORE ENTITIES (Fixes "Regenerating Mobs/Bosses")
        // We load exactly who was alive. If Slime King isn't here, he stays dead.
        S.ents = data.ents;

        // C. RESTORE PLAYER & FARM
        S.p = data.p;


// --- ADD THIS LINE HERE ---
        S.p.hidden = false; 
        // --------------------------



        S.farm = data.farm; // Includes inventory, day, money, AND the 'generated' flag
        
        // D. RESTORE FLAGS (Fixes "Closed Gates" and "Missing Bridge")
        S.locks = data.locks;
        S.wordData = data.wordData;
        S.qStep = data.qStep;
        S.qProg = data.qProg;
        S.unlockedRegion9 = data.unlockedRegion9;
        S.bossDead = data.bossDead;
        S.world = data.world; // Remember if we were in 'farm' or 'main'

        // 4. RESTORE RUNTIME LINKS (The "Glue")
        
        // A. Re-connect Farm System
        // We pass the LOADED state to the farm engine. 
        // Because S.farm.generated is true in the save, it WON'T spawn new trees!
        if(typeof Region9Farm !== 'undefined') Region9Farm.init(S);

        // B. Update UI & Hotkeys (Fixes "Broken Hotkeys")
        // This function checks S.world and turns on the correct interface
        updateUI(); 

        // C. Redraw Minimap (Fixes "Blank Map")
        drawStyledMinimap();



// --- FIX: FORCE CLOSE CHAT & MENUS ---   <-- YOU PASTED THIS
        document.getElementById('rpg-chat').style.display = 'none';
        document.getElementById('special-chat').style.display = 'none';
        document.getElementById('death-screen').style.display = 'none';
        document.getElementById('win-screen').style.display = 'none';
        document.getElementById('pause-menu').style.display = 'none';
        // -------------------------------------   <-- END PASTE





       // 5. START THE GAME LOOP (Bypassing genMap!)
        document.getElementById('main-menu').style.display = 'none';
        
        // --- FORCE MUSIC RESTART ---
        S.audio.currentBgmKey = null; // Forget 'Home' music
        
        // [FIXED] CHECK TIME TO DECIDE DAY/NIGHT MUSIC
        let bgm;
        if (S.world === 'farm') {
            // Check if Night (Before 6AM or After 7PM)
            let isNight = (S.farm.time < 360 || S.farm.time >= 1140);
            bgm = isNight ? 'farm_night' : 'farm_day';
        } else {
            // Main World Music
            bgm = S.bossDead ? 'adventure_new' : 'adventure';
        }

        S.audio.playBGM(bgm);

        S.run = true;
        loop();

        console.log("Save Loaded Successfully.");




    } catch (err) {
        console.error("Load Failed:", err);
        // REPLACED ALERT WITH CONSOLE LOG (So the game doesn't freeze)
        if(typeof AudioSys !== 'undefined') AudioSys.play('error');
        console.log("Failed to load save file. Data might be corrupted.");
    }
}








function triggerSaveUI() {
    // 1. Hide Pause Menu
    document.getElementById('pause-menu').style.display = 'none';
    
    // 2. Show Save Menu
    document.getElementById('save-menu').style.display = 'flex';
    GameMenuNav.reset(); // Reset selection to top
    
    // 3. Update Slot Text
    for(let i=1; i<=3; i++) {
        let raw = localStorage.getItem('rpg_save_slot_' + i);
        let txt = "Empty File";
        if(raw) {
            try {
                let d = JSON.parse(raw);
                txt = `${(d.meta.class||'?').toUpperCase()} Lv.${d.meta.lvl} (Day ${d.meta.day})`;
            } catch(e) { txt = "Corrupted"; }
        }
        document.getElementById('save-info-' + i).innerText = txt;
        
        // Highlight active slot
        let color = (S.curSlot === 'rpg_save_slot_' + i) ? '#ffd700' : '#888';
        document.getElementById('save-info-' + i).style.color = color;
    }
}

function finalSave(slotId) {
    saveGame(slotId);
    S.curSlot = slotId;
    document.getElementById('save-menu').style.display = 'none';
    S.paused = false; 
}







// --- NEW CONFIRMATION SYSTEM ---
// --- IN-GAME MENU NAVIGATION (Pause & Save) ---
const GameMenuNav = {
    selIdx: 0,
    
    // Call this when opening a menu to reset selection
    reset: function() {
        this.selIdx = 0;
        this.update();
    },







   handleInput: function(key, menuId) {
        const menu = document.getElementById(menuId);
        if(!menu) return;

        // Get all clickable buttons in this menu
        const btns = Array.from(menu.querySelectorAll('.m-btn, .quit-btn, .save-slot'));
        const visibleBtns = btns.filter(b => b.style.display !== 'none' && b.offsetParent !== null);
        
        if(visibleBtns.length === 0) return;

        // 1. CLICK ACTION
        if(key === ' ' || key === 'enter') {
            if(visibleBtns[this.selIdx]) visibleBtns[this.selIdx].click();
            return;
        }

        // 2. SPATIAL NAVIGATION (Grid Logic)
        const cur = visibleBtns[this.selIdx] || visibleBtns[0];
        const r1 = cur.getBoundingClientRect();
        const c1 = { x: r1.left + r1.width/2, y: r1.top + r1.height/2 };

        let best = null, minDist = Infinity;

        visibleBtns.forEach((t, i) => {
            if(i === this.selIdx) return;
            const r2 = t.getBoundingClientRect();
            const c2 = { x: r2.left + r2.width/2, y: r2.top + r2.height/2 };
            
            const dx = c2.x - c1.x; 
            const dy = c2.y - c1.y; 

            let isValid = false;
            let weightedDist = Infinity;

            // WEIGHTED LOGIC: Heavily penalize moving in the wrong axis
            if(key === 'arrowdown' && dy > 10) { 
                isValid = true;
                weightedDist = Math.abs(dy) + (Math.abs(dx) * 10); 
            }
            if(key === 'arrowup' && dy < -10) { 
                isValid = true;
                weightedDist = Math.abs(dy) + (Math.abs(dx) * 10);
            }
            if(key === 'arrowright' && dx > 10) { 
                isValid = true;
                weightedDist = Math.abs(dx) + (Math.abs(dy) * 10);
            }
            if(key === 'arrowleft' && dx < -10) { 
                isValid = true;
                weightedDist = Math.abs(dx) + (Math.abs(dy) * 10);
            }

            if(isValid && weightedDist < minDist) { 
                minDist = weightedDist; 
                best = i; 
            }
        });

        // 3. APPLY MOVEMENT
        if(best !== null) {
            this.selIdx = best;
            if(typeof AudioSys !== 'undefined') AudioSys.play('menu_scroll');
            this.update(visibleBtns);
        }
    },








    update: function(btns) {
        // Clear global selections inside menus
        document.querySelectorAll('.m-btn.selected, .quit-btn.selected, .save-slot.selected').forEach(el => el.classList.remove('selected'));
        
        if(!btns) {
            // Auto-detect if buttons aren't provided
            const openMenu = document.getElementById('pause-menu').style.display !== 'none' ? document.getElementById('pause-menu') :
                             document.getElementById('save-menu').style.display !== 'none' ? document.getElementById('save-menu') : null;
            if(!openMenu) return;
            btns = Array.from(openMenu.querySelectorAll('.m-btn, .quit-btn, .save-slot'));
            btns = btns.filter(b => b.style.display !== 'none' && b.offsetParent !== null);
        }

        if(btns[this.selIdx]) btns[this.selIdx].classList.add('selected');
    }
};

// --- NEW CONFIRMATION SYSTEM ---
const ConfirmBox = {


    targetSlot: null,
    targetTextId: null,
    selection: 1, // 0=Yes, 1=No (Default to No for safety)

    // Open the custom window
    open: function(slotId, textId) {
        this.targetSlot = slotId;
        this.targetTextId = textId;
        this.selection = 1; // Default to "No"
        
        document.getElementById('confirm-modal').style.display = 'flex';
        if(typeof AudioSys !== 'undefined') AudioSys.play('error'); // Alert sound
        this.updateVisuals();
    },

    // Handle the Yes/No decision
    resolve: function(result) {
        document.getElementById('confirm-modal').style.display = 'none';
        
        if(result) {
            // --- PERFORM DELETE ---
            // --- PERFORM DELETE ---
            localStorage.removeItem(this.targetSlot);
            // Changed from 'break' to 'btn_click' (Soft sound)
            if(typeof AudioSys !== 'undefined') AudioSys.play('btn_click'); 

            // Refresh UI based on where we are

            // Refresh UI based on where we are
            if (typeof Menu !== 'undefined' && document.getElementById('page-load').classList.contains('active')) {
                Menu.updateSlots();
            } else {
                let el = document.getElementById(this.targetTextId);
                if(el) { el.innerText = "Empty File"; el.style.color = "#888"; }
            }
        }
    },

    // Keyboard Input for the Modal
    handleInput: function(key) {
        if(key === 'arrowleft' || key === 'arrowright') {
            this.selection = (this.selection === 0) ? 1 : 0;
            if(typeof AudioSys !== 'undefined') AudioSys.play('menu_scroll');
            this.updateVisuals();
        }
        if(key === ' ' || key === 'enter') {
            this.resolve(this.selection === 0);
        }
        if(key === 'escape') {
            this.resolve(false);
        }
    },

    // Mouse Hover support
    hover: function(idx) {
        this.selection = idx;
        this.updateVisuals();
    },

    // Update Red/Grey colors
    updateVisuals: function() {
        const yes = document.getElementById('conf-yes');
        const no = document.getElementById('conf-no');
        
        yes.classList.remove('selected');
        no.classList.remove('selected');

        if(this.selection === 0) yes.classList.add('selected');
        else no.classList.add('selected');
    }
};

// --- NEW WRAPPER FUNCTION ---
function deleteSlot(slotId, textId) {
    // Instead of browser popup, open our custom ConfirmBox
    ConfirmBox.open(slotId, textId);
}








function closeSaveMenu() {
    document.getElementById('save-menu').style.display = 'none';
    document.getElementById('pause-menu').style.display = 'flex';
}











// --- INITIALIZE FARM SYSTEM ---
// The FarmSystem class is defined in farm.js
let farmSys = null;






try {
    farmSys = new FarmSystem(S);
} catch(e) { console.log("FarmSystem not loaded yet. Waiting for farm.js..."); }



window.onkeydown = e => {
    const k = e.key.toLowerCase();







    // --- 00. GLOBAL MODAL PRIORITY ---
    if(document.getElementById('confirm-modal').style.display === 'flex') {
        e.preventDefault();
        ConfirmBox.handleInput(k);
        return;
    }

    // --- 0. MAIN MENU NAVIGATION ---
    if(document.getElementById('main-menu').style.display !== 'none') {
        if(typeof Menu !== 'undefined') Menu.handleInput(e);
        return;
    }

    // --- A. WIN SCREEN ---
    if(document.getElementById('win-screen').style.display === 'flex') {
        if(k === ' ' || k === 'enter') document.getElementById('btn-win').click();
        return;
    }

    // --- B. DEATH SCREEN ---
    if(document.getElementById('death-screen').style.display === 'flex') {
        if(k === ' ' || k === 'enter') document.getElementById('btn-die').click();
        return;
    }

    // --- C. PAUSE MENU ---
    if(document.getElementById('pause-menu').style.display === 'flex') {
        if(k === 's' || k === 'escape') { togglePauseMenu(); return; }
        e.preventDefault(); // Stop walking while in menu
        GameMenuNav.handleInput(k, 'pause-menu');
        return;
    }

    // --- D. SAVE MENU ---
    if(document.getElementById('save-menu').style.display === 'flex') {
        if(k === 'escape') { closeSaveMenu(); return; }
        e.preventDefault();
        GameMenuNav.handleInput(k, 'save-menu');
        return;
    }

    // 1. [S] KEY (Global)
    if(e.key.toLowerCase() === 's') {
        togglePauseMenu();
        return;
    }
    // 2. PAUSE CHECK (Stop everything else if menu is open)
    if(S.paused) {
        if(e.key === 'Escape') togglePauseMenu();
        return;
    }





/* --- START OF NEW CODE: SPACE TO CLOSE CHAT --- */
    // If Space/Enter is pressed AND chat is visible AND we aren't locked -> Close immediately
    if ((k === ' ' || k === 'enter') && 
       (document.getElementById('rpg-chat').style.display !== 'none' || 
        document.getElementById('special-chat').style.display !== 'none') && 
        S.ui !== 'locked') { // <--- ADD THIS CHECK!
        
        // 1. Force hide boxes
        document.getElementById('rpg-chat').style.display = 'none';
        document.getElementById('special-chat').style.display = 'none';
        
        // 2. Clear the auto-close timer (Stop it from firing later)
        if(S.chatTo) clearTimeout(S.chatTo);
        
        return; // Stop here
    }
    /* --- END OF NEW CODE --- */










// --- PASTE THIS ---
    if (S.world === 'farm') {




        Region9Farm.handleInput(e);
        return; // Don't do RPG combat stuff
    }
    // ------------------

    S.input.keys[e.key.toLowerCase()] = true;
    
    if(e.code==='Space') {
        if (S.world === 'main') interact();
        // Delegate to Farm Module
        else if (S.world === 'farm' && farmSys) farmSys.handleInput(e);
    }

   if (S.world === 'main') {
        // --- PREVENT ATTACKING WHILE CHATTING ---
        let chatBox = document.getElementById('rpg-chat');
        let spBox = document.getElementById('special-chat');
        
        let isStandardOpen = chatBox.style.display !== 'none';
        let isSpecialOpen = spBox.style.display !== 'none';
        let speakerName = document.getElementById('chat-name').innerText;

        // LOGIC: Lock if (Special Box) OR (Standard Box AND Not System AND Not Tutorial)
        let isChatting = isSpecialOpen || 
                         (isStandardOpen && speakerName !== "SYSTEM" && !chatBox.classList.contains('no-lock'));

        if (!isChatting) {
            if(['z','x','c','v','b','n'].includes(e.key.toLowerCase())) cast(e.key.toLowerCase());
        }

        // ---------------------------------------------
    }






    // Delegate Tool Selection / Menu hotkeys to Farm Module
    if (S.world === 'farm' && farmSys) {
        farmSys.handleInput(e);
    }
};
window.onkeyup = e => S.input.keys[e.key.toLowerCase()] = false;

// MANDATORY FIX: Stop moving if window loses focus
window.addEventListener('blur', () => { S.input.keys = {}; });

// 1. SHARED SETUP (Runs for New Game AND Load Game)
// 1. SHARED SETUP (Runs for New Game AND Load Game)
// 1. SHARED SETUP (Runs for New Game AND Load Game)
function initSharedState() {
    S.gameOver = false;
    S.paused = false;
    S.input.keys = {};
    
    // DEFAULT SLOT: Removed to prevent overwriting Slot 1 on New Game.
    // S.curSlot is now explicitly managed in startNewGame (null) or loadGame (set).

    // Link Audio System
    S.audio = AudioSys;




    // Initialize Farm System if needed
    if(!farmSys && typeof FarmSystem !== 'undefined') farmSys = new FarmSystem(S);
}

// 2. START NEW GAME (Runs ONLY when clicking "Start New Game")
// 2. START NEW GAME (Runs ONLY when clicking "Start New Game")
// 2. START NEW GAME (Runs ONLY when clicking "Start New Game")
// FIND THIS FUNCTION
function startNewGame(cls) {
    // A. Visuals & Audio
    AudioSys.play('class_choose');
    AudioSys.warmUp();

// --- PASTE THIS NEW LINE HERE ---
    if(AudioSys.unlockAmbience) AudioSys.unlockAmbience();
    // --------------------------------

    // B. Run Shared Setup
    initSharedState();

    // C. Reset Player & World (The "Wipe")
    S.curSlot = null; 
    S.p.class = cls;
    
    // --- ADD THIS LINE HERE ---
    S.p.hidden = false; 
    // --------------------------

    S.p.xp = 0; S.p.lvl = 1; S.p.killLog = []; S.p.actLog = {};
    S.p.cds = {}; S.p.buffs = {};
    
    // ... rest of the function ...    


     S.unlockedRegion9 = false; 
    S.bossDead = false;
    S.epilogueSeen = false; // <--- ADD THIS LINE HERE
    // --- FIX: FULL FARM RESET ---
    // Overwrite the dirty farm state with fresh default values
    S.farm = {
        day: 1, money: 5000, houseLevel: 1, fieldLevel: 1, gardenLevel: 1,
        time: 360, water: 30, weather: 'sun',
        generated: false, // Force map regeneration
        tutorialStep: 0,
        
        plots: {}, debris: {}, fences: {}, structures: {}, letterData: {},
        
        inventory: { 
            carrot_seeds: 5, wood: 0, stake: 0, fish: 0, brick: 0,
            carrot: 0, potato: 0, corn: 0, tomato: 0,
            rose: 0, sunflower: 0, tulip: 0, lavender: 0,
            milk: 0, egg: 0, apple: 0, orange: 0,
            letter_brick: 0, star: 0, teddy: 0, qbox: 0, coin: 0,
            bal_r: 0, bal_y: 0, bal_b: 0
        },
        storage: {},
        
        // Reset Tools
        tools: { hoe: 1, sickle: 1, axe: 1, hammer: 1, water: 1, rod: 1 },
        toolNames: ['Hand','Hoe','Hammer','Axe','Sickle','Water','Rod',''], 
        toolIcons: ['‚úã','‚õèÔ∏è','üî®','ü™ì','‚úÇÔ∏è','üöø','üé£',''],
        keyMap:    ['1','2','3','4','Q','W','E','R'],
        toolIndex: 0
    };
    // ----------------------------




    // Apply Class Stats
    Object.assign(S.p, CLASSES[cls]);
    S.p.maxHp = CLASSES[cls].hp; S.p.hp = S.p.maxHp;

    // D. GENERATE WORLD (This is what we SKIP when loading!)
    S.audio.playBGM('adventure');
    genMap(); 
    
    // E. Start Loop
    updateUI(); 
    
    // (Testing code removed: Bridge is now hidden by default)

   document.getElementById('main-menu').style.display='none';
    
    // VISUAL ARROWS: Instantly recognizable
    // ORDER CHANGED: Arrows -> ZXC -> Space
    showChat("Noah", "Use <span style='color:#ffd700'>[‚Üê ‚Üë ‚Üì ‚Üí]</span> to move. Press <span style='color:#ff5252'>Z / X / C</span> to attack!<br><span style='color:#ffd700'>[SPACE]</span> to talk.", true);
    
    S.run = true; 
    loop();
}








function spawnRegionFeatures(centerX, centerY, radius, type, configs, targetTerrain) {
    configs.forEach(conf => {
        let placed = 0;
        let attempts = 0;
        
        while(placed < conf.count && attempts < 500) { 
            attempts++;
            
            // Random Position
            let rx = Math.floor(centerX - radius + Math.random() * (radius*2));
            let ry = Math.floor(centerY - radius + Math.random() * (radius*2));
            let size = conf.size;

            let safe = true;

            // 1. GLOBAL SAFETY: Don't block the Path to Region 8 (East)
            // Region 7 center is x=25. Region 8 is to the East (Right).
            // We forbid spawning anything past x=40 in the Lava zone.
            if(targetTerrain === 7 && rx + size > 40) { // 7 is T.LAVA
                 safe = false; 
            }

            if(safe) {
                for(let y=ry; y<ry+size; y++) {
                    for(let x=rx; x<rx+size; x++) {
                        // Map Bounds
                        if(x<0||y<0||x>=MAP_S||y>=MAP_S) { safe=false; break; }
                        
                        let t = S.map[y*MAP_S+x];

                        // Terrain Match
                        if(t !== targetTerrain) { safe=false; break; }

                        // 2. BLOCK SAFETY: Never touch Letter Bricks or Roads
                        if(t === 13) { safe=false; break; } // T.BLOCK (Letters)
                        if(t === 9 || t === 10 || t === 11) { safe=false; break; } // ROAD, BRIDGE, LOCK
                        if(t === 12) { safe=false; break; } // BEDROCK

                        // 3. Entity Overlap
                        for(let e of S.ents) {
                            if(x >= e.x && x < e.x+e.w && y >= e.y && y < e.y+e.h) { safe=false; break; }
                        }
                        if(!safe) break;
                    }
                    if(!safe) break;
                }
            }

            if(safe) {
                addEnt('env', type, rx, ry, size, size);
                placed++;
            }
        }
    });
}





function unlockRegion9() {
    if (S.unlockedRegion9) return;
    S.unlockedRegion9 = true;

    // 1. Ëµ∑ÈªûÔºö‰øùÊåÅË∑ü Region 7‚Üí8 Âêå‰∏ÄÊ¢ùÊ∞¥Âπ≥Á∑öÔºà‰∏≠ÂøÉ y=125Ôºâ
    const startX = 85;
    const startYTop = 124;   // Ë∑ØÁöÑ„ÄåÊúÄ‰∏äÈù¢ÈÇ£Ê†º„ÄçÔºå‰∏âÊ†ºÈ´ò ‚áí ‰∏≠ÂøÉÂú® 125

    // 2. ÁµÇÈªûÔºöË¶ÅÊé•Âà∞ Region 9 ÁâÜÈôÑËøëÔºå‰ΩÜÂÖ•Âè£‰∏≠ÂøÉË¶ÅÂú®„ÄåÈ†ÇÁâÜ‰∏ã 15 Ê†º„Äç
    //    Region 9 È†ÇÁâÜÂú® y = 120 ‚áí 120 + 15 = 135
    const endX      = 120;
    const endYTop   = 134;   // ‰∏âÊ†ºÈ´òÔºö134,135,136 ‚áí ‰∏≠ÂøÉ 135

    const steps = endX - startX;          // 35
    const dyTop  = endYTop - startYTop;   // 134 - 124 = 10

    // 3. Áï´‰∏ÄÊ¢ù 3 Ê†ºÂéöÁöÑÊ©ãÔºåÂæû (85,124~126) ÊñúËµ∞Âà∞ (120,134~136)
    for (let i = 0; i <= steps; i++) {
        const x = startX + i;

        // Á∑©ÊÖ¢Âêë‰∏ãÔºö‰æù x Á∑öÊÄßË£úÈñì yÔºàÊúÄ‰∏äÈù¢ÈÇ£Ê†ºÔºâ
        const yTop = startYTop + Math.floor(dyTop * i / steps);

        for (let w = 0; w < 5; w++) {
            const y = yTop + w;                       // ‰∏âÊ†ºÈ´ò
            if (y < 0 || y >= MAP_S) continue;

            const idx = y * MAP_S + x;
        S.map[idx] = T.BRIDGE;
    }
}

// REFRESH THE FAKE MAP
    drawStyledMinimap();






    showChat("SYSTEM", "The Chaos Titan falls... A bridge to a new land appears!");
    popText(S.p.x, S.p.y, "REGION 9 UNLOCKED", "#2ecc71");

    // (Minimap reveal removed)
}


function updateUI() {
    // --- 1. FARM MODE ---
    // Only show Farm UI if we are actually inside the gate (x > 118)
    if(S.world === 'farm' && S.p.x > 118) {
        
        // A. CLEAR STUCK STYLES
        let bar = document.getElementById('skill-bar');
        if(bar) {
            bar.style.display = ''; 
            bar.style.gridTemplateColumns = ''; 
            bar.style.gridTemplateRows = '';
            bar.style.top = ''; 
            bar.style.left = '';
        }

        // B. VISIBILITY: HIDE RPG UI, SHOW FARM UI
        
        // 1. Hide the RPG Top HUD (HP, EXP, Level, RPG Minimap)
        let rpgHud = document.getElementById('hud-top');
        if(rpgHud) rpgHud.style.display = 'none';

        // 2. Hide Quest Box
        let quest = document.getElementById('quest-panel');
        if(quest) quest.style.display = 'none';

        // 3. Show Farm Day/Money Stats (REMOVED: Now drawn on Canvas)
        // (Old code for 'farm-stats' was deleted here to prevent crash)

        // C. Enable Farm CSS & Layers
        let fs = document.getElementById('farm-styles');
        if(fs) fs.disabled = false;

               
        // Show Farm Hints (Space/Hand)
        ['space-hint', 'screen-hint'].forEach(id => {
            let el = document.getElementById(id);
            if(el) el.style.display = 'flex';
        });

        // D. Update Content
        if(typeof Region9Farm !== 'undefined' && Region9Farm.updateFarmUI) {
            Region9Farm.updateFarmUI();
        } 
        else if(farmSys) {
            farmSys.updateFarmUI();
        }
        return;
    }

    // --- 2. MAIN WORLD MODE ---
    
    // A. VISIBILITY: SHOW RPG UI
    
    // 1. Show RPG Top HUD (HP, EXP, Level)
    let rpgHud = document.getElementById('hud-top');
    if(rpgHud) rpgHud.style.display = 'flex'; 

    // 2. Show Quest Box
   // 2. Show Quest Box & Reset Title
    let quest = document.getElementById('quest-panel');
    if(quest) {
        quest.style.display = 'block';
        // FORCE THE TITLE BACK TO RPG MODE
        if(quest.children[0]) quest.children[0].innerText = "CURRENT MISSION"; 
        quest.children[1].style.color = "#eee"; // Reset color to white
    }

    // 3. Hide Farm UI
    // [CRASH FIX]: We deleted the specific line that tried to hide 'farm-stats'
    
    
    // Hide Farm Hints
    ['space-hint', 'screen-hint'].forEach(id => {
        let el = document.getElementById(id);
        if(el) el.style.display = 'none';
    });

    // Disable Farm CSS
    let fs = document.getElementById('farm-styles');
    if(fs) fs.disabled = true;

    // --- 3. REBUILD SKILL BAR (RPG Style) ---
    let barEl = document.getElementById('skill-bar'); 
    barEl.innerHTML='';
    
    // Force Horizontal Layout
    barEl.style.display = 'flex'; 
    barEl.style.gridTemplateColumns = 'none'; 
    barEl.style.gridTemplateRows = 'none';

    CLASSES[S.p.class].skills.forEach(s => {
        let d=SKILLS[s];
        let border = d.ult ? 'border-color:#f0f;' : '';
        let isLocked = d.locked && S.qStep <= 4; 
        let lockClass = isLocked ? 'locked' : '';
        barEl.innerHTML += `<div class="slot ${lockClass}" style="${border}">
            <span class="key-hint">${d.k}</span>
            <div class="icon">${d.icon}</div>
            <div class="cd" id="cd-${s}"></div>
        </div>`;
    });
}

function addNPC(name, x, y, txt, gender, qId) { 
    S.ents.push({
        type:'npc', name, txt, x, y, gender, qId, h:1.5, 
        moveTimer: Math.random()*120, isWalking: false, moveDir: 0
    }); 
}

function genMap() {
    S.map = new Uint8Array(MAP_S * MAP_S).fill(T.WATER);
    S.ents = []; S.locks = []; S.p.killLog = []; S.p.actLog = {};
    S.wordData = []; 
    S.qStep = 0; S.qProg = 0;

    let zones = [
        { x:25, y:25, t:T.GRASS, r:20 }, { x:75, y:25, t:T.FOREST, r:18 },
        { x:125, y:25, t:T.SAND, r:18 }, { x:125, y:75, t:T.RUINS, r:18 },
        { x:75, y:75, t:T.SWAMP, r:18 }, { x:25, y:75, t:T.SNOW, r:18 },
        { x:25, y:125, t:T.LAVA, r:18 }, { x:75, y:125, t:T.VOID, r:18 }
    ];

    zones.forEach(z => {
        for(let y=z.y-z.r; y<=z.y+z.r; y++) for(let x=z.x-z.r; x<=z.x+z.r; x++) {
            if(x<0||y<0||x>=MAP_S||y>=MAP_S) continue;
            let d = Math.hypot(x-z.x, y-z.y);
            if(d < z.r) {
                S.map[y*MAP_S+x] = z.t;
                if(d > z.r - 2) S.map[y*MAP_S+x] = T.BEDROCK; 
            }
        }
    });

    for(let i=-8; i<=8; i++) {
        S.map[25*MAP_S + (25+i)] = T.ROAD; 
        S.map[(25+i)*MAP_S + 25] = T.ROAD; 
    }
    
    

    addBlockWords(18, 33, "THE TUCK SHOP", "gold"); 
    addBlockWords(45, 27, "STUDIO CLASSROOM", "red"); 
    addBlockWords(92, 27, "LET'S TALK IN ENGLISH", "blue");
    addBlockWords(88, 73, "HEAVENLY MELODY", "purple");
    addBlockWords(42, 77, "A FRIEND FOR LIFE", "green");
    addBlockWords(40, 122, "STUDIO CLASSROOM", "gold");





    zones.forEach(z => { if(z.t !== T.GRASS) addEnt('struct', 'Healing Crystal', z.x-5, z.y+5); });
    addEnt('struct', 'TuckShop', 18, 28); 
    addEnt('struct', 'Fountain', 24, 24); 
    addEnt('struct', 'House', 16, 18); addEnt('struct', 'Church', 32, 18);
    addEnt('struct', 'House', 32, 28);





// --- [FIX] SPAWN IMPRESSIVE FEATURES (Safe from text) ---
    // Config: 1 Giant(6x6), 3 Huge(4x4), 1 Big(3x3), 5 Small(2x2)
    const bigProps = [
        {count:1, size:6}, 
        {count:3, size:4}, 
        {count:1, size:3}, 
        {count:5, size:2}
    ];

    // Region 5: Swamp (75, 75) - Pass T.SWAMP
    spawnRegionFeatures(75, 75, 16, 'big_mud', bigProps, T.SWAMP);

    // Region 7: Lava (25, 125) - Pass T.LAVA
    spawnRegionFeatures(25, 125, 16, 'lava_crater', bigProps, T.LAVA);
    // -------------------------------------------------------








    
    for(let i=0; i<zones.length-1; i++) connect(zones[i], zones[i+1], i);

    // 1. Draw the New Stylized Map
    drawStyledMinimap();

    // 2. Spawn Mobs & Nature (Logic Only, No Drawing)
    for(let y=0; y<MAP_S; y++) for(let x=0; x<MAP_S; x++) {
        let t = S.map[y*MAP_S+x];
        
        if([T.WATER, T.ROAD, T.BRIDGE, T.LOCK, T.BEDROCK, T.BLOCK].includes(t)) continue;
        if(Math.abs(x - 25) < 3 && Math.abs(y - 35) < 3) continue; 
        if(x > 115 && y > 115) continue; 

        // --- SAFETY: CLEAR TUCK SHOP FRONT (SIMON'S AREA) ---
        // Forbid trees/rocks on x=17 to 24 at y=32
        if(y === 32 && x >= 17 && x <= 24) continue;
        // ----------------------------------------------------

        if(solid(x, y, null)) continue;
        
        // --- CHECK: Is this tile inside a Big Mud or Volcano? ---
        let insideFeature = S.ents.some(e => 
            (e.kind === 'big_mud' || e.kind === 'lava_crater') && 
            x >= e.x && x < e.x + e.w && 
            y >= e.y && y < e.y + e.h
        );

        // Only spawn rocks/trees if NOT inside a big feature
        if(!insideFeature && Math.random() < 0.1) {
            addEnt('env', getEnv(t), x, y);
        }
        
        if(Math.random() < 0.025) { 
            let distFromSpawn = Math.hypot(x - 25, y - 32); 
            if(distFromSpawn > 8) { 
                let mobType = getMob(t); 
                if(mobType) addMob(mobType, x, y);
            }
        }
    }

   // --- REPLACE TABLETS WITH STATUES (TIGHT SANCTUARY LAYOUT) ---
    // Center X is 125. We place them just slightly off-center so the path is open.
    
    // 1. Top LEFT (Moved from 129 to 121)
    addObj("Angel Statue", 121, 64, "The Guardian of the East is restored.");
    
    // 2. Middle Left - Moved closer (121)
    addObj("Angel Statue", 121, 78, "The Guardian of the West shines bright."); 
    
    // 3. Middle Right - Moved closer (129)
    addObj("Angel Statue", 129, 72, "The Southern Guardian awakes.");

    // --- CLEANUP DEBRIS (Keep this) ---
    S.ents = S.ents.filter(e => {
        if(e.type !== 'env') return true; 
        let tooClose = S.ents.some(statue => statue.name === 'Angel Statue' && Math.hypot(e.x - statue.x, e.y - statue.y) < 2.5);
        return !tooClose;
    });

    addMob("Slime King", 25, 35, true); 
    addMob("Scorpion King", 125, 25, true);
    addMob("Hydra", 75, 75, true); 
    addMob("Red Dragon", 25, 125, true);
    addMob("Chaos Titan", 75, 125, true);

    for(let i=0; i<6; i++) addItem("Medic Herb", 70+(Math.random()*10), 20+(Math.random()*10));

    addObj("Frozen Friend", 20, 70, "You saved a friend!"); 
    addObj("Frozen Friend", 30, 80, "Brrr... thanks!"); 
    addObj("Frozen Friend", 25, 75, "Friend for life!");

    // OLD: "Ah, a new hero..."
    // NEW: Teaches the Save System immediately
    addNPC("Elder Man", 24, 21, "Welcome, hero! Press <span style='color:#ffd700'>[S]</span> to Open Menu and <span style='color:#ffd700'>SAVE</span> your journey!", 'M', 0);


    addNPC("Simon", 20, 32, "Suce ma bite, I have the best restaurant in Margaret River.", 'M');
    addNPC("David", 28, 20, "Now I‚Äôm the only David at ORTV.", 'M', -1);
    addNPC("Grace", 28, 26, "‚ÄúHow abundant are the good things that you have stored up.‚Äù ‚Äî Psalm 31:19 (NIV)", 'F');
    addNPC("Fu Jing", 30, 20, "Busy, busy‚Äîbut let‚Äôs hang out sometime.", 'M'); 
    addNPC("Steve", 44, 25, "Hi, mate. I'm the best Chef in Port Douglas.", 'M');
    addNPC("Pam", 46, 25, "‚ÄúBelieve in the Lord Jesus, and you will be saved‚Äîyou and your household.‚Äù ‚Äî Acts 16:31 (NIV)", 'F');
    addNPC("Nicolas", 50, 25, "Bonjour, mon ami ! Quel monde magnifique pour une aventure !", 'M');
    addNPC("Sukie", 38, 33, "‚ÄúEven though I walk through the darkest valley, I will fear no evil, for you are with me.‚Äù ‚Äî Psalm 23:4 (NIV)", 'F', 0);
    addNPC("Jack", 40, 28, "‚ÄúTrust in the Lord with all your heart‚Ä¶ and he will make your paths straight.‚Äù ‚Äî Proverbs 3:5‚Äì6 (NIV)", 'M');
    addNPC("John", 42, 28, "I'm Jack's brother.", 'M');
    addNPC("Daphne", 40, 30, "Piano is a beautiful art. Remember to eat something‚Äîdon‚Äôt go hungry.", 'F', -1);
    addNPC("Tomo Chiu", 72, 28, "I love the feeling of riding a scooter while traveling.", 'M');
    addNPC("Shummi", 78, 22, "‚ÄúSurely your goodness and love will follow me all the days of my life.‚Äù ‚Äî Psalm 23:6 (NIV)", 'F', -1);
    addNPC("Sharon", 115, 25, "‚ÄúHe leads me beside quiet waters.‚Äù ‚Äî Psalm 23:2 (NIV)", 'F');
    addNPC("Avon", 120, 30, "‚ÄúGod is our refuge and strength, an ever-present help in trouble.‚Äù ‚Äî Psalm 46:1 (NIV)", 'F', -1);
    addNPC("Fang", 125, 60, "I love classical music and detective novels.", 'M');
    addNPC("Angus", 125, 72, "Enjoy your life while you‚Äôre young.", 'M');
    addNPC("Bohan", 75, 70, "I wish I could fly like a bird.", 'M');
    addNPC("Pauline", 85, 75, "Josh, look! This is so fun‚Äîjust like Costa Rica.", 'F', -1);
    addNPC("Josh", 87, 75, "Lovely, Pauline! I‚Äôll take some photos for you.", 'M', -1);
    addNPC("A Gan", 35, 75, "I'm good at peeling oranges.", 'F');
    addNPC("Jussi", 28, 78, "Moi moi, this is nothing. Finland is warm.", 'M');
    addNPC("Mary", 25, 115, "Never regret‚ÄîGod has a plan for me, for you, for everyone.", 'F');
    addNPC("Mark", 28, 115, "Have you seen my adorable son, Levi?", 'M', -1);
     addNPC("Jingle", 22, 115, "Phew! Singapore is just as hot as a volcano!", 'F');
    addNPC("Corni", 46, 125, "„Åì„Çì„Å´„Å°„ÅØ (konnichiwa)", 'M');
    addNPC("Bian Bain", 48, 125, "Do you know how to find Orion? Look for three bright stars in a line.", 'M');
    
    S.p.x = 25; S.p.y = 32;

// LOOK FOR THIS PART AT THE END OF genMap function:
    if (typeof Region9Farm !== 'undefined') {
        Region9Farm.init(S); // Send main game data to farm
    }
}





function connect(z1, z2, lockId) {
    let x = Math.floor(z1.x), y = Math.floor(z1.y);
    let tx = Math.floor(z2.x), ty = Math.floor(z2.y);
    let path = [];
    let steps = 0;
    while((x !== tx || y !== ty) && steps < 500) {
        if(x < tx) x++; else if(x > tx) x--;
        else if(y < ty) y++; else if(y > ty) y--;
        path.push({x,y});
        steps++;
    }
    let mid = path[Math.floor(path.length/2)];

    path.forEach(p => {
        for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
            let idx = (p.y+j)*MAP_S+(p.x+i);
            S.map[idx] = T.BRIDGE;
        }
    });

    if(mid) {
        let isVert = Math.abs(path[0].y - path[path.length-1].y) > Math.abs(path[0].x - path[path.length-1].x);
        for(let i=-1; i<=1; i++) {
            let lx = mid.x + (isVert ? i : 0);
            let ly = mid.y + (isVert ? 0 : i);
            S.map[ly*MAP_S+lx] = T.LOCK;
            S.locks.push({x:lx, y:ly, id:lockId});
        }
    }
}

function getEnv(t) {
    let r = Math.random();
    if(t===T.GRASS) return r<.5 ? 'tree_g' : 'flower'; 
    if(t===T.FOREST) return r<.6 ? 'tree_f' : 'stump';
    if(t===T.RUINS) return r<.5 ? 'rubble' : 'column';
    if(t===T.SAND) return r<.5 ? 'cactus' : 'rock';
    
  // [FIX] SWAMP: Only dead trees (Big mud is handled separately now)
    if(t===T.SWAMP) return 'dead_tree';
    
    if(t===T.SNOW) return 'ice_crystal';
    
    // [FIX] LAVA: Only rocks (Big craters handled separately now)
    if(t===T.LAVA) return 'magma_rock';
    
    if(t===T.VOID) return 'void_shard';
    return 'rock';
}

function getMob(t) {
    let r = Math.random();
    if(t===T.GRASS) return r<.5 ? 'Slime' : 'Goblin'; 
    if(t===T.FOREST) return r<.5 ? 'Boar' : 'Ent';
    if(t===T.SAND) return r<.5 ? 'Scorpion' : 'Mummy'; 
    if(t===T.RUINS) return r<.5 ? 'Skeleton' : 'Bat';
    if(t===T.SWAMP) return r<.5 ? 'Basilisk' : 'Mosquito'; 
    if(t===T.SNOW) return r<.5 ? 'Yeti' : 'Ice Spirit';
    if(t===T.LAVA) return r<.5 ? 'Magma' : 'Fire Imp'; 
    if(t===T.VOID) return r<.5 ? 'Stone Golem' : 'Cinder Wolf';
    return null;
}

// [FIX] Updated to accept custom width/height (w, h) arguments
function addEnt(type, kind, x, y, w, h) { 
    // Default sizes if w/h are not provided
    if(!w) w=1; 
    if(!h) h=1; 

    // Legacy overrides (only used if w/h are not passed)
    if(arguments.length < 5) {
        if(kind==='Fountain'){w=3;h=3;} 
        if(kind==='House'){w=4;h=4;}
        if(kind==='FarmHouse'){w=6;h=5;}
        if(kind==='TuckShop'){w=5;h=4;}
        if(kind==='Church'){w=5;h=6;}
        if(kind==='Healing Crystal'){w=2;h=2;}
        if(['tree_g','tree_f','column','cactus','dead_tree','ice_crystal','void_shard'].includes(kind)) h=1.5;
    }

    S.ents.push({type, kind, x, y, w, h}); 
}


function addMob(name, x, y, boss=false) {
    // 1. BASE STATS
    let hp = 600, dmg = 15; 
    let w=1, h=1;

    if(boss) {
        // Default Boss Stats
        dmg = 45; w=2; h=2;
        
        // --- BOSS SPECIFIC OVERRIDES ---
        if(name==="Slime King") {
            hp = 3500; 
        }
        else if(name==="Chaos Titan") { 
            hp = 18000; // High HP
            dmg = 80;   // High Damage
            w = 4;      // Huge Size
            h = 4; 
        } 
        else {
            // Scorpion, Hydra, Dragon
            hp = 9000; 
        }
    } else {
        // --- NORMAL MOBS ---
        if(name==='Goblin') { hp=600; dmg=20; }
        if(name==='Ent') { hp=800; dmg=30; }
        if(name.includes('Slime')) { hp=600; dmg=18; }
        
        if(name==='Scorpion' || name==='Mummy') { hp=1000; dmg=30; }
        if(name==='Skeleton' || name==='Bat') { hp=1000; dmg=30; }
        if(name==='Mosquito') { hp=800; dmg=25; }
        if(name==='Basilisk') { hp=1600; dmg=35; }

        if(name==='Yeti' || name==='Ice Spirit') { hp=2400; dmg=45; }
        if(name==='Magma' || name==='Fire Imp') { hp=2800; dmg=55; }

        if(name==='Stone Golem' || name==='Cinder Wolf') { hp=4000; dmg=70; }
    }
    
    // 3. SPAWN THE MOB (Ensure MaxHP matches HP)
    S.ents.push({
        type:'mob', 
        name, x, y, w, h, 
        hp: hp, 
        maxHp: hp, // <--- CRITICAL: This must match 'hp' exactly
        dmg, boss, 
        aggro:0, 
        status:{}
    });
}



function addBlockWords(x, y, txt, theme) {
    for(let i=0; i<txt.length; i++) {
        let idx = y*MAP_S + (x+i);
        if(txt[i] !== ' ') {
            S.map[idx] = T.BLOCK; 
            S.wordData[idx] = { char:txt[i], theme }; 
        }
    }
}

function addItem(name, x, y) { S.ents.push({type:'item', name, x, y}); }
function addObj(name, x, y, msg) { 
    let size = (name==='Tablet' || name==='Frozen Friend') ? 2 : 1;
    S.ents.push({type:'obj', name, x, y, msg, active:false, w:size, h:size}); 
}

// --- FPS FIX START ---
let lastTime = 0;
const fpsInterval = 1000 / 60; // Target 60 FPS

function loop(timestamp) {
    // 1. Keep requesting frames
    if(S.run) requestAnimationFrame(loop);

    // 2. Handle first run
    if (!timestamp) timestamp = performance.now();

    // 3. Calculate time elapsed
    const elapsed = timestamp - lastTime;

    // 4. Limit to 60 FPS
    if (elapsed > fpsInterval) {
        lastTime = timestamp - (elapsed % fpsInterval);

        // --- THIS IS WHERE YOUR ERROR WAS ---
        try {
            update(); 
            draw();
        } catch(e) {            // You were missing this line
            console.error(e);   // And this line
        }                       // And this line
    }
}
// --- FPS FIX END ---
// --- FPS FIX END ---





function update() {
    if(S.paused) return; // STOP GAME IF PAUSED
    const now = Date.now();
    const p = S.p;









// --- PLAYER POISON LOGIC (Damage Over Time) ---
    if (p.poisonedUntil && p.poisonedUntil > now) {
        // Initialize ticker if missing
        if (!p.poisonTick) p.poisonTick = 0;
        p.poisonTick++;

        // Every 30 frames (0.5 seconds), take damage
        if (p.poisonTick > 30) {
            let dmg = 5; // Poison damage per tick
            p.hp -= dmg;
            popText(p.x, p.y, `-${dmg}`, "#8e44ad"); // Purple text
            S.audio.play('hurt');
            part(p.x, p.y, '#8e44ad', 3, 2); // Little bubbles
            p.poisonTick = 0;
            
            // Death check
            if(p.hp <= 0 && !S.gameOver) triggerGameOver("Hydra Poison");
        }
    }
// --- PLAYER BURN LOGIC (Red & Less Damage) ---
    if (p.burnedUntil && p.burnedUntil > now) {
        if (!p.burnTick) p.burnTick = 0;
        p.burnTick++;

        // Every 30 frames (0.5 seconds)
        if (p.burnTick > 30) {
            let dmg = 3; // Lower damage than poison
            p.hp -= dmg;
            popText(p.x, p.y, `-${dmg}`, "#ff5722"); // Orange text
            S.audio.play('hurt');
            part(p.x, p.y, '#ff5722', 3, 2); // Fire sparks
            p.burnTick = 0;
            
            if(p.hp <= 0 && !S.gameOver) triggerGameOver("Dragon Fire");
        }
    }











    // --- 1. WORLD SWITCHING LOGIC ---

    // Trigger Farm Mode earlier (at x=108)
    // FIX: Allow going North (y < 118) ONLY if we are deep in the East/Ocean (x > 160)
    let inFarmArea = (p.x > 108 && S.unlockedRegion9 && (p.y > 118 || p.x > 160));

    if (inFarmArea) {
        // === ENTERING FARM ===
        if(S.world !== 'farm') {
            S.world = 'farm';
            
 // --- PASTE THIS NEW LINE HERE ---
            if(S.audio.unlockAmbience) S.audio.unlockAmbience();
            // --------------------------------



            if(typeof Region9Farm !== 'undefined') Region9Farm.init(S);

            let fs = document.getElementById('farm-styles');
            if(fs) fs.disabled = false; 

           updateUI();
        }
    } else {
        // === RETURNING TO MAIN WORLD ===
        if(S.world === 'farm') {
            S.world = 'main';


// --- PASTE THIS NEW LINE HERE ---
            S.audio.stopAmbience(); 
// --------------------------------



            let fs = document.getElementById('farm-styles');
            if(fs) fs.disabled = true; 
            
            // --- REDRAW STYLIZED MAP ---
            drawStyledMinimap();










// === AUTO-PARK HORSE (Dynamic Position) ===
            if (S.p.isRiding) {
                S.p.isRiding = false;
                
                // We park the horse at the fixed "Farm Gate" coordinates (121, 135).
                // This guarantees it lands on the flat road, not the void or slope.
                S.ents.push({
                    type: 'horse', 
                    kind: 'horse', 
                    x: 121,         // Safe spot inside the gate
                    y: 135,         // Safe top-middle lane
                    w: 1.2, 
                    h: 1.2,
                    walkTimer: 0
                });

                // 2. Reset Player Speed (Remove Horse Speed)
                if (S.p.class === 'rogue') S.p.spd = 0.15;
                else if (S.p.class === 'warrior') S.p.spd = 0.12;
                else S.p.spd = 0.13; // Mage

                // 3. Notify Player
                popText(S.p.x, S.p.y, "Horse Parked", "#d7ccc8");
            }
            // ==========================================









            // ---------------------------

            updateUI();
            
            // Play NEW song if boss is dead, otherwise play OLD song
            S.audio.playBGM(S.bossDead ? 'adventure_new' : 'adventure');
        }
    }
        




    // --- 2. DELEGATE TO FARM ---
    if (S.world === 'farm') {
        
        // ... (Existing UI switching logic) ...
        let uiLayer = document.getElementById('farm-ui-layer');
        let isFarmUI = (uiLayer && uiLayer.style.display === 'block');
        let shouldBeFarmUI = (S.p.x > 118);
        if (isFarmUI !== shouldBeFarmUI) updateUI();


// --- [FIX] BGM SYNC AT GATE (118) ---
        // 1. If inside Farm (x > 118): Play Farm Music
        if (S.p.x > 118) {
            let track = (S.farm.time >= 360 && S.farm.time < 1140) ? 'farm_day' : 'farm_night';
            S.audio.playBGM(track);
        } 
        // 2. If on Driveway (x <= 118): Keep/Play Adventure Music
        else {
            S.audio.playBGM(S.bossDead ? 'adventure_new' : 'adventure');
        }
        // ------------------------------------




        if (farmSys) farmSys.update();
        else if (typeof Region9Farm !== 'undefined') Region9Farm.update();
        
        let timeIcon = document.getElementById('time-icon');
        if(timeIcon) timeIcon.innerText = (S.farm.time > 360 && S.farm.time < 1140) ? '‚òÄÔ∏è' : 'üåô';
        
        // --- [FIX] BRIDGE TEXT RESTORATION ---
        // While on the driveway (108 < x <= 118), keep the ORIGINAL RPG text.
        if (S.p.x <= 118) {
            let q = QUESTS[S.qStep];
            let qBox = document.getElementById('quest-txt');
            let qTitle = document.getElementById('quest-panel');

            if (qBox && qTitle) {
                // 1. Reset Title
                if(qTitle.children[0]) qTitle.children[0].innerText = "CURRENT MISSION";
                
                // 2. Exact Logic from Main World
                if(q) {
                    let prog = (q.type==='collect'||q.type==='activate') ? ` (${S.qProg}/${q.count})` : '';
                    qBox.innerText = q.txt + prog;
                    qBox.style.color = "#eee";
                } 
                // 3. RESTORE THE ORIGINAL "SURPRISE" HTML LAYOUT
                else if (S.bossDead && !S.epilogueSeen) {
                    qBox.innerHTML = `
                        <div style='color:#fff; font-size:22px; border-bottom:1px solid #444; margin-bottom:5px;'>East ‚ûî Farm</div>
                        
                        <div style='display:flex; align-items:center; justify-content:center; gap:5px;'>
                            <div style='font-size:65px; color:#00e676; line-height:1.0;'>‚Ü©</div>
                            <div style='text-align:left; display:flex; flex-direction:column;'>
                                <span style='color:#00e676; font-size:22px; font-weight:bold; line-height:0.9;'>RETURN<br>TO</span>
                                <span style='color:#ff1744; font-size:26px; font-weight:bold; line-height:0.9; margin-top:2px; text-shadow:2px 2px 0 #000;'>STARTING<br>VILLAGE</span>
                            </div>
                        </div>
                        <div style='margin-top:8px; padding-top:4px; border-top:1px dashed #555; color:#ffd700; font-size:24px; font-weight:bold; text-shadow:1px 1px 0 #000;'>
                            üéÅ SURPRISE **
                        </div>
                    `;
                }
            }
        }
        // ------------------------------

        return; 
    }

    // --- 3. RPG MAIN WORLD LOGIC ---

    if(now%15 === 0) {
        let healer = S.ents.find(e => {
            if(e.kind !== 'Fountain' && e.kind !== 'Healing Crystal') return false;
            let cx = e.x + e.w/2; let cy = e.y + e.h/2;
            return Math.hypot(cx - (p.x+0.5), cy - (p.y+0.5)) < 4.0; 
        });

        if(healer) {
            if(p.hp < p.maxHp) {
                p.hp = Math.min(p.maxHp, p.hp + 15);
                if(now%15===0) part(p.x, p.y, 'pink', 1, 10, 'heal_txt');
            }
        }
    }

    let dx=0, dy=0;

    


  let chatBox = document.getElementById('rpg-chat');
    let spBox = document.getElementById('special-chat');
    
    // Check if boxes are visible
    let isStandardOpen = chatBox.style.display !== 'none';
    let isSpecialOpen = spBox.style.display !== 'none';
    
    // Get the name of who is talking
    let speakerName = document.getElementById('chat-name').innerText;

    // LOGIC: Lock if (Special Box is Open) OR (Standard Box is Open AND It is NOT System)
    // We also check for the 'no-lock' class (Tutorial)
    let isChatting = isSpecialOpen || 
                     (isStandardOpen && speakerName !== "SYSTEM" && !chatBox.classList.contains('no-lock'));

    // --- [SANDWICH START] ---
    // Only allow movement if NOT chatting AND NOT hidden (Ult active)
    if (!isChatting && !S.p.hidden) {
        if(S.input.keys['arrowup']) dy=-1; if(S.input.keys['arrowdown']) dy=1;
        if(S.input.keys['arrowleft']) dx=-1; if(S.input.keys['arrowright']) dx=1;
    }
// --- [SANDWICH END] ---
    








    if(dx||dy) {
        let len = Math.hypot(dx,dy);
        let spd = p.buffs.speed > now ? p.spd*1.5 : p.spd; 

        // --- NEW: MUD SLOWDOWN ---
        // Check if player is standing inside a Mud Pool
        let inMud = S.ents.some(e => 
            e.kind === 'big_mud' && 
            p.x >= e.x && p.x < e.x + e.w && 
            p.y >= e.y && p.y < e.y + e.h
        );
        
        if(inMud) {
            spd *= 0.5; // 50% Speed (Slog through mud)
            // Optional: You could add a 'squish' sound logic here later if you wanted
        }
        // -------------------------

        dx=(dx/len)*spd; dy=(dy/len)*spd;
        let tx = p.x + dx; let ty = p.y + dy;
        
        if(!solid(tx+0.5, p.y+0.5)) p.x = tx;
        if(!solid(p.x+0.5, ty+0.5)) p.y = ty;
        
        p.x = Math.max(0, Math.min(MAP_S-1, p.x));
        p.y = Math.max(0, Math.min(MAP_S-1, p.y));

        if(dy<0) p.dir=0; if(dx>0) p.dir=1; if(dy>0) p.dir=2; if(dx<0) p.dir=3;

        // NEW ROBUST AUDIO TIMER
        if(!p.stepTimer) p.stepTimer = 0;
        p.stepTimer++;
        if(p.stepTimer > 20) {
            // Play squish sound if in mud, else normal step
            // (If you don't have 'squish', it defaults to 'step')
            S.audio.play(S.p.isRiding ? 'horse' : 'step');
            p.stepTimer = 0;
        }

    } else {
        S.p.stepTimer = 20; 
    }



    

    if(S.shake > 0) S.shake *= 0.8; if(S.shake < 0.5) S.shake = 0;
    if(isNaN(S.shake)) S.shake = 0;

    S.cam.x += (p.x*TILE - cvs.width/2 - S.cam.x) * 0.1;
    S.cam.y += (p.y*TILE - cvs.height/2 - S.cam.y) * 0.1;




    S.ents.forEach(e => {
        if(e.dead) return;




// --- [SANDWICH START] ---
        // === RANGER ULT: FLUORESCENT EXECUTION CIRCLE ===
        // === RANGER ULT: FLUORESCENT EXECUTION CIRCLE ===
       // === RANGER ULT: EXECUTION CIRCLE (Complete Reset) ===
       // === RANGER ULT: AFTERIMAGE ARROW STORM ===
        if(e.type === 'execution_controller') {
            e.life++;
            let t = e.life;

            // PHASE 1: EXPANSION
            if (t < 25) {
                let progress = t / 25;
                e.radius = 6.5 * (1 - Math.pow(1 - progress, 3)); 
            }
            
            // PHASE 2: SPAWN CLONES (Hidden initially)
            if (t === 25) {
                S.audio.play('magic'); 
                for(let i=0; i<12; i++) {
                    let angle = (i / 12) * 6.28;
                    
                    // Sprite Direction
                    let faceDir = 2; 
                    if (i >= 8 && i <= 10) faceDir = 2; // North
                    else if (i === 11 || i <= 1) faceDir = 3; // East
                    else if (i >= 2 && i <= 4) faceDir = 0; // South
                    else if (i >= 5 && i <= 7) faceDir = 1; // West

                    e.clones.push({
                        angle: angle,
                        x: e.x + Math.cos(angle) * e.radius,
                        y: e.y + Math.sin(angle) * e.radius,
                        dir: faceDir,
                        fireAnim: 0,
                        opacity: 0 // <--- START INVISIBLE
                    });
                }
            }

            // PHASE 3: CLOCKWISE "ON AND OFF" FIRE
            if (t >= 35 && t < 143) {
                
                // A. FADE OUT EFFECT (Every frame)
                // Reduce opacity of all clones so they disappear after appearing
                e.clones.forEach(cl => {
                    if(cl.opacity > 0) cl.opacity -= 0.05; // Fade speed
                    if(cl.opacity < 0) cl.opacity = 0;
                });

                // B. FIRE & FLASH ON (Every 3 frames)
                if ((t - 35) % 3 === 0) {
                    let shotNum = Math.floor((t - 35) / 3);
                    let activeCloneIdx = (9 + shotNum) % 12; // Start 12 o'clock
                    let c = e.clones[activeCloneIdx];

                    if(c) {
                        S.audio.play('bow');
                        S.shake = 2; 
                        
                        // --- THE "ON" SWITCH ---
                        c.opacity = 1.0; // Flash fully visible
                        c.fireAnim = 5; 

                        // Fire Arrow
                        let dx = e.x - c.x;
                        let dy = e.y - c.y;
                        let dist = Math.hypot(dx, dy);
                        let spd = 0.8; 

                        S.ents.push({
                            type: 'proj', x: c.x, y: c.y,
                            vx: (dx/dist)*spd, vy: (dy/dist)*spd,
                            dmg: 0, color: '#76ff03', life: 30,
                            icon: 'üèπ', scale: 1.0,
                            effect: { icon: 'üèπ' } 
                        });

                        // Area Damage
                      // Area Damage
                     // Area Damage
                        S.ents.forEach(m => {
                            if(m.type === 'mob' && !m.dead && Math.hypot(m.x - e.x, m.y - e.y) < 6.5) {
                                // FIX:
                                // 1. Uses e.dmg (18)
                                // 2. Scale 0.08 (At Lvl 10, this adds ~500 extra damage total)
                                // 3. knock: 0 (No pushing)
                                hit(m, e.dmg, { color: '#ff1744', scale: 0.08, knock: 0 });
                            }
                        });
                    }
                }
            }

            // PHASE 4: CONVERGENCE (Force Visible)
            if (t >= 143 && t <= 158) {
                let progress = (t - 143) / 15; 
                let ease = progress * progress * progress; 
                e.clones.forEach(c => {
                    c.opacity = 1.0; // <--- TURN ALL ON FOR FINALE
                    let curR = 6.5 * (1 - ease);
                    c.x = e.x + Math.cos(c.angle) * curR;
                    c.y = e.y + Math.sin(c.angle) * curR;
                });
            }

            // PHASE 5: EXPLOSION
            if (t >= 160) {
                S.p.hidden = false; 
                S.audio.play('explode');
                S.shake = 25;
                for(let k=0; k<200; k++) {
                    let a = Math.random() * 6.28;
                    let s = 5 + Math.random() * 15; 
                    let col = Math.random() > 0.3 ? '#76ff03' : '#ffffff'; 
                    S.parts.push({
                        x: e.x, y: e.y,
                        vx: Math.cos(a) * s * 0.05, vy: Math.sin(a) * s * 0.05,
                        c: col, life: 30 + Math.random()*20, s: 3, type: 'firefly'
                    });
                }
                e.dead = true;
            }
        }
        // ============================================
// --- [SANDWICH END] ---








// [FIX] INTELLIGENT CHAT FREEZE
        // 1. Always freeze for Special Chat (Noah/Doris)
        let spBox = document.getElementById('special-chat');
        if (spBox && spBox.style.display !== 'none') {
            return; 
        }




       // 2. Check Standard Chat
        let chatBox = document.getElementById('rpg-chat');
        if (chatBox && chatBox.style.display !== 'none') {
            // Get the name currently shown
            let speakerName = document.getElementById('chat-name').innerText;
            
            // FREEZE CONDITION:
            // 1. It is NOT "SYSTEM" (System messages don't pause)
            // 2. It is NOT the Tutorial (Tutorial has 'no-lock' class)
            if (speakerName !== "SYSTEM" && !chatBox.classList.contains('no-lock')) {
                return;
            }
        }










// --- YONDU ARROW LOGIC START ---
        if(e.type === 'yaka_controller') {
            let target = e.plan[e.nextIdx];
            
            // If target dead/missing, skip to next
            if(!target || target.dead) {
                e.nextIdx++;
                if(e.nextIdx >= e.plan.length) {
                    e.dead = true;
                    // Leave visual trail
                    S.vfxs.push({type:'yaka_trail', trail:e.trail, life:100, maxLife:100});
                }
                return;
            }

            // Move towards Target
            let dx = target.x - e.x;
            let dy = target.y - e.y;
            let dist = Math.hypot(dx, dy);

            if(dist < e.speed) {
                // HIT!
                e.x = target.x; 
                e.y = target.y;
                e.trail.push({x: e.x, y: e.y});
                
                S.audio.play('yaka_hit'); // <--- PLAY IMPACT SOUND
                



                // FIX: "Giant Slayer" - Deal 3x Damage if it hits a Boss!
            // Mobs take 12 dmg. Bosses take 36 dmg.
            let finalDmg = target.boss ? e.dmg * 3 : e.dmg;
            
            // Visual Crit Effect for Bosses
            if(target.boss) part(e.x, e.y, '#ffd700', 10, 4); 

            hit(target, finalDmg, { scale: e.scale, color:'#ff1744' });




                part(e.x, e.y, '#ff1744', 5, 2); 
                S.shake = 2;

                // Next Target
                e.nextIdx++;
                if(e.nextIdx >= e.plan.length) {
                    e.dead = true;
                   S.vfxs.push({type:'yaka_trail', trail:e.trail, life:100, maxLife:100});
                }
            } else {
                // FLY
                e.x += (dx/dist) * e.speed;
                e.y += (dy/dist) * e.speed;
                // Add smooth trail points
                if(Date.now() % 3 === 0) e.trail.push({x:e.x, y:e.y});
            }
        }
        // --- YONDU ARROW LOGIC END ---
























// ==========================================
        // PASTE THIS NEW BLOCK HERE
        // ==========================================
       // --- 1. VOID AURA LOGIC (The Dark Pool) ---
        if(e.type === 'void_aura') {
            e.x = S.p.x; e.y = S.p.y; // Follow Player
            // Die if no hands are active
            if(!S.ents.some(ent => ent.type === 'shadow_hand' && !ent.dead)) e.dead = true;
        }

        // --- 2. SHADOW HAND LOGIC (The Attack) ---
        if(e.type === 'shadow_hand') {
            if(!e.target || e.target.dead) { e.dead = true; return; }

            // State 0: Reaching
            if(e.state === 0) {
                let dx = e.target.x - e.x, dy = e.target.y - e.y;
                let dist = Math.hypot(dx, dy);
                if(dist > 0.5) {
                    e.x += (dx/dist) * e.speed; e.y += (dy/dist) * e.speed;
                } else {
                    e.state = 1; e.life = 40; S.shake = 2; // Grab!
                    S.audio.play('grasp_hit'); // <--- PLAY IMPACT SOUND HERE (Syncs perfectly)
                }
            }
            // State 1: Grabbing
            else if(e.state === 1) {
                e.life--;
                e.x = e.target.x; e.y = e.target.y; // Stick to enemy
                e.target.status.stun = Date.now() + 100; // Stun

                // EXPLOSION (Void Nuke)
                if(e.life <= 0) {
                    hit(e.target, e.dmg, {knock: 2.0, color:'#d500f9'});
                    S.shake = 25; // Massive Shake
                    
                    // Spawn Visual Explosion
                    S.vfxs.push({
                        type: 'void_nuke', x: e.target.x, y: e.target.y, 
                        life: 30, maxLife: 30, rot: Math.random()*6.28 
                    });
                    
                    // Spawn Debris
                    for(let k=0; k<12; k++) {
                        let ang=Math.random()*6.28, spd=0.5+Math.random()*0.5;
                        S.parts.push({
                            x:e.x, y:e.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd,
                            c:Math.random()>.5?'#fff':'#d500f9', life:20, s:3+Math.random()*4, type:'void_shard'
                        });
                    }
                    e.dead = true;
                }
            }
        }
        // ==========================================
        // END OF PASTE
        // ==========================================











        if(e.type === 'npc') {
            
            // --- FIX: NOAH & DORIS STAY STILL ---
            if (e.name === "Noah" || e.name === "Doris") {
                e.isWalking = false; // Force stop
                return; // Skip movement logic completely
            }
            // ------------------------------------

            e.moveTimer--;
            if(e.moveTimer <= 0) {
                if(Math.random() < 0.4) {
                    e.isWalking = true;
                    e.moveDir = Math.floor(Math.random() * 4); 
                    e.moveTimer = 30 + Math.random() * 50;
                } else {
                    e.isWalking = false;
                    e.moveTimer = 60 + Math.random() * 100;
                }
            }
            if(e.isWalking) {
                let mx = 0, my = 0;
                let s = 0.02; 
                if(e.moveDir === 0) my = -s;
                if(e.moveDir === 1) mx = s;
                if(e.moveDir === 2) my = s;
                if(e.moveDir === 3) mx = -s;
                
                // --- SOCIAL DISTANCING FIX ---
                // Calculate where the NPC is trying to go
                let futureX = e.x + mx;
                let futureY = e.y + my;

                // Check distance to Player. If too close (< 1.0 tile), STOP.
                if (Math.hypot(futureX - S.p.x, futureY - S.p.y) < 1.0) {
                    mx = 0; my = 0; // Don't move
                    e.moveTimer = 0; // Pick a new random direction immediately
                }
                // -----------------------------

                // --- FIX: SMART DIRECTIONAL COLLISION ---
                let offY = 0.5;
                if (e.moveDir === 0) offY = 0.3; 
                if (e.moveDir === 2) offY = 0.9;

                // --- THE FIX IS HERE ---
                // OLD BROKEN LINE: let amIStuck = solid(e.x + 0.5, e.y + offY, e);
                
                // NEW CORRECT LINE: Check the CENTER (0.5). 
                // This ensures we only ignore collision if the body is ACTUALLY inside a rock.
                let amIStuck = solid(e.x + 0.5, e.y + 0.5, e);

                // 2. Allow move if: (We are Stuck) OR (Target is Free)
                if(amIStuck || !solid(e.x + mx + 0.5, e.y + offY, e)) e.x += mx;
                if(amIStuck || !solid(e.x + 0.5, e.y + my + offY, e)) e.y += my;
            }
        }

        if(e.type==='mob') {
            // =====================================================
            // [FIX] MOB FREEZE LOGIC (Consolidated)
            // =====================================================
            let shouldFreeze = false;

            // 1. Check Special Chat (Noah/Doris) -> ALWAYS FREEZE
            let spBox = document.getElementById('special-chat');
            if (spBox && spBox.style.display !== 'none') {
                shouldFreeze = true;
            }

            // 2. Check Standard Chat
            let chatBox = document.getElementById('rpg-chat');
            if (chatBox && chatBox.style.display !== 'none') {
                let speakerName = document.getElementById('chat-name').innerText;
                // FREEZE IF: Not "SYSTEM" AND Not a "Tutorial"
                if (speakerName !== "SYSTEM" && !chatBox.classList.contains('no-lock')) {
                    shouldFreeze = true;
                }
            }

            if (shouldFreeze) return; // Stop mob logic
            // =====================================================

            if(e.status.freeze > now && Math.random()<0.1) part(e.x, e.y, '#00e5ff', 1); 
            if(e.status.stun > now) return;





// --- RED DRAGON: 6-FIRE STREAM (F1-F3 Fake, F4-F6 Real) ---
if(e.name.includes('Dragon')) {
    if(!e.animTimer) e.animTimer = 0;
    if(!e.shootCd) e.shootCd = 0;

    let dist = Math.hypot(p.x - e.x, p.y - e.y);

    // 1. TRIGGER
    if (e.animTimer === 0 && now > e.shootCd && dist < 10 && !S.p.hidden) {
        e.animTimer = 60;       // 1 second sequence (6 shots total)
        e.shootCd = now + 4000; // 4s Cooldown
        e.frozenUntil = now + 1500; // Freeze movement
        
        // Lock Aim Angle ONCE at start
        let mobCx = e.x + (e.w/2);
        let mobCy = e.y + (e.h/2);
        e.fireAngle = Math.atan2((p.y+0.5) - mobCy, (p.x+0.5) - mobCx);
        
        S.audio.play('explode'); 
    }

    // 2. SHOOTING SEQUENCE
    if (e.animTimer > 0) {
        
        // Fire every 10 frames (60, 50, 40, 30, 20, 10)
        if (e.animTimer % 10 === 0) {
            // Calculate Shot Number (1 to 6)
            // 60->1, 50->2, 40->3 (Fake) | 30->4, 20->5, 10->6 (Real)
            let shotNum = 7 - (e.animTimer / 10); 

            // IS IT FAKE? (Shots 1, 2, 3)
            let isFake = (shotNum <= 3);

            // --- FIX: INVERTED SIZING ---
            // Old: 1.3 + (shotNum * 0.7) -> Mouth was Huge
            // New: 2.0 + ((6 - shotNum) * 0.7) -> Mouth is Small (2.0), Tip is Huge (5.5)
            let scale = 2.0 + ((6 - shotNum) * 0.7);

            // MOUTH POSITION
            let faceDir = (p.x > e.x) ? 1 : -1;
            let mouthX = e.x + (e.w/2) + (faceDir * 0.6); 
            let mouthY = e.y + (e.h/2) - 1.3;

            S.ents.push({
                type: 'proj', 
                owner: 'mob', 
                kind: 'fire', 
                x: mouthX, y: mouthY, 
                
                // MOVEMENT
                vx: Math.cos(e.fireAngle) * 0.22, 
                vy: Math.sin(e.fireAngle) * 0.22, 
                
                // DAMAGE LOGIC: Fake=0, Real=20
                dmg: isFake ? 0 : 20, 
                
                color: '#d50000', 
                icon: 'üî•', 
                effect: {icon: isFake ? '' : '‚òÑÔ∏è'}, 
                
                // --- FIX: SHORT LIFE (Breath Attack) ---
                // Reduced from (30 + scale*5) to just 25 frames.
                // They will disappear after traveling a short distance.
                life: 25, 
                
                scale: scale
            });
        }

        e.animTimer--;
        return; // Stop moving
    }
}           // --- FIX: RELIABLE BURNING & POISON ---
            
            // 1. BURN LOGIC
            if(e.status.burn > now) {
                // Create a counter if it doesn't exist
                if(!e.burnTimer) e.burnTimer = 0;
                e.burnTimer++;
                



                // Tick every 20 frames (approx 3 times a second)
            if(e.burnTimer > 20) {



                // FIX: Base 8 damage + 25% Scaling (Stronger burn)
                hit(e, 8, {color:'#e74c3c', scale: 0.25});
                e.burnTimer = 0;
            }




            }

            // 2. POISON LOGIC
            if(e.status.poison > 0) {
                e.status.poison--; // Reduces duration
                
                if(!e.poisonTimer) e.poisonTimer = 0;
                e.poisonTimer++;



// Standard Speed (20 frames) for everyone. Simple and Clean.
            if(e.poisonTimer > 20) {
                // FIX: 4x Damage to Bosses (Melts them!)
                // Mob = 10 dmg. Boss = 40 dmg.
                let pDmg = e.boss ? 58 : 10; 
                hit(e, pDmg, {color:'#8e44ad', scale: 0.15});
                e.poisonTimer = 0;
            }




            }





            let speedMod = 1;
            if(e.status.slow > now) speedMod = 0.3; 
            if(e.status.freeze > now) speedMod = 0;

            let d = Math.hypot(p.x-e.x, p.y-e.y);
            











// --- MOB SPECIAL ATTACKS (SINGLE SOURCE OF TRUTH) ---
            if(!e.shootCd) e.shootCd = now + Math.random()*2000;

            if(d < 9 && now > e.shootCd && !S.p.hidden) {
                
                // CALCULATE CENTER-TO-CENTER AIM (Fixes Aim Logic)
                let mobCx = e.x + (e.w/2);
                let mobCy = e.y + (e.h/2);
                let playerCx = p.x + 0.5;
                let playerCy = p.y + 0.5;
                let aimAng = Math.atan2(playerCy - mobCy, playerCx - mobCx);

                // 1. YETI: GIANT BOULDER (Stops 1s, Aimed Correctly)
                if(e.name.includes('Yeti')) {
                    e.throwAnim = 40; 
                    e.frozenUntil = now + 1000; // Freeze
                    S.audio.play('rock'); 

                    S.ents.push({
                        type:'proj', owner:'mob', kind:'rock',
                        x:e.x+1, y:e.y+1, // Spawn at center
                        vx:Math.cos(aimAng)*0.15, vy:Math.sin(aimAng)*0.15,
                        life:80, dmg:15, 
                        color:'#90a4ae', icon:'ü™®', scale: 2.5,
                        birth: now 
                    });
                    e.shootCd = now + 6000 + (Math.random() * 3000); 
                }

                // 2. HYDRA: LIQUID SPIT (Double Shot + BIGGER + Short Range)
                else if(e.name.includes('Hydra')) {
                    e.frozenUntil = now + 1200; 
                    
                    for(let i=0; i<2; i++) {
                        setTimeout(() => {
                            if(e.dead) return;
                            
                            S.audio.play('hydra_shoot'); 
                            
                            S.ents.push({
                                type:'proj', owner:'mob', kind:'hydra_spit',
                                x:e.x+1, y:e.y+1, 
                                vx:Math.cos(aimAng)*0.18, vy:Math.sin(aimAng)*0.18,
                                
                                // --- CHANGE: REDUCED LIFE ---
                                life: 35, // Dies after ~6 tiles distance
                                // ----------------------------
                                
                                dmg:15, 
                                color:'#d500f9', 
                                scale: 4.5, 
                                icon: '' 
                            });
                        }, i * 250); 
                    }
                    e.shootCd = now + 3000; 
                }

                // 4. CHAOS TITAN: 4-WAY DOUBLE TAP
                else if(e.name === 'Chaos Titan') {
                    e.frozenUntil = now + 2000; // Freeze

                    // Add slight random spin to the base angle
                    let baseAng = aimAng + (Math.random() - 0.5) * 0.5; 

                    for(let k=0; k<2; k++) {
                        setTimeout(() => {
                            if(e.dead) return;
                            for(let i=0; i<4; i++) { 
                                let chaosAng = baseAng + (i * 1.5708); 
                                S.ents.push({
                                    type:'proj', owner:'mob', kind:'chaos_star',
                                    x:e.x+2, y:e.y+2, 
                                    vx:Math.cos(chaosAng)*0.18, vy:Math.sin(chaosAng)*0.18,
                                    life:70, dmg:35, color:'#d500f9', 
                                    scale: 3.0, icon: '' 
                                });
                            }
                            S.audio.play('magic'); 
                        }, k * 200); 
                    }
                    e.shootCd = now + 4000; 
                }
            }










           // --- 1. IDENTIFY REGION 1 MOBS ---
            let isRegion1 = (e.name === 'Slime King' || e.name === 'Slime' || e.name === 'Goblin');

            // --- 2. VISION LOGIC ---
            let vision = e.boss ? 9 : 5; 
            if (isRegion1) vision = e.boss ? 5 : 3.5;
            
            // Check if mob WANTS to chase (Visible OR Aggroed)
            let wantsToChase = (d < vision || e.aggro > now);



// === MODE A: PLAYER IS VISIBLE (NORMAL CHASE) ===
            if( wantsToChase && !S.p.hidden ) {
                if(d < vision) {
                    let chaseTime = isRegion1 ? 1500 : (e.boss ? 4000 : 2500);
                    e.aggro = now + chaseTime;
                }

                // MOVEMENT CALCULATION
                let baseSpd = (e.boss ? 0.055 : 0.04);
                if (isRegion1) baseSpd *= 0.5;

                // --- [CRITICAL FIX] CHECK FREEZE TIMER ---
                let speedMod = 1;
                
                // 1. Check Status Effects (Ice/Slow)
                if(e.status.slow > now) speedMod = 0.3; 
                if(e.status.freeze > now) speedMod = 0;

                // 2. Check Attack Animation Freeze (Yeti/Hydra/Dragon)
                if (e.frozenUntil && now < e.frozenUntil) {
                    speedMod = 0; 
                }
                // ----------------------------------------

                let s = baseSpd * speedMod;
                



                let mx = (p.x-e.x)/d * s;
                let my = (p.y-e.y)/d * s;
                
              // ONLY MOVE IF SPEED > 0
                if(speedMod > 0) {
                    // SPLIT-AXIS MOVEMENT (The Anti-Stuck Fix)
                    // We check X and Y independently.
                    // If X is blocked, we still allow Y to move (and vice versa).
                    // This creates a natural "sliding" effect against the full solid wall.

                    // 1. Try moving X
                    if(!solid(e.x + mx, e.y, e)) {
                        e.x += mx;
                    }

                    // 2. Try moving Y
                    if(!solid(e.x, e.y + my, e)) {
                        e.y += my;
                    }
                }



                // ATTACK (Melee Hit)






                // ATTACK (Melee Hit)
                if(d < (e.boss?2:1) && (!e.hitCd || e.hitCd < now) && speedMod > 0) {
                    p.hp -= e.dmg;
                    S.audio.play('hurt');
                    popText(p.x, p.y, `-${e.dmg}`, "#e74c3c", true); 
                    S.shake = 8;
                    e.hitCd = now + 1200;
                    if(p.hp <= 0 && !S.gameOver) triggerGameOver(e.name); 
                }
            }



















          // === MODE B: PLAYER IS INVISIBLE (ENGAGE CLONES) ===
            else if ( wantsToChase && S.p.hidden && speedMod > 0 ) {
                e.aggro = now + 100; 

                // 1. Find the Ult Controller
                let ult = S.ents.find(ent => ent.type === 'execution_controller' && !ent.dead);
                
                let targetX = null;
                let targetY = null;

                if (ult) {
                    // 2. Find Nearest Visible Clone
                    if(ult.clones && ult.clones.length > 0) {
                        let bestDist = Infinity;
                        ult.clones.forEach(c => {
                            // Only target clones that are clearly visible
                            if(c.opacity > 0.3) {
                                let distToClone = Math.hypot(c.x - e.x, c.y - e.y);
                                if(distToClone < bestDist) {
                                    bestDist = distToClone;
                                    targetX = c.x;
                                    targetY = c.y;
                                }
                            }
                        });
                    }

                    // 3. Fallback: If no clones visible, target Center (Player's last spot)
                    if (targetX === null) {
                        targetX = ult.x;
                        targetY = ult.y;
                    }
                }

                // 4. Movement Logic
                if(targetX !== null) {
                    let dist = Math.hypot(targetX - e.x, targetY - e.y);

                    // --- THE FIX: STOPPING DISTANCE ---
                    // Changed from 0.5 to 1.5. 
                    // This stops them from "merging" into the clone. 
                    // They will run up and stop at melee range.
                    if(dist > 1.5) {
                        let baseSpd = (e.boss ? 0.055 : 0.04);
                        if (isRegion1) baseSpd *= 0.5;

                        let s = baseSpd * speedMod;
                        
                        let mx = (targetX - e.x)/dist * s; 
                        let my = (targetY - e.y)/dist * s;
                        
                        if(!solid(e.x+mx, e.y, e)) e.x+=mx;
                        if(!solid(e.x, e.y+my, e)) e.y+=my;
                    }
                }
            }
}







        
        if(e.type==='zone') {
             e.life--; 
             for(let i=0; i<3; i++) {
                part(e.x+(Math.random()*e.w), e.y+(Math.random()*e.h), e.color, 1, 6, 'cloud');
             }
             if(e.life<=0) e.dead=true;
             S.ents.forEach(m => {
                 if(m.type==='mob' && !m.dead) {
                     if(m.x < e.x + e.w && m.x + (m.w||1) > e.x &&
                        m.y < e.y + e.h && m.y + (m.h||1) > e.y) {
                         m.status.poison = e.poison;



                         // --- MEAT (Replace only this line) ---
                         // scale: 0.05 ensures the cloud area damage isn't OP
                         if(now % 200 < 20) hit(m, 5, {color:'#8e44ad', scale: 0.07});
                     }
                 }
             });
        }
        
       if(e.type==='tornado') {
             // 1. GROW & MOVE
             if(!e.maxScale) e.maxScale = 2.0;
             if(e.scale < e.maxScale) e.scale += 0.04; 

             e.life--; 
             e.angle += 0.3; 
             e.x += e.vx; e.y += e.vy;
             
             // 2. RELIABLE COLLISION (Check Every Frame)
             S.ents.forEach(m => {
                if(m.type !== 'mob' || m.dead) return;
                
                // COOLDOWN CHECK: Has this mob been hit by a tornado recently?
                // This prevents hitting 60 times a second.
                if(m.tornadoTimer && m.tornadoTimer > Date.now()) return;

                let cx = m.x + (m.w||1)/2;
                let cy = m.y + (m.h||1)/2;
                let dist = Math.hypot(cx - e.x, cy - e.y);

                // HIT BOX: Increased size + Account for Mob Size
                if(dist < 2.5 + (m.w||1)/2) {
                     // HIT!
                     hit(m, e.dmg, { knock: 0 }); 
                     
                     // Set Cooldown (Hit roughly 5 times per second)
                     m.tornadoTimer = Date.now() + 200; 

                     // Vacuum Pull
                     let dx = e.x - m.x;
                     let dy = e.y - m.y;
                     let pullStr = 0.05;
                     if(!solid(m.x + dx*pullStr, m.y + dy*pullStr, m)) {
                         m.x += dx*pullStr;
                         m.y += dy*pullStr;
                     }
                }
             });
             
             if(e.life<=0) e.dead=true;
        }

        if(e.type==='web') {
             e.life--; 
             if(e.life<=0) e.dead=true;
             S.ents.forEach(m => {
                 let cx = m.x + (m.w||1)/2, cy = m.y + (m.h||1)/2;
                 if(m.type==='mob' && !m.dead && Math.hypot(cx-e.x, cy-e.y)<3.5) {
                     m.status.slow = now + 100; 
                 }
             });
        }





       if(e.type==='proj') {
            e.x += e.vx; e.y += e.vy; e.life--;
            if(e.icon==='üèπ') part(e.x, e.y, '#fff', 1, 2); 



// --- FIX: ENEMY FIREBALLS ONLY HURT PLAYER ---
            if(e.hostile) {
                // 1. Check Player Hit
                if(Math.hypot(e.x - S.p.x, e.y - S.p.y) < 1.5) {
                    S.p.hp -= e.dmg;
                    S.audio.play('hurt');
                    popText(S.p.x, S.p.y, `-${e.dmg}`, "#ff0000", true);
                    e.dead = true;
                    S.shake = 10;
                }
                // 2. Check Walls (Ignore Mobs!)
                if(solid(e.x, e.y)) e.dead = true;
                
                return; // SKIP the rest (Don't let it hit mobs)
            }
            // ---------------------------------------------


            if(e.icon==='üßö') part(e.x, e.y, '#ff00ff', 1, 3);
            










 // FIX: ROCKS HIT OBSTACLES (With 0.5s Safety Delay)
            // The check "(now - e.birth > 500)" ensures it doesn't break on the Yeti's own body
            // FIX: ROCKS HIT OBSTACLES (With 0.5s Safety Delay)
            // The check "(now - e.birth > 500)" ensures it doesn't break on the Yeti's own body
            // FIX: ROCKS HIT OBSTACLES (With 0.5s Safety Delay)
            // The check "(now - e.birth > 500)" ensures it doesn't break on the Yeti's own body
          // FIX: ROCKS HIT OBSTACLES (With 0.5s Safety Delay)
            if(e.kind === 'rock' && (now - e.birth > 500) && solid(e.x, e.y)) {
                e.dead = true;
                part(e.x, e.y, '#90a4ae', 8, 3);
                S.audio.play('rock'); // <--- USES ROCK SMASH SOUND
                return; 
            }




     // --- [SANDWICH START] ---
            // --- A. MOB PROJECTILES (Can ONLY hurt Player) ---
           // --- A. MOB PROJECTILES (Can ONLY hurt Player) ---
            if(e.owner === 'mob') {
                
                // --- FIX: DIE ON WALLS/DEBRIS ---
                if(solid(e.x, e.y)) {
                    e.dead = true;
                    // Optional: Small puff of smoke when hitting wall
                    if(e.kind === 'fire') part(e.x, e.y, '#333', 3, 2); 
                    return; // Stop processing
                }
                // --------------------------------

                if(!S.p.hidden && Math.hypot(e.x - S.p.x, e.y - S.p.y) < 1.0) {
                    e.dead = true;
                    // Damage Player
                    S.p.hp -= e.dmg;
                    S.audio.play('hurt');
                    popText(S.p.x, S.p.y, `-${e.dmg}`, "#e74c3c", true);
                    
                    // Hydra Special: POISON EFFECT
                    if(e.kind === 'hydra_spit') {
                        part(S.p.x, S.p.y, '#d500f9', 10, 3);
                        S.p.poisonedUntil = Date.now() + 4000; 
                        popText(S.p.x, S.p.y - 1, "POISON!", "#8e44ad");
                    }

                    // Dragon Special: BURN EFFECT (50% Chance)
                    if(e.kind === 'fire') {
                        if(Math.random() < 0.5) { 
                            part(S.p.x, S.p.y, '#ff5722', 10, 3);
                            S.p.burnedUntil = Date.now() + 3000; 
                            popText(S.p.x, S.p.y - 1, "BURN!", "#e64a19");
                        }
                    }

                    if(S.p.hp <= 0 && !S.gameOver) triggerGameOver("Monster Attack");
                }
            }


            // --- B. PLAYER PROJECTILES (Can ONLY hurt Mobs) ---
            else {
                // ... (This preserves your existing player attack logic) ...
                if( (!e.star && solid(e.x, e.y)) || (e.icon==='üß™' && e.life<=1) ) {
                    e.dead = true;
                    if(e.effect && e.effect.icon==='‚òÑÔ∏è') { 
                        e.exploded=true; S.shake=15; 
                        S.ents.forEach(m => { if(m.type==='mob' && Math.hypot(e.x-m.x, e.y-m.y)<5) hit(m, e.dmg, e.effect); });
                    }
                    if(e.icon==='üß™') {
                        part(e.x, e.y, '#ccc', 8, 2); 
                        part(e.x, e.y, '#8e44ad', 10, 4, 'cloud');
                        // This uses your original Zone logic for Player Skill
                        S.ents.push({type:'zone', x:e.x-3.5, y:e.y-3.5, w:7, h:7, life:250, color:'#8e44ad', poison:e.effect.poison});
                    }
                }

                if(!e.dead) {
                    if(e.effect && e.effect.type === 'arrowRain' && e.life<=0) {
                         e.dead = true; S.shake = 5; part(e.x, e.y, '#f1c40f', 8, 3);
                         S.ents.forEach(m => { if(m.type==='mob' && !m.dead && Math.hypot(e.x-m.x, e.y-m.y)<3) hit(m, e.dmg, e.effect); });
                    } 
                    else {
                        S.ents.forEach(m => {
                            let cx = m.x + (m.w||1)/2, cy = m.y + (m.h||1)/2;
                            let hitDist = (e.effect && e.effect.icon==='‚òÑÔ∏è'?2:1.5);
                            if(m.type==='mob' && !m.dead && Math.hypot(e.x-cx, e.y-cy)< hitDist + (m.w||1)/2) {
                                hit(m, e.dmg, e.effect||{}); e.dead=true;
                                part(e.x, e.y, e.color, 8, 3);
                            }
                        });
                    }
                }
            }
        }
// --- [SANDWICH END] ---
        
        if(e.type==='vfx_proj') {
            e.x += e.vx; e.y += e.vy; e.life--; e.scale += 0.03; 
            if(solid(e.x, e.y)) e.dead = true; 
            S.ents.forEach(m => {
                let cx = m.x + (m.w||1)/2, cy = m.y + (m.h||1)/2;
                if(m.type==='mob' && !m.dead && Math.hypot(e.x-cx, e.y-cy) < (e.scale*0.8)) {
                     hit(m, e.dmg, {knock:1.0});
                }
            });
            if(e.life<=0) e.dead=true;
        }
    });

    S.ents = S.ents.filter(e => !e.dead);

    document.getElementById('hp-bar').style.width = (Math.max(0, p.hp)/p.maxHp*100)+'%';
    let xpReq = p.lvl*100;
    document.getElementById('xp-bar').style.width = (Math.min(xpReq, p.xp)/xpReq*100)+'%';
    document.getElementById('lvl-val').innerText = p.lvl;
    
    // --- QUEST BOX LOGIC (FINAL) ---
    let q = QUESTS[S.qStep];
    let qBox = document.getElementById('quest-txt');

    if(q) {
        // 1. Normal Mission
        let prog = (q.type==='collect'||q.type==='activate') ? ` (${S.qProg}/${q.count})` : '';
        qBox.innerText = q.txt + prog;
        
        
    } 


    // 2. Boss Dead + Haven't talked to Noah/Doris yet -> SHOW INSTRUCTIONS
    else if (S.bossDead && !S.epilogueSeen) {
        qBox.innerHTML = `
            <!-- UPDATED: White color, 22px size. Kept original structure. -->
            <div style='color:#fff; font-size:22px; border-bottom:1px solid #444; margin-bottom:5px;'>East ‚ûî Farm</div>
            
            <div style='display:flex; align-items:center; justify-content:center; gap:5px;'>
                <div style='font-size:65px; color:#00e676; line-height:1.0;'>‚Ü©</div>
                <div style='text-align:left; display:flex; flex-direction:column;'>
                    <span style='color:#00e676; font-size:22px; font-weight:bold; line-height:0.9;'>RETURN<br>TO</span>
                    <span style='color:#ff1744; font-size:26px; font-weight:bold; line-height:0.9; margin-top:2px; text-shadow:2px 2px 0 #000;'>STARTING<br>VILLAGE</span>
                </div>
            </div>
            <div style='margin-top:8px; padding-top:4px; border-top:1px dashed #555; color:#ffd700; font-size:24px; font-weight:bold; text-shadow:1px 1px 0 #000;'>
                üéÅ SURPRISE **
            </div>
        `;
    }
    // 3. Epilogue Seen -> CLEAR BOX
    else {
        qBox.innerText = "World Cleansed!";
        qBox.style.color = "#eee"; // Reset color
    }




// --- UPDATE MINIMAP PLAYER DOT ---
let miniDot = document.getElementById('mini-player');
if (miniDot) {
    // Map is 180x180, CSS is 180x180. Ratio is 1:1.
    miniDot.style.left = S.p.x + 'px';
    miniDot.style.top = S.p.y + 'px';
    
    // Hide dot if we are in a menu or dead
    miniDot.style.display = (S.p.hp <= 0) ? 'none' : 'block';
}





    if(S.world==='main') {
        CLASSES[p.class].skills.forEach(s => {
            let el=document.getElementById('cd-'+s);
            if(el) el.style.height = (Math.max(0, (p.cds[s]||0)-now)/SKILLS[s].cd*100) + '%';
        });
    }

// --- GLOBAL DEATH CHECK (SAFETY NET) ---
    // This catches you if the monster hit missed the check
    if(S.p.hp <= 0 && !S.gameOver) {
        triggerGameOver("Fatal Injury");
    }


}





function xIn(e, x, y) { return x >= e.x && x < e.x+e.w && y >= e.y && y < e.y+e.h; }

function solid(x, y, excludeEnt=null) {
    let b = 0.35; 
    let corners = [
        {x:x-b, y:y-b}, {x:x+b, y:y-b},
        {x:x-b, y:y+b}, {x:x+b, y:y+b}
    ];
    
    if(S.world === 'farm') {
        let k = `${Math.floor(x)},${Math.floor(y)}`;
        if(S.farm.fences[k]) return true;
        if(['stone','stump','boulder'].includes(S.farm.debris[k])) return true;
    }

   for(let c of corners) {
        let mx = Math.floor(c.x);
        let my = Math.floor(c.y);
        if(mx >= 0 && mx < MAP_S && my >= 0 && my < MAP_S) {
            // --- FIX: Check for LETTER BLOCKS and WATER (Abyss) ---
            let ct = S.map[my*MAP_S + mx];
            // REMOVED T.VOID (because that is the Boss Room floor)
            if(ct === T.BLOCK || ct === T.WATER) return true; 
            // ------------------------------------------------------
        }
    }

    if(x<0||y<0||x>=MAP_S||y>=MAP_S) return true;
    let t = S.map[Math.floor(y)*MAP_S+Math.floor(x)];

    // --- FIX: Added VOID and BLOCK to forbidden tiles ---
    // --- FIX: Added T.BLOCK, but REMOVED T.VOID ---
    if(t===T.WATER || t===T.BEDROCK || t===T.LOCK || t===T.BLOCK) return true;
    
    for(let e of S.ents) {
        if(e.dead) continue;
        if(e === excludeEnt) continue; 
        
        if(e.type==='struct') {
            // 1. Walk through Fountain/Crystals
            if (e.kind === 'Healing Crystal' || e.kind === 'Fountain') continue;

            // 2. CHURCH FIX: Lower the wall further
            // Changed "+ 3" to "+ 4". Now only the bottom 2 rows are solid.
            if (e.kind === 'Church') {
                if(x >= e.x && x < e.x+e.w && y >= e.y + 4 && y < e.y+e.h) return true;
                continue; 
            }

            // 3. ROOF FIX: HOUSE & TUCK SHOP
            // The new art has a high roof. We start collision 1.5 tiles down 
            // so you can walk behind the roof.
            if (e.kind === 'House' || e.kind === 'TuckShop') {
                if(x >= e.x && x < e.x+e.w && y >= e.y + 1.5 && y < e.y+e.h) return true;
                continue;
            }

            // 4. STANDARD COLLISION (FarmHouse, Walls, etc.)
            // Blocks the full tile area
            if(x >= e.x && x < e.x+e.w && y >= e.y && y < e.y+e.h) return true;
        }






        // CHANGE THIS LINE (Remove && e.name==='Tablet')
       // CORRECT: Check ALL objects, then check names inside
        else if(e.type==='obj') { 
            
            // 1. ANGEL STATUE (Wide Wing Collision)
            if(e.name === 'Angel Statue') {
                // VISUAL FIX:
                // The wings extend sideways, so we widen the box.
                // X: Start -0.5 tiles to the left, End +1.5 tiles to the right.
                //    (Total width = 2 tiles)
                // Y: Standard height.
                if(x >= e.x - 0.5 && x < e.x + 1.5 && 
                   y >= e.y && y < e.y + 1) {
                    return true;
                }
            }

            // 2. TABLET COLLISION (Backup)
            else if(e.name === 'Tablet') {
                if(x >= e.x && x < e.x+e.w && y >= e.y && y < e.y+e.h) return true;
            }




        }
       else if(e.type==='env') {
            // 1. NON-SOLID DECORATION (Walk through)
            if(e.kind === 'big_mud') continue; 
            if(['flower','mushroom','pebble'].includes(e.kind)) continue;

            // 2. VOLCANO (Keep existing cone logic)
            if(e.kind === 'lava_crater') {
                let colTop = e.y + (e.h * 0.38); 
                let colBottom = e.y + e.h;
                if (y >= colTop && y < colBottom) {
                    let progress = (y - colTop) / (colBottom - colTop);
                    let shrinkFactor = 0.25 - (progress * 0.20); 
                    let currentShrink = e.w * shrinkFactor;
                    if(x >= e.x + currentShrink && x < e.x + e.w - currentShrink) return true;
                }
                continue; 
            }



           // 3. FENCE (Small Center Hitbox)
            if(e.kind==='Fence') { 
                if(Math.abs(e.x-x)<0.5 && Math.abs(e.y-y)<0.5) return true; 
            }
            




           // 4. STANDARD DEBRIS (FULL SOLID BLOCK)
            else {
                // NO PADDING. Using a full 1x1 box prevents squeezing.
                // The "Stuck" issue is solved by the movement logic, not the hitbox.
                if (x >= e.x && x < e.x + 1 && y >= e.y && y < e.y + 1) {
                    return true;
                }
            }
        }




        else if(e.type==='npc') {
             // Calculate center coordinates of the NPC
             let npcX = e.x + 0.5;
             let npcY = e.y + 0.7;

             // 1. ARE WE HITTING THEM?
             // Check if the target position (x,y) hits the NPC bubble
             if(Math.hypot(npcX - x, npcY - y) < 0.5) {
                 
                 // 2. THE "AM I STUCK?" CHECK
                 // Check if the Player is CURRENTLY inside this NPC
                 let currentDist = Math.hypot(npcX - (S.p.x + 0.5), npcY - (S.p.y + 0.5));
                 
                 // If we are currently deep inside (stuck), ignore collision to let us leave.
                 if (currentDist < 0.5) return false;

                 // Otherwise, we are outside, so act like a solid wall.
                 return true;
             }
        }



        else if(e.type==='farm_mob') {
             if(Math.hypot(e.x-x, e.y-y) < 0.5) return true;
        }
    }
    return false;
}

function hit(m, dmg, eff={}) {
    // --- TUTORIAL SAFETY ---
    // If the Tutorial Box is open, attacks deal no damage.
    // This allows practice without killing mobs or dying.
    let chatBox = document.getElementById('rpg-chat');


    // FIX: Only block damage if the box is visible AND has the tutorial class
    if (chatBox && chatBox.classList.contains('no-lock') && chatBox.style.display !== 'none') {
        return; 
    }
    // -----------------------

    // --- NEW SCALING LOGIC ---
    // Default scaling is 1.0 if not defined. 
    let scaleFactor = eff.scale !== undefined ? eff.scale : 1.0;
    
    // Calculate Level Bonus: (Level-1) * 20 * ScaleFactor
    // Example: Lvl 10 Web Arrow = 9 * 20 * 0.06 = +10 damage per bounce.
    // Example: Lvl 10 Slash     = 9 * 20 * 1.0  = +180 damage.
    let levelBonus = Math.max(0, (S.p.lvl-1) * 20 * scaleFactor);
    
    let totalDmg = dmg + levelBonus;
    // -------------------------

    m.hp -= totalDmg;
    m.aggro = Date.now() + 6000;
    popText(m.x, m.y, Math.floor(totalDmg), eff.color||"#fff");
    
    if(m.hp <= 0) {
        kill(m);
        return;
    }
    
    if(eff.heal) {
        S.p.hp = Math.min(S.p.maxHp, S.p.hp + eff.heal);
        popText(S.p.x, S.p.y-1, "+"+eff.heal, "#0f0");
    }

    if(eff.vfx === 'slash') S.vfxs.push({x:m.x, y:m.y, type:'slash', life:10, ang:Math.random()*6});
    if(eff.vfx === 'bash') S.shockwaves.push({x:m.x, y:m.y, r:0, maxR:2.5, a:1, c:'#e74c3c'});
    
    if(eff.burn) m.status.burn = Date.now()+3000;
    if(eff.poison) { m.status.poison = 50; part(m.x, m.y, '#8e44ad', 10, 3, 'cloud'); }
    if(eff.stun) m.status.stun = Date.now()+eff.stun;
    if(eff.freeze) m.status.freeze = Date.now()+eff.freeze; 
    
    // FIX: Check if knock is defined, so 0 is accepted as 0
    let k = (eff.knock !== undefined) ? eff.knock : 0.5;

    if(m.boss && m.hp > 1000) k = 0; 
    // Vacuum/Pull Logic for Warrior Tornado (Optional, but you said you preferred Push)
    // if(eff.tornado) k = -0.5; 

    if(k !== 0) {
        let ang = Math.atan2(m.y-S.p.y, m.x-S.p.x);
        let tx = m.x + Math.cos(ang)*k, ty = m.y + Math.sin(ang)*k;
        if(!solid(tx, ty, m)) { m.x=tx; m.y=ty; }
    }
}


function cast(k) {
    const p = S.p, now = Date.now();
    let sName = CLASSES[p.class].skills.find(n => SKILLS[n].k.toLowerCase()===k);
    if(!sName) return;
    
    let s = SKILLS[sName];
    if(s.locked && S.qStep <= 4) { 
        showChat("SYSTEM", "Skill Locked! Complete Ruins Task to unlock.");
        return;
    }

// FIX: Removed 'error' sound here so it doesn't beep when spamming keys
    if((p.cds[sName]||0) > now) return;
    
    p.cds[sName] = now + s.cd;

    // AUDIO: Specific Skill Mapping
    const ic = s.icon;

    // --- WARRIOR ---
    if (ic === '‚öîÔ∏è') S.audio.play('swing');       // Slash
    else if (ic === 'üõ°Ô∏è') S.audio.play('bash');   // Bash (Specific File)
    else if (ic === '‚ò¢Ô∏è') S.audio.play('wstomp'); // War Stomp
    else if (ic === '‚ù§Ô∏è') S.audio.play('heal');   // Rally
    else if (ic === 'üåã') S.audio.play('quake');  // Quake
    else if (ic === 'üåÄ') S.audio.play('tornado');// Tornado

    // --- MAGE ---
    else if (ic === 'üî•') S.audio.play('explode'); // Inferno (Magma)
    else if (ic === '‚ùÑÔ∏è') S.audio.play('ice');     // Glacial Spike
    else if (ic === '‚ö°') S.audio.play('thunder'); // Thunderstorm
    else if (ic === 'üíö') S.audio.play('heal');    // Heal
     else if (ic === '‚ú®') S.audio.play('starfall');// Starfall

    // --- RANGER ---
    else if (ic === 'üèπ') S.audio.play('yaka_cast'); // Shoot (Yaka Arrow Cast)
    else if (ic === '‚ò†Ô∏è') S.audio.play('poison');  // Poison Cloud
    else if (ic === 'üï∏Ô∏è') S.audio.play('trap');    // Trap
    else if (ic === 'üëü') S.audio.play('rush');    // Rush
   else if (ic === 'üåßÔ∏è') S.audio.play('arrow_storm');   // Arrow Storm (Generic Bow sound fits rain)
    else if (ic === 'üßö') S.audio.play('fairy');   // Fairy Bomb

    else S.audio.play('magic'); // Fallback



    
    // ===============================================
    // WARRIOR SKILL LOGIC
    // ===============================================
    
    // 1. Z SKILL: SLASH (Triple Energy Cleave)
    // Replaces the old simple line slash
    // ===============================================
    // WARRIOR SKILL LOGIC
    // ===============================================
    
    // 1. Z SKILL: SLASH (Massive Combo)
  // ===============================================
    // WARRIOR SKILL LOGIC
    // ===============================================
    
    // ===============================================
    // WARRIOR SKILL LOGIC
    // ===============================================
    
    // 1. Z SKILL: SLASH (Combo: Small -> Small -> MASSIVE)
    if(p.class === 'warrior' && s.icon === '‚öîÔ∏è') {
        [0, 100, 200].forEach((delay, i) => {
            setTimeout(() => {
                let swingSide = (i % 2 === 0) ? 1 : -1; 
                let isFinisher = (i === 2);

                S.vfxs.push({
                    type: 'sword_sweep',
                    x: p.x, y: p.y, dir: p.dir, side: swingSide,
                    life: 15, maxLife: 15,
                    
                    // --- THE MIX: Small Combo vs Big Finish ---
                    // Hit 1 & 2: White, Scale 1.5 (Fast/Sharp)
                    // Hit 3: Cyan, Scale 4.0 (Screen Filling)
                    color: isFinisher ? '#00e5ff' : '#ffffff', 
                    scale: isFinisher ? 4.0 : 1.5,
                    width: isFinisher ? 4 : 2 // Thicker line for finisher
                });
            }, delay);
        });
    }

  // 2. X SKILL: BASH (Shield + Red Aura + BULLET CLEAR)
    if(s.icon === 'üõ°Ô∏è') {
        // A. Visuals
        S.vfxs.push({
            type: 'shield_slam',
            x: p.x, y: p.y, dir: p.dir,
            life: 35, maxLife: 35
        });

        S.vfxs.push({
            type: 'shield_aura', 
            x: p.x, y: p.y, dir: p.dir,
            life: 35, maxLife: 35
        });
        
        for(let i=0; i<8; i++) {
             let ang = (p.dir * 1.57) + (Math.random()-0.5);
             let dist = 1.5 + Math.random();
             part(p.x + Math.cos(ang)*dist, p.y + Math.sin(ang)*dist, '#e74c3c', 1, 4, 'cloud');
        }

        // --- NEW: PROJECTILE DESTRUCTION (Moved to Shield) ---
        // Range 5.0 creates a safe zone in front of you
        S.ents.forEach(e => {
            if(e.type === 'proj' && e.owner === 'mob' && !e.dead) {
                // Check range (Bash range + little extra)
                if(Math.hypot(e.x - p.x, e.y - p.y) < 5.0) {
                    e.dead = true; 
                    part(e.x, e.y, '#fff', 5, 2); 
                    // Satisfying shield block sound
                    S.audio.play('break'); 
                }
            }
        });
        // -----------------------------------------------------
    }

  




// ===============================================
    // NEW SKILL: ABYSSAL GRASP (Mage B) - FIX HERE
    // ===============================================
    // ===============================================
    // NEW SKILL: ABYSSAL GRASP (Mage B)
   // ===============================================
    // NEW SKILL: ABYSSAL GRASP (Mage B)
    // ===============================================
    if(s.grasp) {
        S.audio.play('grasp_cast'); // <--- PLAY CAST SOUND HERE
        S.shake = 5;

        // --- 1. VISUAL: POOL RIPPLE ---
        // while the slow hands travel.
        S.vfxs.push({
            type: 'void_ripple', 
            x: p.x,
            y: p.y,
            life: 300,           
            maxLife: 300
        });

        // --- 2. LOGIC: VOID AURA ---
        if(!S.ents.some(e => e.type === 'void_aura')) {
            S.ents.push({ type: 'void_aura', x: p.x, y: p.y, h: 0 });
        }
        
        // --- 3. LOGIC: SPAWN SLOW HANDS ---
        let targets = S.ents.filter(e => e.type==='mob' && !e.dead && Math.hypot(e.x-p.x, e.y-p.y) < s.range);
        
        targets.forEach((m, i) => {
            setTimeout(() => {
                S.ents.push({
                    type: 'shadow_hand',
                    x: p.x,     
                    y: p.y,
                    target: m,  
                    
                    // LIFE: Increased to 400 so it doesn't disappear mid-air
                    life: 400,  
                    state: 0,   
                    dmg: s.dmg,

                    // SPEED: Reduced from 0.3 to ~0.08
                    // This makes it crawl very slowly!
                    speed: 0.08 + (Math.random()*0.02) 
                });
            }, i * 50); 
        });
        return; 
    }
    // ===============================================

    // --- OTHER SKILL LOGIC ---







  
    
    if(s.vfx === 'boom') {
         S.vfxs.push({type:'void_burst', x:p.x, y:p.y, life:50});
         for(let i=0; i<20; i++) {
             let ang = Math.random()*6.28;
             let dist = 10 + Math.random()*5;
             S.parts.push({
                 x: p.x + Math.cos(ang)*dist, y: p.y + Math.sin(ang)*dist,
                 vx: -Math.cos(ang)*0.4, vy: -Math.sin(ang)*0.4,
                 c: '#4a148c', life: 25, s: 3, type: 'norm'
             });
         }
         setTimeout(() => {
             S.ents.forEach(m => {
                 if(m.type==='mob' && !m.dead) {
                     let mx = m.x + (m.w||1)/2, my = m.y + (m.h||1)/2;
                     if(Math.hypot(mx-p.x, my-p.y) < 7 + (m.w||1)/2) hit(m, s.dmg, {knock:4.0, color:'#d500f9'});
                 }
             });
         }, 200);
    }

    if(s.tornado) {
         S.shake = 10;
         
         // 1. Determine Player Facing Angle
         let baseAng = 0;
         if(p.dir === 0) baseAng = -1.57; // Up
         if(p.dir === 1) baseAng = 0;     // Right
         if(p.dir === 2) baseAng = 1.57;  // Down
         if(p.dir === 3) baseAng = 3.14;  // Left

         // 2. Capture Start Position (So they spawn from where you CAST, not where you run)
         // 2. Capture Start Position (OFFSET FORWARD so it hits enemies instantly)
         // 0:Up, 1:Right, 2:Down, 3:Left
         let forward = 1.5; 
         let startX = p.x + (p.dir===1 ? forward : p.dir===3 ? -forward : 0);
         let startY = p.y + (p.dir===2 ? forward : p.dir===0 ? -forward : 0);
         
         let count = 5; // 5 Tornadoes for a clean sector

         for(let i=0; i<count; i++) {
             // STAGGER: Spawn them 120ms apart
             setTimeout(() => {
                 // 3. Calculate Cone Angle (Spread them out)
                 // This maps i (0 to 4) to an offset between -0.5 and +0.5 radians (~60 degrees)
                 let spread = 1.0; 
                 let offset = -spread/2 + (i / (count-1)) * spread; 
                 let finalAng = baseAng + offset;

                 // Debris Gen (Same as before)
                 let debris = [];
                 for(let d=0; d<8; d++) {
                     debris.push({
                         angle: Math.random() * 6.28,
                         dist: 20 + Math.random() * 20, 
                         speed: 0.15 + Math.random() * 0.1,
                         size: 3 + Math.random() * 4,
                         yOff: Math.random() * 60 
                     });
                 }

                 S.ents.push({
                    type: 'tornado', 
                    x: startX, // Spawn from original cast point
                    y: startY,
                    // Move OUTWARD in the cone direction
                    vx: Math.cos(finalAng) * 0.12, 
                    vy: Math.sin(finalAng) * 0.12, 
                    life: 140, 
                    maxLife: 140,
                    angle: Math.random()*6.28,
                    scale: 0.2, // Start Small
                    maxScale: 2.5, // Grow HUGE
                    dmg: s.dmg,
                    debris: debris
                 });
                 
                 // Little screen shake on each spawn for weight
                 S.shake = 5; 

             }, i * 120); // The Stagger Delay
         }
         return;
    }


if(s.stomp) {
        // 1. Shockwave Ring (Thick & Fast)
        S.shockwaves.push({
            x: p.x, y: p.y, 
            r: 0.5,      
            maxR: 9.0,   // Matches range
            a: 1.0,      
            c: '#fff',   // White hot
            w: 8         // Thick line
        });

        // 2. Flying Debris (Rock Chunks)
        for(let i=0; i<15; i++) {
             let ang = Math.random() * 6.28;
             part(p.x, p.y, '#5d4037', 1, 5 + Math.random()*5, 'rock'); 
             let lastPart = S.parts[S.parts.length-1];
             let spd = 2 + Math.random() * 3;
             lastPart.vx = Math.cos(ang) * spd;
             lastPart.vy = Math.sin(ang) * spd;
        }

        // 3. The Explosion Cloud (Nuclear Style)
        let puffs = [];
        for(let i=0; i<40; i++) { 
            let angle = Math.random() * 6.28;
            let dist = Math.random() * 20; // Start near center
            let speed = 5 + Math.random() * 8; // Blast outwards FAST
            
            puffs.push({
                x: Math.cos(angle) * dist, 
                y: Math.sin(angle) * dist * 0.7, 
                vx: Math.cos(angle) * speed, 
                vy: Math.sin(angle) * speed * 0.7, 
                r: 20 + Math.random() * 30, // Big clouds
                rot: Math.random() * 6.28,
                id: i 
            });
        }

        S.vfxs.push({
            type: 'explosion_cloud', 
            x: p.x, 
            y: p.y, 
            life: 40,        
            maxLife: 40, 
            puffs: puffs
        });

        // 4. Hit Logic (Wide Area + Flash)
        S.ents.forEach(m => {
            let mx = m.x + (m.w||1)/2, my = m.y + (m.h||1)/2;
            if(m.type==='mob' && !m.dead && Math.hypot(mx-p.x, my-p.y) < s.range) {
                part(m.x, m.y, '#fff', 10, 5); // Flash on hit
                hit(m, s.dmg, { knock: s.knock });
            }
        });
        return;
    }

   







// --- 1. REDESIGNED QUAKE (Pre-calculated Paths) ---
 // --- 1. EARTH SHATTER (Web Design, Fast, Custom Browns) ---
    if(s.quake) {
        let segments = [];
        let debris = [];
        let mainCount = 6; 

        for(let i=0; i<mainCount; i++) {
            let angle = (i / mainCount) * 6.28;
            let dist = 0;
            let maxDist = s.range * 45; 
            let px = 0, py = 0; 
            
            let path = [{x:0, y:0}];

            while(dist < maxDist) {
                dist += 30; 
                let jaggedAng = angle + (Math.random() - 0.5) * 1.0; 
                px += Math.cos(jaggedAng) * 20;
                py += Math.sin(jaggedAng) * 20;
                path.push({x:px, y:py});

                // Cross-Links (The Web)
                if(i > 0 && Math.random() < 0.5) {
                    let branchAng = jaggedAng + 1.57; 
                    let bx = px + Math.cos(branchAng) * 25;
                    let by = py + Math.sin(branchAng) * 25;
                    segments.push({x1:px, y1:py, x2:bx, y2:by});
                }

                // Debris: Deep Bedrock Brown (Not Road Brown)
                if(Math.random() < 0.4) {
                    debris.push({
                        x: px + (Math.random()-0.5)*20,
                        y: py + (Math.random()-0.5)*20,
                        size: 4 + Math.random() * 8,
                        vx: Math.cos(jaggedAng) * (1 + Math.random()*2),
                        vy: Math.sin(jaggedAng) * (1 + Math.random()*2),
                        rot: Math.random() * 6.28,
                        color: '#3e2723' // Deep dark brown
                    });
                }
            }
            
            for(let k=0; k<path.length-1; k++) {
                segments.push({x1:path[k].x, y1:path[k].y, x2:path[k+1].x, y2:path[k+1].y});
            }
        }

        S.vfxs.push({
            type: 'tectonic_rupture', 
            x: p.x, y: p.y, 
            life: 70, maxLife: 70, // Fast Snap
            web: segments,       
            debris: debris  
        });

        S.shake = 15; 
        
        S.ents.forEach(m => {
            if(m.type==='mob' && !m.dead && Math.hypot((m.x+m.w/2)-p.x, (m.y+m.h/2)-p.y) < s.range) {
                hit(m, s.dmg, { knock: 1.5, stun: 3000 });
            }
        });
        return; 
    }



    // --- 2. FREEZE: GIANT RUGGED ICE BOULDERS ---
  // --- 2. FREEZE: MAGE 'X' (INSTANT SPAWN) ---
    // Internal Name: 'glacial_cone'
    if(s.spike) {
        let faceAng = 0;
        if(p.dir===0) faceAng = -1.57; else if(p.dir===1) faceAng = 0;     
        else if(p.dir===2) faceAng = 1.57; else faceAng = 3.14;             

        let boulders = [];
        let count = 15; 
        
        let maxRange = s.range * 60; 

        for(let i=0; i<count; i++) {
            let progress = i / count; 
            let dist = 20 + (progress * maxRange) + (Math.random() * 30);
            
            let spread = (Math.random() - 0.5) * 0.8; 
            
            let bx = Math.cos(faceAng + spread) * dist;
            let by = Math.sin(faceAng + spread) * dist;

            let radius = 40 + Math.random() * 45; 
            
            let pts = [];
            let verts = 6 + Math.floor(Math.random() * 3); 
            for(let j=0; j<verts; j++) {
                let ang = (j / verts) * 6.28;
                let r = radius * (0.6 + Math.random() * 0.6); 
                pts.push({ x: Math.cos(ang)*r, y: Math.sin(ang)*r });
            }

            let fractures = [];
            for(let k=0; k<5; k++) { 
                let p1 = pts[Math.floor(Math.random()*pts.length)];
                let p2 = pts[Math.floor(Math.random()*pts.length)];
                fractures.push({x1:p1.x, y1:p1.y, x2:p2.x*0.4, y2:p2.y*0.4});
            }

            boulders.push({
                x: bx, y: by,
                pts: pts,
                fractures: fractures,
                // INSTANT RIPPLE: Lower number = Faster wave
                delay: (dist / maxRange) * 0.05, 
                sortY: by
            });
        }
        boulders.sort((a,b) => a.sortY - b.sortY);

        S.vfxs.push({
            type: 'glacial_cone',
            x: p.x, y: p.y,
            life: 160, maxLife: 160, 
            boulders: boulders
        });

        S.shake = 5; 

        S.ents.forEach(m => {
            if(m.type !== 'mob' || m.dead) return;
            let dx = (m.x + m.w/2) - p.x;
            let dy = (m.y + m.h/2) - p.y;
            let dist = Math.hypot(dx, dy);
            let mobAng = Math.atan2(dy, dx);
            let diff = mobAng - faceAng;
            while(diff < -3.14159) diff += 6.28318;
            while(diff > 3.14159) diff -= 6.28318;

            if(dist < s.range * 1.8 && Math.abs(diff) < 1.0) { 
                hit(m, s.dmg, { freeze: 2500, knock: 1.5 });
            }
        });
        return;
    }








// --- 1. LOGIC FOR INFERNO (Magma Boulders) ---
   // --- 1. LOGIC FOR INFERNO (Phoenix Flame) ---
    // --- 1. LOGIC FOR INFERNO (Phoenix Flame) ---
    // --- 1. LOGIC FOR INFERNO (Chaotic Phoenix Fire) ---
    if(s.inferno) {
        // Random Count: 5 to 7
        let cnt = Math.floor(Math.random() * 3) + 5; 
        
        for(let i=0; i<cnt; i++) {
            // Get base facing angle
            let baseAng = 0;
            if(p.dir===0) baseAng = -1.57; // Up
            if(p.dir===1) baseAng = 0;     // Right
            if(p.dir===2) baseAng = 1.57;  // Down
            if(p.dir===3) baseAng = 3.14;  // Left
            
            // CHAOS 1: Random Angle (Wide Cone +/- 50 degrees)
            // No fixed pattern. Pure random spread.
            let randomOffset = (Math.random() - 0.5) * 1.8; 
            let finalAng = baseAng + randomOffset;
            
            // CHAOS 2: Random Speed
            // Varies between 0.15x and 0.35x of base speed.
            // This creates depth as they separate over time.
            let speedVar = (0.15 + Math.random() * 0.20) * s.spd;

            // CHAOS 3: Random Spawn Position
            // Don't spawn from a single pixel. Burst from the whole body.
            let offX = (Math.random() - 0.5) * 1.0;
            let offY = (Math.random() - 0.5) * 1.0;

            S.ents.push({
                type:'proj', 
                x: p.x + offX, 
                y: p.y - 0.5 + offY, 
                vx: Math.cos(finalAng) * speedVar, 
                vy: Math.sin(finalAng) * speedVar, 
                dmg: s.dmg, 
                color: s.color, 
                effect: s, 
                life: 240, // Long life
                
                vfxType: 'phoenix_fire', 
                seed: Math.random() * 10,
                birth: Date.now()
            });
        }
        return;
    }



    // --- 2. LOGIC FOR THUNDERSTORM (Lightning Strikes) ---
  // --- 2. LOGIC FOR THUNDERSTORM (UPGRADED) ---
    if(s.storm) { 
        S.shake = 25; // MASSIVE SHAKE
        
        // 1. Find Targets
        let targets = S.ents.filter(e => e.type==='mob' && !e.dead && Math.hypot(e.x-p.x, e.y-p.y) < s.range);
        
        // 2. Determine number of strikes (Max 8)
        let strikeCount = targets.length > 0 ? targets.length : 5;
        if(strikeCount > 8) strikeCount = 8; 

        for(let i=0; i<strikeCount; i++) {
            let target = targets[i];
            let tx = target ? target.x : p.x + (Math.random()-0.5)*12;
            let ty = target ? target.y : p.y + (Math.random()-0.5)*12;
            
            // Stagger the strikes
            setTimeout(() => {
                // VISUAL: Generate a Heavy Bolt
                lightning(tx, ty - 20, tx, ty, true); // True = Heavy Bolt
                
                // VISUAL: Giant Ground Flash
                part(tx, ty, '#e0f7fa', 15, 8, 'cloud');
                
                // VISUAL: Impact Shockwave (The "Wow" Factor ring)
                S.shockwaves.push({
                    x:tx, y:ty, 
                    r:0.5, maxR:5.0, // Big ring
                    a:1.0, c:'#00ffff', w:10 // Cyan, Thick line
                });

                // DAMAGE
                if(target) {
                    hit(target, s.dmg, { stun: s.stun, knock: 1.0 });
                    part(target.x, target.y, '#ffd700', 10, 4); // Sparks
                }
            }, i * 60); // Faster stagger for chaos
        }
        return;
    }




    if(s.type === 'fairy') {
        S.shake = 10;
        for(let k=0; k<5; k++) {
            setTimeout(() => {
                S.ents.forEach(m => {
                    let mx = m.x + (m.w||1)/2, my = m.y + (m.h||1)/2;
                    let dist = Math.hypot(mx-p.x, my-p.y);
                    if(m.type==='mob' && !m.dead && dist < s.range + (m.w||1)) {
                        hit(m, s.dmg, {color:'#ff00ff'});
                    }
                });
            }, k * 100); 
        }

        for(let i=0; i<50; i++) {
            let colors = ['#ff00ff', '#00ffff', '#ffff00', '#00ff00', '#ff69b4', '#8a2be2'];
            let c = colors[Math.floor(Math.random()*colors.length)];
            let ang = Math.random() * 6.28;
            let spd = 0.2 + Math.random() * 0.4;
            part(p.x, p.y, c, 1, 5 + Math.random()*15, 'cloud');
            let justAdded = S.parts[S.parts.length-1];
            justAdded.vx = Math.cos(ang) * spd; justAdded.vy = Math.sin(ang) * spd;
            
            if(i % 3 === 0) {
                setTimeout(() => {
                    let icons = ['ü¶ã', 'üåà', '‚ú®', 'ü¶Ñ'];
                    let ic = icons[Math.floor(Math.random()*icons.length)];
                    part(p.x, p.y, c, 1, 20 + Math.random()*20, 'icon_' + ic);
                    let justIcon = S.parts[S.parts.length-1];
                    justIcon.vx = Math.cos(ang) * spd * 1.2; justIcon.vy = Math.sin(ang) * spd * 1.2;
                }, i * 20);
            }
        }
        return;
    }






// --- [SANDWICH START] ---
    if(s.type === 'execution') {
        // 1. Lock Player & Hide
        S.p.hidden = true; 
        S.p.invuln = Date.now() + 2500; // Invincible during animation
        
        // 2. Spawn Controller
        S.ents.push({
            type: 'execution_controller',
            x: p.x, y: p.y,
            dmg: s.dmg,
            life: 0,
            maxLife: 160, // Total duration ~2.6 seconds
            radius: 0,
            clones: []
        });
        
        S.audio.play('rush'); // Initial woosh sound
        return;
    }


















    if(s.type === 'shower' || s.type === 'arrowRain') {
        let color = s.type==='arrowRain' ? '#fff' : '#ff5722';
        for(let i=0; i<s.count; i++) {
            setTimeout(() => {
                let angle = Math.random() * 6.28;
                let dist = 2 + Math.random() * 8; 
                let tx = p.x + Math.cos(angle)*dist;
                let ty = p.y + Math.sin(angle)*dist;
                let offset = s.type==='arrowRain' ? 12 : 15;
                let spd = s.type==='arrowRain' ? 1.5 : 0.8;
                let size = 0.5 + Math.random() * 1.0; 
                S.ents.push({
                    type:'proj', x:tx, y:ty-offset, vx:0, vy:spd, 
                    dmg:s.dmg, color:color, effect:s, life:15, icon: s.type==='arrowRain' ? 'üèπ' : '',
                    scale: size
                });
            }, i*(s.type==='arrowRain'?10:50)); 
        }
        return;
    }

    if(s.type === 'stars') {
         S.shake = 5;
         for(let i=0; i<s.count; i++) {
            setTimeout(()=>{
                let angle = Math.random() * 6.28;
                let dist = Math.random() * 12; 
                let target = S.ents.find(e => e.type==='mob' && !e.dead && Math.hypot(e.x-p.x, e.y-p.y) < 10 && Math.random() < 0.3);
                let sx = p.x + Math.cos(angle)*dist;
                let sy = p.y + Math.sin(angle)*dist;
                if(target) { sx = target.x; sy = target.y; }
                S.ents.push({type:'proj', x:sx, y:sy-10, vx:0, vy:1.0, dmg:s.dmg, color:'#ffd700', effect:{...s, icon:'‚ú®'}, life:15, star:true});
            }, i*20); 
         }
         return;
    }

    if(s.icon==='‚ö°') { 
        S.shake = 10;
        S.ents.forEach(e => { if(e.type==='mob' && Math.hypot(e.x-p.x, e.y-p.y)<s.range) hit(e, s.dmg, s); });
        for(let i=0; i<8; i++) {
             let angle = (i/8)*6.28;
             let tx = p.x + Math.cos(angle)*s.range;
             let ty = p.y + Math.sin(angle)*s.range;
             lightning(p.x, p.y, tx, ty);
        }
        return;
    }
    // RANGER X: POISON FLASK (Lobbed Projectile)
    // RANGER X: NINJA SMOKE (Visual Update)
    if(s.icon==='‚ò†Ô∏è') { 
        // 1. Visual: Instant Smoke Puffs around player
        S.shake = 5;
        for(let i=0; i<20; i++) {
            part(p.x, p.y, i%2==0?'#8e44ad':'#555', 1, 6+Math.random()*4, 'cloud');
        }

        // 2. Logic: Create the poison zone instantly at feet
        S.ents.push({
            type:'zone', 
            x:p.x-4, y:p.y-4, w:8, h:8, // Large 8x8 area
            life:200, 
            color:'#8e44ad', 
            poison:s.poison
        });
        return;
    }




    if(s.icon==='üï∏Ô∏è') {
        S.ents.push({type:'web', x:p.x, y:p.y, life:120}); 
        return;
    }
    if(s.icon==='üåã') { 
        S.shake = 25; part(p.x, p.y, '#5d4037', 50, 6); 
        S.ents.forEach(e => { if(e.type==='mob' && Math.hypot(e.x-p.x, e.y-p.y)<s.range) hit(e, s.dmg, s); });
        return; 
    }
    if(s.icon==='‚òÑÔ∏è') { 
        let tx = p.x + (p.dir===1?5:p.dir===3?-5:0), ty = p.y + (p.dir===2?5:p.dir===0?-5:0);
        S.ents.push({type:'proj', x:tx, y:ty-10, vx:0, vy:0.5, dmg:s.dmg, color:'#ff5722', effect:s, life:25}); 
        return; 
    }
    // RANGER Z: YAKA ARROW (Chain Attack)
    // RANGER Z: CHAOS WEB ARROW
   if(s.icon==='üèπ') { 
        // 1. Calculate the Flight Plan
        let flightPlan = [];
        let curr = {x:p.x, y:p.y};
        let hitIds = []; 

        for(let i=0; i<15; i++) { // 15 Bounces
            // Find closest enemy we haven't hit yet
            let targets = S.ents.filter(e => 
                e.type==='mob' && !e.dead && !hitIds.includes(e) && 
                Math.hypot(e.x-curr.x, e.y-curr.y) < 10.0
            );
            
            // Sort by distance
            // CHAOS MODE: Randomize targets to create a criss-cross web
            targets.sort(() => Math.random() - 0.5);
            
            if(targets.length > 0) {
                let t = targets[0];
                flightPlan.push(t); 
                hitIds.push(t);
                curr = t; 
            } else {
                break; 
            }
        }

        // 2. Spawn the Arrow Controller
        if(flightPlan.length > 0) {
            S.ents.push({
                type: 'yaka_controller',
                x: p.x, 
                y: p.y,
                plan: flightPlan,     
                nextIdx: 0,           
                speed: 0.8, // Flight Speed
                trail: [{x:p.x, y:p.y}], 
                dmg: s.dmg,
                scale: s.scale
            });
        } else {
            // Fallback: Shoot straight if no enemies
            let vx=0, vy=0;
            if(p.dir===0) vy=-0.8; else if(p.dir===1) vx=0.8; else if(p.dir===2) vy=0.8; else vx=-0.8;
            S.ents.push({type:'proj', x:p.x, y:p.y, vx, vy, dmg:s.dmg, color:'#fff', effect:s, life:30, icon:'üèπ'});
        }
        return;
    }







    if(s.heal) { 
        // --- BALANCED SCALING HEAL ---
        let amount = s.heal; // Default (Mage gets standard 150)

        if (p.class === 'warrior') {
            // Formula: Base 200 + 30 per Level
            // Lv 1: 230 (Nerf - Was 300)
            // Lv 9: 470 (Buff - Helps vs Boss)
            amount = 200 + (p.lvl * 30);
        }
        
        p.hp = Math.min(p.maxHp, p.hp + amount); 
        part(p.x, p.y, '#0f0', 30, 4); 
        popText(p.x, p.y-1, "+" + amount, "#0f0"); 
        return; 
    }






    if(s.speed) { p.buffs.speed=now+4000; part(p.x, p.y, '#ff0', 30, 4); return; }

    if(s.proj) {
        let cnt = s.count || 1; 
        for(let i=0; i<cnt; i++) {
            let angOffset = (i - (cnt-1)/2) * (s.spread || 0);
            let vx=0, vy=0;
            if(p.dir===0) { vx=angOffset; vy=-s.spd; }
            if(p.dir===1) { vx=s.spd; vy=angOffset; }
            if(p.dir===2) { vx=angOffset; vy=s.spd; }
            if(p.dir===3) { vx=-s.spd; vy=angOffset; }
            S.ents.push({type:'proj', x:p.x, y:p.y, vx, vy, dmg:s.dmg, color:s.color, effect:s, life:60});
        }
    } else {
        let ang = p.dir===0?-1.57:p.dir===1?0:p.dir===2?1.57:3.14;
        S.vfxs.push({type:'slash', x:p.x+Math.cos(ang), y:p.y+Math.sin(ang), life:10, ang});
        S.ents.forEach(e => {
            if(e.type==='mob' && !e.dead && Math.hypot(e.x-p.x, e.y-p.y) < s.range) {
                let midX = (p.x+e.x)/2, midY = (p.y+e.y)/2;
                if(!solid(midX, midY)) hit(e, s.dmg, s);
            }
        });
    }
}

function kill(m) {
    if(m.dead) return; 
    m.dead = true;
    S.p.xp += m.boss?800:50;
    S.p.killLog.push(m.name);
    
    // --- INSIDE kill(m) ---

    // Replace the Chaos Titan block with this clean version:
    if(m.name === "Chaos Titan") {
       // 1. Basic Unlocks
       // 1. Basic Unlocks
       unlockRegion9();      
       S.bossDead = true;    
       
       S.p.hidden = false; // <--- ADD THIS LINE (Fixes Ranger Ult bug) 
       drawStyledMinimap();  
       S.audio.playBGM('adventure_new'); 

       // 2. SPAWN NOAH (The Artist)
       addNPC("Noah", 32, 24, "My dear friend, I am blessed to have met you. Thank you for being part of my story. I‚Äôm not sure when our paths will cross again, but I am so thankful to have had you in my life.", 'M');
       S.ents[S.ents.length-1].moveTimer = Infinity; 

       // 3. SPAWN DORIS (The Teacher)
       addNPC("Doris", 36, 24, "When you travel, you need to have your passport ready. Just the same, one day when you leave this world, you need to have your passport to heaven ready.", 'F');
       S.ents[S.ents.length-1].moveTimer = Infinity; 

       // 4. SYSTEM MESSAGE
       showChat("SYSTEM", "The path is open. Follow the signs on the floor.");
   }




  if(S.p.xp >= S.p.lvl*100) { 
        S.p.xp=0; S.p.lvl++; S.p.maxHp+=50; S.p.hp=S.p.maxHp; 
        S.audio.play('lvlup'); 


// --- NEW LEVEL UP SIGNS ---
        
        // 1. LVL Label
        popUiText('lvl-val', "LEVEL UP!");

       // 2. HP Bar (Uses the ID we added in Step 1)
        popUiText('hp-container', "MAX HP");

        // 3. Skill Bar: Flash Keys Only (No bar flash)
        document.querySelectorAll('.key-hint').forEach(el => {
            el.classList.remove('key-flash');
            void el.offsetWidth; 
            el.classList.add('key-flash');
        });

        // 3b. Manually add "POWER UP" text (Bypassing the white flash effect)
        let d = document.createElement('div');
        d.className = 'ui-pop-txt'; 
        d.innerText = "POWER UP";
        d.style.left = '50%'; 
        d.style.top = '600px'; // Positioned perfectly above skill bar
        document.getElementById('game-wrapper').appendChild(d);
        setTimeout(() => d.remove(), 2000);
        
        // 4. Player Flash
        part(S.p.x, S.p.y, '#ffd700', 30, 5);



           }





    let q = QUESTS[S.qStep];
    if(q && q.type==='kill' && q.target===m.name) nextQuest();
}







function interact() {
    // 1. Find targets (NPCs, Items, Objects)
    let targets = S.ents.filter(e => (e.type==='npc'||e.type==='item'||e.type==='obj') && Math.hypot(e.x-S.p.x, e.y-S.p.y)<2.5);
    
    // 2. Sort by distance (closest first)
    targets.sort((a,b) => Math.hypot(a.x-S.p.x, a.y-S.p.y) - Math.hypot(b.x-S.p.x, b.y-S.p.y));
    
    // 3. Pick the closest one
    let t = targets[0];

    if(t) {

        // ============================================
        // A. NPC INTERACTION
        // ============================================
        if(t.type==='npc') {
            S.audio.play('npc'); 
            showChat(t.name, t.txt);
            
            let q = QUESTS[S.qStep];
            
            // 1. Normal Quest Progress
            if(q && q.type==='talk' && q.target===t.name) {
                nextQuest();
            }

            // 2. Epilogue Logic
            if(S.bossDead && (t.name === "Noah" || t.name === "Doris")) {
                 S.epilogueSeen = true; 
                 
                 // JUST THE HEART (No text)
                 popText(S.p.x, S.p.y, "‚ù§Ô∏è", "#ff69b4");
                 
                 // Sound removed (It will use the standard 'npc' sound played above)
            }
        }

        // ============================================
        // B. ITEM INTERACTION (Herbs, etc.) <--- THIS WAS MISSING
        // ============================================
        if(t.type==='item') {
            // Play Sound
            S.audio.play('item_found'); 
            
            // Remove Item & Show Text
            t.dead = true; 
            popText(S.p.x, S.p.y, "+ "+t.name, "#0ff");
            
            // Check Quest Progress
            let q = QUESTS[S.qStep];
            if(q && q.type==='collect' && q.target===t.name) {
                S.qProg++;
                if(S.qProg >= q.count) nextQuest();
            }
        }

        // ============================================
        // C. OBJECT INTERACTION (Tablets, Portals)
        // ============================================
        if(t.type==='obj') {
             // 1. Portal Logic
             if(t.name === 'PortalHome') {
                 S.p.x = 25; S.p.y = 35; // Teleport to Village
                 S.audio.play('tele');
                 showChat("SYSTEM", "Warping to Village...");
                 return;
             }

             // 2. Tablet / Statue Logic
             if(!t.active) {
                S.audio.play('item_found');
                t.active = true;
                if(t.msg) showChat("SYSTEM", t.msg);
                
                popText(S.p.x, S.p.y, "DONE", "#f0f");
                part(t.x, t.y, '#fff', 20);
                
                let q = QUESTS[S.qStep];
                if(q && q.type==='activate' && q.target===t.name) {
                    S.qProg++;
                    if(S.qProg >= q.count) nextQuest();
                }
            }
        }
    }
}












function nextQuest() {
    popText(S.p.x, S.p.y, "OBJECTIVE COMPLETE", "#0f0");
    S.qStep++; S.qProg=0;
    
    if(S.qStep > 4) updateUI(); 

    let prevQ = QUESTS[S.qStep-1];
    if(prevQ && prevQ.lock !== undefined) unlockGate(prevQ.lock);
    
   // WIN CONDITION
    // WIN CONDITION
    if(S.qStep >= QUESTS.length) {
      S.audio.play('victory'); 
        
        // --- 1. FREEZE ENGINE INSTANTLY ---
        S.paused = true; 
        // ----------------------------------

        // 2. Remove floating text so it doesn't overlap
        document.querySelectorAll('.float-txt, .ui-pop-txt').forEach(el => el.remove());

        // 3. Move Win Screen to front and show it
        let winScreen = document.getElementById('win-screen');
        document.getElementById('game-wrapper').appendChild(winScreen);
        winScreen.style.display='flex';
    }else {
        // --- FIXED: COMBO SYSTEM ---
        // If the NEXT quest target is ALREADY dead (Pre-killed),
        // wait 1.5 seconds, then auto-complete it.
        let nq = QUESTS[S.qStep];
        
        if(nq && nq.type==='kill' && S.p.killLog.includes(nq.target)) {
            setTimeout(() => nextQuest(), 1500); 
        }
    }
}



function unlockGate(id) {
    let removed = false;
    for(let i=0; i<S.map.length; i++) {
        let lock = S.locks.find(l => l.x === i%MAP_S && l.y === Math.floor(i/MAP_S) && l.id === id);
        if(lock) {
            S.map[i] = T.BRIDGE; 
            part(lock.x, lock.y, '#0ff', 10, 3);
            removed = true;
        }
    }
    if(removed) { 
        showChat("SYSTEM", "A path opens..."); 
        S.shake = 5; 
        S.audio.play('gate'); // <--- Logic added here
    }
}

let eggClicks = 0;
function eggTitle() {
    eggClicks++;
    if(eggClicks===5) showChat("Noah", "Stop clicking the title and play the game!");
}




//////////////////
 function draw() {
    // 1. Delegate to Farm
    if (S.world === 'farm') {
        Region9Farm.draw();
        return; 
    }

    // 2. RESET GRAPHICS (Fixes "Weird Art" on return)
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
    ctx.globalAlpha = 1.0;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.lineWidth = 1;
    ctx.font = "10px sans-serif"; // Reset font size

    // =======================================

    if(isNaN(S.cam.x)) S.cam.x = 0; 
    ctx.fillStyle='#000'; ctx.fillRect(0,0,cvs.width,cvs.height);



    
    let sx = (Math.random()-0.5)*(S.shake||0), sy = (Math.random()-0.5)*(S.shake||0);
    let cx = Math.floor(S.cam.x/TILE), cy = Math.floor(S.cam.y/TILE);
    let ex = cx + (cvs.width/TILE)+2, ey = cy + (cvs.height/TILE)+2;

    for(let y=cy; y<ey; y++) for(let x=cx; x<ex; x++) {
        if(x<0||y<0||x>=MAP_S||y>=MAP_S) continue;
        let t = S.map[y*MAP_S+x];
        let px = Math.floor(x*TILE-S.cam.x+sx), py = Math.floor(y*TILE-S.cam.y+sy);
        




// --- 1. SETUP RANDOM MATH (For textures) ---
        let seed = Math.abs(Math.sin(x * 12.9898 + y * 78.233));
        let r1 = (seed * 100) % 1;
        let r2 = (seed * 200) % 1;
        let r3 = (seed * 300) % 1;
        let r4 = (seed * 400) % 1;

        // --- 2. BASE COLORS ---
        // Use rich brown for roads, default colors for others
        if(t === T.BRIDGE || t === T.ROAD) ctx.fillStyle = '#5d4037'; 
        else ctx.fillStyle = Object.values(C)[t];
        
        if(t === T.LOCK) ctx.fillStyle = `rgba(200,0,0,${0.7+Math.sin(Date.now()/200)*0.3})`;
        
        ctx.fillRect(px, py, TILE, TILE);

        // --- 3. FARM DELEGATION ---
        if(S.world === 'farm' && farmSys) farmSys.draw(ctx, S.cam.x, S.cam.y);

        // --- 4. APPLY DETAILED TEXTURES ---
        
        // A. ROAD/BRIDGE (Gravel)
        if(t === T.BRIDGE || t === T.ROAD) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.18)'; 
            ctx.fillRect(px + (r1 * (TILE-3)), py + (r2 * (TILE-3)), 3, 3);
            ctx.fillRect(px + (r3 * (TILE-3)), py + (r4 * (TILE-3)), 3, 3);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; 
            ctx.fillRect(px + (r2 * (TILE-2)), py + (r3 * (TILE-2)), 2, 2);
            ctx.fillRect(px + (r4 * (TILE-2)), py + (r1 * (TILE-2)), 2, 2);
        }
        // B. GRASS (Lush)
        else if(t === T.GRASS) {
            ctx.fillStyle = 'rgba(0, 60, 0, 0.15)'; 
            ctx.fillRect(px + (r1 * (TILE-3)), py + (r2 * (TILE-3)), 3, 3);
            ctx.fillStyle = 'rgba(200, 255, 100, 0.15)'; 
            ctx.fillRect(px + (r2 * (TILE-2)), py + (r3 * (TILE-2)), 2, 2);
        }
        // C. FOREST (Deep)
        else if(t === T.FOREST) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)'; 
            ctx.fillRect(px + (r1 * (TILE-3)), py + (r2 * (TILE-3)), 3, 3);
            ctx.fillRect(px + (r3 * (TILE-3)), py + (r4 * (TILE-3)), 3, 3);
        }
        // D. SAND (Dunes)
        else if(t === T.SAND) {
            ctx.fillStyle = 'rgba(200, 100, 0, 0.2)'; 
            ctx.fillRect(px + (r1 * (TILE-2)), py + (r2 * (TILE-2)), 2, 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)'; 
            ctx.fillRect(px + (r2 * (TILE-2)), py + (r3 * (TILE-2)), 2, 2);
        }
        // E. RUINS (Cracked)
        else if(t === T.RUINS) {
            ctx.strokeStyle = '#555'; ctx.lineWidth = 2;
            ctx.strokeRect(px+2, py+2, 46, 46); 
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            ctx.fillRect(px + (r1 * (TILE-4)), py + (r2 * (TILE-4)), 4, 4);
        }
        // F. SNOW (Sparkle)
        else if(t === T.SNOW) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; 
            ctx.fillRect(px + (r1 * (TILE-2)), py + (r2 * (TILE-2)), 2, 2);
        }
        // G. SWAMP (Murky)
        else if(t === T.SWAMP) {
             ctx.fillStyle = 'rgba(50, 60, 0, 0.3)'; 
             ctx.fillRect(px + (r1 * (TILE-4)), py + (r2 * (TILE-4)), 4, 4);
             ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
             ctx.fillRect(px + (r3 * (TILE-3)), py + (r4 * (TILE-3)), 3, 3);
        }
        // --- [FIX] ADD MISSING REGION 7 & 8 TEXTURES ---
        
        // H. LAVA (Cracked Magma Crust)
        else if(t === T.LAVA) {
             // 1. Cooling Crust (Darker patches)
             ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; 
             ctx.fillRect(px + (r1 * (TILE-6)), py + (r2 * (TILE-6)), 6, 6);
             
             // 2. Molten Cracks (Bright Orange/Red)
             ctx.fillStyle = 'rgba(255, 87, 34, 0.4)'; 
             ctx.fillRect(px + (r2 * (TILE-3)), py + (r3 * (TILE-3)), 3, 3);
             
             // 3. Heat Bubbles (Yellow)
             ctx.fillStyle = 'rgba(255, 235, 59, 0.5)'; 
             ctx.fillRect(px + (r4 * (TILE-2)), py + (r1 * (TILE-2)), 2, 2);
        }

        // I. VOID (Cosmic Space Floor)
        else if(t === T.VOID) {
             // 1. Nebula Clouds (Purple)
             ctx.fillStyle = 'rgba(123, 31, 162, 0.2)'; 
             ctx.fillRect(px + (r1 * (TILE-5)), py + (r2 * (TILE-5)), 5, 5);
             
             // 2. Distant Stars (White/Blue)
             ctx.fillStyle = 'rgba(224, 247, 250, 0.4)'; 
             ctx.fillRect(px + (r3 * (TILE-2)), py + (r4 * (TILE-2)), 2, 2);
             
             // 3. Void Grid/Glitch (Darker)
             ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; 
             ctx.fillRect(px + (r2 * (TILE-8)), py + (r3 * (TILE-8)), 2, 8);
        }
        // -----------------------------------------------

        // J. BEDROCK
        else if(t === T.BEDROCK) {
            ctx.fillStyle = '#111'; ctx.fillRect(px, py, TILE, TILE);
        }
        







        // --- FARM DRAW DELEGATION (Plots, Fences, Debris) ---
        if(S.world === 'farm' && farmSys) {
             farmSys.draw(ctx, S.cam.x, S.cam.y);
        }







        
        
        
            }


// ============================================================
    // STEP 1: DRAW SWAMP MUD HERE (So it is the bottom layer)
    // ============================================================
    S.ents.forEach(e => {
        if(e.kind === 'big_mud') {
            let x = Math.floor(e.x*TILE - S.cam.x + sx);
            let y = Math.floor(e.y*TILE - S.cam.y + sy);
            // Only draw if visible on screen
            if(x > -300 && x < cvs.width+200 && y > -300 && y < cvs.height+200) {
                drawEnv(x, y, e.kind, e);
            }
        }
    });
    // ============================================================






    



// ===============================================
    // START: FLOOR TEXT (BOSS ARENA SIGNS)
    // ===============================================
    // ===============================================
    // START: FLOOR TEXT (BIG, GLOWING, FADING)
    // ===============================================
    if(S.bossDead && S.world === 'main') {
        ctx.save();
        ctx.textAlign = "center";
        
        // Helper to draw text that fades when you pass it
        const paintFloorText = (txt, subTxt, tx, ty, color, fadeThreshold, fadeDir) => {
            // --- 1. FADE LOGIC ---
            // fadeDir: 1 = Fade when walking Right (East)
            // fadeDir: -1 = Fade when walking Left (West)
            let alpha = 1.0;
            
            // If fading Right (Farm Path): Fade out as we step onto the bridge (x > 80)
            if (fadeDir === 1 && S.p.x > fadeThreshold) {
                alpha = Math.max(0, 1 - (S.p.x - fadeThreshold) / 4);
            }
            // If fading Left (Return Path): Fade out as we walk away (x < 68)
            else if (fadeDir === -1 && S.p.x < fadeThreshold) {
                alpha = Math.max(0, 1 - (fadeThreshold - S.p.x) / 4);
            }

            if (alpha <= 0.05) return; // Don't draw if invisible
            ctx.globalAlpha = alpha;

            // Coords
            let px = Math.floor(tx * TILE - S.cam.x + sx) + (TILE/2);
            let py = Math.floor(ty * TILE - S.cam.y + sy);

            // --- 2. GLOW EFFECT ---
            // Pulsing glow size
            let glowSize = 15 + Math.sin(Date.now() / 200) * 5; 

            // DRAW MAIN TITLE (Big)
            ctx.font = "bold 60px 'VT323', monospace"; 
            ctx.shadowColor = color; 
            ctx.shadowBlur = glowSize;
            ctx.fillStyle = color;
            ctx.fillText(txt, px, py);

            // DRAW SUBTITLE (Smaller, White)
            ctx.font = "bold 30px 'VT323', monospace";
            ctx.shadowColor = "#fff"; 
            ctx.shadowBlur = 10;
            ctx.fillStyle = "#fff";
            ctx.fillText(subTxt, px, py + 35);
        };

        // 1. Text pointing West (Left) -> Back to Village
        // Fades out if you walk Left past x=68
        paintFloorText("‚¨Ö RETURN", "TO VILLAGE", 65, 125, "#ff5252", 68, -1);

        // 2. Text pointing East (Right) -> To Farm
        // Fades out if you walk Right past x=80 (Onto the bridge)
        paintFloorText("REGION 9 ‚û°", "THE FARM", 85, 125, "#ffd700", 80, 1);

        ctx.restore();
    }
    // ===============================================
    // ===============================================
    // END: FLOOR TEXT
    // ===============================================







// --- START OF TECTONIC RUPTURE (FLOOR LAYER) ---
// --- START OF TECTONIC RUPTURE (FLOOR LAYER) ---
   // --- SPECIAL FLOOR VFX LOOP (Draws BEFORE Player) ---
    S.vfxs.forEach(v => {
























 if(v.type === 'void_ripple') {
            let x = Math.floor(v.x*TILE - S.cam.x + sx);
            let y = Math.floor(v.y*TILE - S.cam.y + sy);
            
            // Manual life decrement for floor layer
            v.life--; 
            if(v.life <= 0) v.dead = true;

            let cx = x + 25; 
            let cy = y + 42; 
            let prog = 1 - (v.life / v.maxLife); // 0.0 -> 1.0

            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(1.0, 0.6); // Flatten perspective

            // --- ANIMATION VARS ---
            // Fade: Fast in, Stay, Slow out
            let alpha = 1.0;
            if(prog < 0.1) alpha = prog / 0.1; 
            else if(prog > 0.8) alpha = 1 - ((prog - 0.8) / 0.2);
            
            ctx.globalAlpha = alpha * 0.95;

            // Time variable for wobbly movement
            let time = Date.now() / 120; 

            // --- A. THE BLACK POOL (Organic Shape) ---
            // It grows to max size then slowly shrinks
            let growCurve = Math.sin(Math.pow(prog, 0.6) * Math.PI); 
            let baseR = 10 + (growCurve * 55); 

            ctx.fillStyle = '#000'; // Void Black
            ctx.shadowBlur = 25; 
            ctx.shadowColor = '#4a148c'; // Deep Purple Glow

            ctx.beginPath();
            for(let a=0; a<=Math.PI*2; a+=0.1) {
                // FLUID MATH: Combine 2 sine waves for "blob" effect
                let distortion = Math.sin(a * 3 + time) * 4 + 
                                 Math.cos(a * 7 - time*1.5) * 3;
                
                let r = baseR + distortion;
                if(r < 0) r = 0;

                let px = Math.cos(a) * r;
                let py = Math.sin(a) * r;
                if(a===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();

            // --- B. THE SURFACE RIPPLES (Light Reflection) ---
            ctx.shadowBlur = 0;
            ctx.lineWidth = 2;
            
            // Generate 3 organic rings
            for(let i=0; i<3; i++) {
                // Rings loop continuously while the pool is alive
                let ringPhase = (prog * 3 + (i * 0.35)) % 1; 
                let ringR = ringPhase * baseR; // Expand outward
                let ringAlpha = (1 - ringPhase) * alpha; // Fade as they expand

                ctx.strokeStyle = `rgba(224, 86, 253, ${ringAlpha})`; // Neon Violet

                ctx.beginPath();
                for(let a=0; a<=Math.PI*2; a+=0.1) {
                    // Different distortion speed per ring for "churning" look
                    let wave = Math.sin(a * 5 + time + (i*2)) * (3 + i) + 
                               Math.cos(a * 10 - time*2) * 2;
                    
                    let r = ringR + wave;
                    if(r < 0) r = 0; 
                    // Don't draw outside the pool (clipping logic simplified)
                    if(r > baseR + 2) r = baseR + 2; 

                    let px = Math.cos(a) * r;
                    let py = Math.sin(a) * r;
                    if(a===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
            }

            ctx.restore();
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = 0;
            return; // Done drawing this VFX
        }






        // --- VISUAL: TECTONIC RUPTURE (Brown Crust + Black Core) ---
        if(v.type === 'tectonic_rupture') {
            ctx.shadowBlur = 0; 
            let cx = Math.floor(v.x*TILE - S.cam.x + sx) + 25;
            let cy = Math.floor(v.y*TILE - S.cam.y + sy) + 40;
            let prog = 1 - (v.life / v.maxLife);
            
            // Animation: Snaps open fast
            let openAmt;
            if(prog < 0.15) openAmt = prog * 6.6; 
            else if(prog > 0.85) openAmt = (1 - prog) * 6.6; 
            else openAmt = 1.0; 

            ctx.save();
            ctx.translate(cx, cy);
            
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';

            // 1. OUTER CRUST (Deep Bedrock Brown)
            // This is wider than the black hole, creating the "Brown Edge" you wanted
            ctx.strokeStyle = '#3e2723'; // <--- Distinct Dark Brown
            ctx.lineWidth = 16 * openAmt; 
            
            ctx.beginPath();
            if(v.web) {
                v.web.forEach(seg => {
                    ctx.moveTo(seg.x1, seg.y1);
                    ctx.lineTo(seg.x2, seg.y2);
                });
            }
            ctx.stroke();

            // 2. INNER ABYSS (The Black Hole inside the Brown)
            // Drawn narrower so the brown shows on the edges
            if (openAmt > 0.1) {
                ctx.strokeStyle = '#000000'; // Pure Black
                ctx.lineWidth = 8 * openAmt;
                ctx.stroke(); 
            }

            // 3. FLYING DEBRIS (Matching Brown)
            if(v.debris) {
                v.debris.forEach((d, i) => {
                    let flyProg = prog; 
                    if(flyProg > 0.9) return; 

                    let height = Math.sin(flyProg * 3.14) * 30; 
                    
                    ctx.save();
                    ctx.translate(d.x + (d.vx * flyProg * 30), d.y + (d.vy * flyProg * 30) - height);
                    ctx.rotate(d.rot + (flyProg * 5));
                    ctx.fillStyle = d.color;
                    ctx.fillRect(-d.size/2, -d.size/2, d.size, d.size);
                    ctx.restore();
                });
            }
            ctx.restore();
        }
    });
    // --- END OF TECTONIC RUPTURE ---







    S.ents.forEach(e => {
        if(e.kind === 'Fountain' || e.kind === 'Healing Crystal') {
            let px = Math.floor(e.x*TILE - S.cam.x + sx);
            let py = Math.floor(e.y*TILE - S.cam.y + sy);
            let w = e.w * TILE, h = e.h * TILE;
            
            ctx.fillStyle = `rgba(0, 255, 0, 0.2)`; 
            ctx.beginPath(); 
            ctx.arc(px+w/2, py+h/2, 200, 0, 6.28); 
            ctx.fill();
            
            ctx.shadowBlur = 20; ctx.shadowColor='#0f0';
            ctx.strokeStyle = `rgba(0, 255, 0, 0.8)`; ctx.lineWidth=3; ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
       





        if(e.type === 'web') {
             let px = Math.floor(e.x*TILE - S.cam.x + sx);
             let py = Math.floor(e.y*TILE - S.cam.y + sy);
             ctx.strokeStyle='#eee'; ctx.lineWidth=2;
             ctx.globalAlpha = e.life/80;
             ctx.beginPath(); 
             for(let i=0; i<8; i++) {
                 let ang = i/8 * 6.28;
                 ctx.moveTo(px+25,py+25); ctx.lineTo(px+25+Math.cos(ang)*80, py+25+Math.sin(ang)*80);
             }
             ctx.stroke();
             ctx.beginPath(); ctx.arc(px+25,py+25, 40, 0, 6.28); ctx.stroke();
             ctx.beginPath(); ctx.arc(px+25,py+25, 70, 0, 6.28); ctx.stroke();
             ctx.globalAlpha=1;
        }

        if(e.type==='vfx_proj') {
            let px = Math.floor(e.x*TILE - S.cam.x + sx);
            let py = Math.floor(e.y*TILE - S.cam.y + sy);
            let alpha = e.life / e.maxLife;
            ctx.strokeStyle = `rgba(224, 255, 255, ${alpha})`; 
            ctx.shadowColor = '#00e5ff'; ctx.shadowBlur = 15 * alpha; ctx.lineWidth = 3;
            ctx.save();
            ctx.translate(px+25, py+25);
            ctx.rotate((Date.now() / 100) + e.id); 
            ctx.beginPath();
            let points = 50; 
            for(let j=0; j<points; j++) {
                let prog = j / points; 
                let angle = prog * (Math.PI * 2 * 3);
                let r = (prog * 25) * e.scale; 
                let rx = Math.cos(angle) * r;
                let ry = Math.sin(angle) * r;
                if(j===0) ctx.moveTo(rx, ry); else ctx.lineTo(rx, ry);
            }
            ctx.stroke();
            ctx.restore();
            ctx.shadowBlur = 0;
        }
    });

    // --- [SANDWICH START] ---
    S.parts.forEach((p,i) => {
        // FRICTION PHYSICS (Make fireflies explode fast then float)
        if(p.type === 'firefly') {
            p.vx *= 0.92; // Slow down 8% per frame
            p.vy *= 0.92;
        }

        p.x+=p.vx; p.y+=p.vy;
        p.life--;
        let px = p.x*TILE-S.cam.x+sx, py = p.y*TILE-S.cam.y+sy;
// --- [SANDWICH END] ---
        













// FIX: Check if 'type' exists first. 
        // If p.type is undefined (from Farm), this check fails safely and skips to the 'else' block.
        if(p.type && p.type.includes('icon_')) {
             let icon = p.type.split('_')[1];
             let scale = p.s/10;
             ctx.font = (20*scale)+"px sans-serif";
             ctx.fillText(icon, px, py);
        } 
        else if(p.type === 'heal_txt') {
             ctx.font = "bold 30px monospace";
             ctx.strokeStyle = "white"; ctx.lineWidth=3;
             ctx.strokeText("+", px, py);
             ctx.fillStyle = "#ff69b4"; 
             ctx.fillText("+", px, py);
        }
        // --- [SANDWICH START] ---
        else {
            ctx.fillStyle=p.c; 
            
            // FADING LOGIC
            if(p.type==='cloud') ctx.globalAlpha = p.life/50;
            // Fireflies fade out quickly in their last 15 frames
            else if(p.type==='firefly') ctx.globalAlpha = Math.min(1, p.life / 15); 
// --- [SANDWICH END] ---
            














if(p.type==='bubble') {
                ctx.strokeStyle=p.c; ctx.lineWidth=2; ctx.globalAlpha=p.life/20;
                ctx.beginPath(); ctx.arc(px+p.s/2, py+p.s/2, p.s, 0, 6.28); ctx.stroke(); 
            } else {
                ctx.beginPath(); ctx.arc(px+p.s/2, py+p.s/2, p.s, 0, 6.28); ctx.fill(); 
            }
        }
        ctx.globalAlpha = 1;
        if(p.life<=0) p.dead = true;
    });
  
 S.parts = S.parts.filter(p => !p.dead);
    // MANDATORY FIX: Cap particles to prevent crash
    if(S.parts.length > 500) S.parts.splice(0, 50);




// ============================================================
    // LAYER 2.5: LETTER TILES (The "Cheese")
    // Drawn AFTER Quake/VFX, but BEFORE Player/Trees
    // ============================================================
    for(let y=cy; y<ey; y++) for(let x=cx; x<ex; x++) {
        if(x<0||y<0||x>=MAP_S||y>=MAP_S) continue;
        let t = S.map[y*MAP_S+x];
        
        // Recalculate position for this layer
        let px = Math.floor(x*TILE-S.cam.x+sx);
        let py = Math.floor(y*TILE-S.cam.y+sy);

        if(t===T.BLOCK && S.wordData[y*MAP_S+x]) {
             let e = S.wordData[y*MAP_S+x];
             let cTop='#eee', cSide='#bbb', cTxt='#111';
             
             if(e.theme === 'blue') { cTop='#2980b9'; cSide='#1a5276'; cTxt='#fff'; }
             if(e.theme === 'red') { cTop='#c0392b'; cSide='#922b21'; cTxt='#fff'; }
             if(e.theme === 'gold') { cTop='#f1c40f'; cSide='#b7950b'; cTxt='#000'; }
             if(e.theme === 'purple') { cTop='#8e44ad'; cSide='#6c3483'; cTxt='#fff'; }
             if(e.theme === 'green') { cTop='#27ae60'; cSide='#1e8449'; cTxt='#fff'; }
             
             ctx.fillStyle = cTop; 
             ctx.fillRect(px, py, 50, 50); 
             ctx.strokeStyle = cSide; ctx.lineWidth = 4;
             ctx.strokeRect(px+2, py+2, 46, 46);

             ctx.font = 'bold 30px monospace'; 
             ctx.fillStyle = cTxt; ctx.textAlign='center'; 
             ctx.fillText(e.char, px+25, py+35);
             ctx.textAlign='left';
        }
    }
    // ============================================================










    // ============================================================
    // STEP 2: DEFINE THE LIST (Filter out the Mud!)
    // ============================================================
    
    // 1. Create list, but EXCLUDE 'big_mud' (because we drew it earlier)
    let list = S.ents.filter(e => e.kind !== 'big_mud');

   // --- [SANDWICH START] ---
    // 2. Add the Player (Only if not hidden by Ult)
    if(S.p.class && !S.p.hidden) list.push({type:'p', x:S.p.x, y:S.p.y, h:1});
// --- [SANDWICH END] ---

    // ============================================================
    
    // 1. TOP BUN (Keep this line)
    list = list.filter(e => !e.dead && e.type!=='zone' && e.type!=='web' && e.type!=='vfx_proj' && e.type!=='tile_block');
    
    // --- [PASTE THIS NEW BLOCK HERE] ---
    
    // Check House status first (needed for sorting)
    let house = S.ents.find(e => e.kind === 'FarmHouse');
    let isInside = house && xIn(house, S.p.x, S.p.y);

    // --- SORTING LOGIC (Depth Buffer) ---
    // --- SORTING LOGIC ---
    list.sort((a,b) => {
        let getDepth = (e) => {
            // 1. FORCE BOTTOM LAYER
            if (e.kind === 'big_mud') return -999999; 
            if (e.type === 'void_aura') return -999998; // <--- ADD THIS LINE (Right above mud)

            // 2. FORCE TOP LAYER
            if (e.type === 'shadow_hand') return 999999; 
            if (e.type === 'tornado') return 500000; 
            
            // ... rest of logic ...
            if (e.kind === 'FarmHouse') return isInside ? -10000 : (e.y + e.h);
            if (e.type === 'p') return e.y + 1.2;
            
            // ... (keep existing boss/env logic) ...
            if (e.type === 'mob' && e.boss) {
                 if(e.name === 'Chaos Titan') return e.y + e.h - 3.5;
                 return e.y + e.h - 1.2;
            }
            if (e.type === 'env') {
                if (e.kind === 'lava_crater') return e.y + e.h - 0.2;
                return e.y + 0.85; 
            }

            return e.y + (e.h||1);
        };
        return getDepth(a) - getDepth(b);
    });




    // -----------------------------------

    // 2. BOTTOM BUN (Keep this line)
   

    list.forEach(e => {
        try {
            let x = Math.floor(e.x*TILE - S.cam.x + sx), y = Math.floor(e.y*TILE - S.cam.y + sy);
            if(x<-300 || x>cvs.width+200 || y<-300 || y>cvs.height+200) return;



/////////////




/////////////


            // Add ", e" at the end so the function knows the size!
if(e.type==='env') drawEnv(x, y, e.kind, e);
            else if(e.type==='struct') drawStruct(x,y,e);
            else if(e.type==='p') drawHero(x,y);
            else if(e.type==='mob') drawMob(x,y,e);



































// --- [SANDWICH START] ---
            if(e.type === 'execution_controller') {
                let px = Math.floor(e.x*TILE - S.cam.x + sx);
                let py = Math.floor(e.y*TILE - S.cam.y + sy);
                let r = e.radius * TILE;

                // 1. Draw Ring
                ctx.save();
                ctx.translate(px + 25, py + 25);
                ctx.beginPath(); ctx.arc(0, 0, r, 0, 6.28);
                ctx.strokeStyle = `rgba(118, 255, 3, ${0.5 + Math.sin(Date.now()/50)*0.3})`; 
                ctx.lineWidth = 3; ctx.stroke();
                ctx.restore(); 
                
               // 2. Draw Clones (Afterimage Effect)
                if(e.clones) {
                    e.clones.forEach((c, i) => {
                        // Skip drawing if invisible
                        if(c.opacity <= 0.01) return;

                        let cx = Math.floor(c.x * TILE - S.cam.x + sx);
                        let cy = Math.floor(c.y * TILE - S.cam.y + sy);
                        
                        ctx.save();
                        
                        // FIX: Use the specific opacity calculated in Update
                        ctx.globalAlpha = c.opacity;

                        if (c.fireAnim > 0) {
                            ctx.shadowColor = '#76ff03'; ctx.shadowBlur = 25; 
                            c.fireAnim--;
                        } 
                        
                        drawHero(cx, cy, c.dir); 
                        ctx.restore();
                    });
                }
            }
// --- [SANDWICH END] ---















 if(e.type === 'tornado') {
             let px = Math.floor(e.x*TILE - S.cam.x + sx);
             let py = Math.floor(e.y*TILE - S.cam.y + sy);
             
             // Smooth fade out
             let alpha = e.life < 20 ? e.life / 20 : 1.0;

             ctx.save();
             ctx.translate(px+25, py+40); 
             ctx.scale(e.scale, e.scale); // Uses the updated large scale
             ctx.globalAlpha = alpha;

             let time = Date.now() / 40; 

             // --- LAYER 1: THE CORE (Gradient Funnel) ---
             // No more stacked rings. One solid shape.
             let grd = ctx.createLinearGradient(-15, -80, 15, 0);
             grd.addColorStop(0, "rgba(200, 230, 255, 0.1)"); // Top (Transparent)
             grd.addColorStop(0.5, "rgba(180, 210, 230, 0.6)"); // Mid (Thick)
             grd.addColorStop(1, "rgba(100, 130, 150, 0.2)"); // Bottom (Dusty)

             ctx.fillStyle = grd;
             ctx.beginPath();
             ctx.moveTo(-25, -90); // Top Left (Wide)
             ctx.quadraticCurveTo(0, -40, -5, 0); // Curve to bottom
             ctx.lineTo(5, 0);
             ctx.quadraticCurveTo(0, -40, 25, -90); // Top Right (Wide)
             ctx.closePath();
             ctx.fill();

             // --- LAYER 2: THE WIND STREAKS (Fast Spinning Lines) ---
             // Draw curved lines wrapping around the funnel
             ctx.lineWidth = 3;
             ctx.lineCap = 'round';
             
             for(let i=0; i<6; i++) {
                 // Calculate a "height" for this streak
                 let h = (time * 2 + i * 20) % 90; // Moves UP the tornado
                 let yPos = -h;
                 
                 // Width depends on height (Wider at top)
                 let w = 8 + (h * 0.3);
                 
                 // Sine wave for X to simulate 3D rotation
                 let rot = time * 0.5 + i;
                 let xOff = Math.sin(rot) * w;
                 let zDepth = Math.cos(rot); // Is it in front or behind?

                 // Only draw if "in front" (simple 3D effect) or transparent
                 ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + zDepth*0.3})`; // Brighter when in front
                 
                 ctx.beginPath();
                 ctx.moveTo(xOff - 5, yPos); 
                 ctx.quadraticCurveTo(xOff, yPos - 2, xOff + 5, yPos);
                 ctx.stroke();
             }

             // --- LAYER 3: DEBRIS (Rocks & Dust) ---
             if(e.debris) {
                 e.debris.forEach(d => {
                     let dAng = d.angle + time * d.speed;
                     
                     // 3D Orbit Logic
                     let rx = Math.cos(dAng) * d.dist;
                     let ry = Math.sin(dAng) * (d.dist * 0.3) - d.yOff; // Elliptical & Vertical spread
                     
                     // Z-Index Sorting (Simple):
                     // If moving "back" (sin > 0), draw dark. If "front", draw light.
                     let isFront = Math.sin(dAng) > 0;
                     
                     ctx.fillStyle = isFront ? '#795548' : '#3e2723';
                     
                     ctx.beginPath();
                     ctx.arc(rx, ry, d.size, 0, 6.28);
                     ctx.fill();
                 });
             }
             
             // --- LAYER 4: GROUND DUST ---
             ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
             ctx.beginPath();
             ctx.ellipse(0, 0, 20 + Math.sin(time)*5, 8, 0, 0, 6.28);
             ctx.fill();

             ctx.restore();
             ctx.globalAlpha = 1.0;
        }










else if(e.type === 'shadow_hand') {
            // 1. Calculate Screen Positions
            let shakeX = (typeof sx !== 'undefined') ? sx : 0;
            let shakeY = (typeof sy !== 'undefined') ? sy : 0;
            
            let handScreenX = Math.floor(e.x * TILE - S.cam.x + shakeX);
            let handScreenY = Math.floor(e.y * TILE - S.cam.y + shakeY);
            
            let playerScreenX = Math.floor(S.p.x * TILE - S.cam.x + shakeX);
            let playerScreenY = Math.floor(S.p.y * TILE - S.cam.y + shakeY);

            // Anchor points
            let startX = playerScreenX + 25;
            let startY = playerScreenY + 40; 
            let endX = handScreenX + 25;
            let endY = handScreenY + 25;

            // 2. DRAW THE ARM (Tentacle connecting Player to Hand)
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            let midX = (startX + endX) / 2;
            let midY = (startY + endY) / 2;
            // Subtle wiggle for the arm
            let armWiggle = Math.sin(Date.now() / 200) * 15;
            
            ctx.quadraticCurveTo(midX + armWiggle, midY - armWiggle, endX, endY);
            
            ctx.lineCap = 'round';
            ctx.shadowBlur = 10; ctx.shadowColor = '#d500f9';
            ctx.strokeStyle = '#000'; 
            ctx.lineWidth = 5; 
            ctx.stroke();

            // 3. DRAW THE HUMAN-LIKE HAND
            ctx.shadowBlur = 0;
            ctx.save();
            ctx.translate(endX, endY);
            
            // Calculate angle so hand points away from player (towards target)
            // We rotate +90deg (PI/2) because we draw the hand pointing UP (-Y)
            let angle = Math.atan2(endY - startY, endX - startX);
            ctx.rotate(angle + Math.PI/2);

            let scale = e.state === 1 ? 0.9 : 1.2; 
            ctx.scale(scale, scale);

            // Common Style
            ctx.fillStyle = '#000';       
            ctx.strokeStyle = '#4a148c';  // Dark Purple Outline
            ctx.lineWidth = 1;

            // --- DRAW PALM ---
            ctx.beginPath();
            // A rounded rectangle shape for the palm
            ctx.moveTo(-8, 0); 
            ctx.lineTo(-10, -15); // Left side
            ctx.quadraticCurveTo(0, -18, 10, -15); // Top of palm (knuckles)
            ctx.lineTo(8, 0); // Right side
            ctx.quadraticCurveTo(0, 5, -8, 0); // Wrist
            ctx.fill();
            ctx.stroke();

            // --- DRAW FINGERS ---
            // Finger Config: [OffsetX, OffsetY, Length, Width]
            let fingers = [
                { x: -12, y: -8, l: 10, w: 3.5, thumb: true }, // Thumb
                { x: -7,  y: -15, l: 18, w: 3.0 }, // Index
                { x: -2,  y: -16, l: 20, w: 3.0 }, // Middle
                { x: 3,   y: -15, l: 17, w: 2.8 }, // Ring
                { x: 8,   y: -13, l: 12, w: 2.5 }  // Pinky
            ];

            fingers.forEach((f, i) => {
                ctx.beginPath();
                
                // Animate wiggle (only if not grabbing)
                let wiggle = (e.state === 0) ? Math.sin((Date.now()/100) + i) * 2 : 0;
                
                // Base of finger
                let bx = f.x;
                let by = f.y;
                
                if(f.thumb) {
                    // Draw Thumb (Angled out)
                    if(e.state === 0) { // Open
                        ctx.moveTo(bx, by);
                        ctx.quadraticCurveTo(bx - 8, by - 5, bx - 10 + wiggle, by - f.l);
                        ctx.lineTo(bx - 3, by - f.l + 3);
                    } else { // Clenched
                        ctx.moveTo(bx, by);
                        ctx.quadraticCurveTo(bx - 5, by - 2, bx, by - 5);
                    }
                } else {
                    // Draw Fingers
                    if(e.state === 0) {
                        // === REACHING (Straightish) ===
                        ctx.moveTo(bx, by);
                        // Curve slightly inward for a "grasping" look
                        let tipX = bx + (wiggle * 0.5); 
                        let tipY = by - f.l;
                        
                        ctx.quadraticCurveTo(bx - 2, by - (f.l/2), tipX, tipY); // Left edge
                        ctx.lineTo(tipX + f.w, tipY + 2); // Tip
                        ctx.quadraticCurveTo(bx + f.w + 1, by - (f.l/2), bx + f.w, by + 2); // Right edge
                    } else {
                        // === GRABBING (Curled/Fist) ===
                        // Draw them short and curled inward
                        ctx.moveTo(bx, by);
                        ctx.quadraticCurveTo(bx - 2, by - 5, bx + 1, by + 2); 
                        // Draw a "knuckle" bump to show fist
                        ctx.arc(bx + 2, by - 2, 3, 0, Math.PI*2);
                    }
                }
                ctx.fill();
                ctx.stroke();
            });

            ctx.restore();
        }






            else if(e.type==='npc') drawNPC(x,y,e);



            else if(e.type==='farm_mob') drawFarmMob(x,y,e);
            else if(e.type==='item') { 
                 let b = Math.sin(Date.now()/300)*5;
                 ctx.shadowColor='#fff'; ctx.shadowBlur=10; ctx.font="30px s"; 
                 ctx.fillText(e.name.includes('Herb')?'üåø':'üìú', x+10, y+35+b); 
                 ctx.shadowBlur=0;
            }



            else if(e.type==='obj') {
            
            // 1. THE NEW HIGH-RES STATUE
            if(e.name === 'Angel Statue') {
                drawHighResStatue(ctx, x, y, e.active);
            }




            // 2. FROZEN FRIEND (Custom Outfits & Hats)
            else if (e.name === 'Frozen Friend') {
                let w = 2 * TILE; 
                let h = 2 * TILE;
                let cx = x + w/2;
                let cy = y + h - 10;
                let t = Date.now();

                // --- A. GENERATE UNIQUE STYLE ---
                // We use their X/Y position to pick their clothes.
                // This ensures they look different from each other, but stay consistent.
                let seed = Math.floor(e.x * 13 + e.y * 7);
                
                // Palette Options
                const coats = ['#e53935', '#1e88e5', '#43a047', '#fb8c00', '#8e24aa', '#00acc1']; // Red, Blue, Green, Orange, Purple, Teal
                const hats  = ['#fff', '#212121', '#ffeb3b']; // White, Black, Yellow
                
                // Pick traits
                let coatColor = coats[seed % coats.length];
                let hatColor  = hats[(seed + 1) % hats.length];
                let hatType   = seed % 3; // 0=Beanie, 1=Earmuffs, 2=Hood
                let scarfColor = (seed % 2 === 0) ? '#fff' : '#ffd700'; // White or Gold Scarf

                // Helper to draw the Person
                const drawPerson = () => {
                    // Legs
                    ctx.fillStyle = '#37474f'; 
                    ctx.fillRect(-2.5, 0, 2, 8); ctx.fillRect(0.5, 0, 2, 8); 
                    
                    // Body (Coat)
                    ctx.fillStyle = coatColor; 
                    // Trapezoid Coat Shape
                    ctx.beginPath();
                    ctx.moveTo(-4, -12); ctx.lineTo(4, -12); 
                    ctx.lineTo(5, 2); ctx.lineTo(-5, 2); 
                    ctx.fill();
                    
                    // Coat Buttons
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(-0.5, -9, 1, 1); ctx.fillRect(-0.5, -6, 1, 1);

                    // Arms
                    ctx.strokeStyle = coatColor; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
                    ctx.beginPath();
                    if(e.active) { // Freed: Hands Up!
                        ctx.moveTo(-4, -9); ctx.lineTo(-8, -15); 
                        ctx.moveTo(4, -9);  ctx.lineTo(8, -15); 
                    } else { // Frozen: Arms Down
                        ctx.moveTo(-4, -9); ctx.lineTo(-5, -1);
                        ctx.moveTo(4, -9);  ctx.lineTo(5, -1);
                    }
                    ctx.stroke();

                    // Head
                    ctx.fillStyle = '#ffe0b2'; // Skin
                    ctx.beginPath(); ctx.arc(0, -14, 3.5, 0, Math.PI*2); ctx.fill();
                    
                    // Face
                    ctx.fillStyle = '#000'; 
                    ctx.fillRect(-1.5, -14, 1, 1); ctx.fillRect(0.5, -14, 1, 1);
                    
                    // --- HATS ---
                    if (hatType === 0) { // BEANIE (Pom-pom)
                        ctx.fillStyle = hatColor;
                        ctx.beginPath(); ctx.arc(0, -16, 3.5, Math.PI, 0); ctx.fill();
                        ctx.beginPath(); ctx.arc(0, -19, 1.5, 0, 6.28); ctx.fill(); // Pom
                    } 
                    else if (hatType === 1) { // EARMUFFS
                        ctx.strokeStyle = hatColor; ctx.lineWidth = 1;
                        ctx.beginPath(); ctx.arc(0, -14, 4, Math.PI, 0); ctx.stroke(); // Band
                        ctx.fillStyle = hatColor;
                        ctx.beginPath(); ctx.arc(-4, -14, 1.5, 0, 6.28); ctx.fill(); // Left Ear
                        ctx.beginPath(); ctx.arc(4, -14, 1.5, 0, 6.28); ctx.fill(); // Right Ear
                    }
                    else if (hatType === 2) { // HOOD (Fur Trim)
                        ctx.strokeStyle = coatColor; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(0, -14, 4, Math.PI, 0); ctx.stroke();
                    }

                    // Scarf
                    ctx.fillStyle = scarfColor; 
                    ctx.fillRect(-3, -11, 6, 2);
                    if(e.active) ctx.fillRect(2, -10, 2, 4); // Scarf tail flying if freed
                };

                // --- DRAWING LOGIC ---

                // STATE A: FREED
                if(e.active) {
                    // Water Puddle
                    ctx.fillStyle = 'rgba(129, 212, 250, 0.6)';
                    ctx.beginPath(); ctx.ellipse(cx, cy, 40, 18, 0, 0, Math.PI*2); ctx.fill();
                    
                    // Ice Shards
                    ctx.fillStyle = 'rgba(225, 245, 254, 0.8)';
                    for(let i=0; i<5; i++) {
                        let sx = cx + Math.sin(i*2)*30;
                        let sy = cy + Math.cos(i*2)*10;
                        ctx.fillRect(sx, sy, 4, 4);
                    }

                    ctx.save();
                    ctx.translate(cx, cy - 5); 
                    let bounce = Math.sin(t/150) * 3;
                    ctx.translate(0, bounce);
                    ctx.scale(3.0, 3.0); 
                    
                    drawPerson();

                    ctx.restore();

                    // Heart
                    ctx.font = "28px sans-serif"; ctx.fillStyle = "#ff1744"; ctx.textAlign = "center";
                    ctx.fillText("‚ù§Ô∏è", cx, cy - 90 + bounce); ctx.textAlign = "left";
                }

                // STATE B: FROZEN
                else {
                    let pulse = Math.sin(t/500) * 3;

                    // 1. Draw Person Inside (Dimmed)
                    ctx.save();
                    ctx.translate(cx, cy); 
                    ctx.scale(3.0, 3.0); 
                    ctx.globalAlpha = 0.9; // Slightly visible inside ice
                    drawPerson();
                    ctx.restore();

                    // 2. The Ice Crystal Overlay
                    ctx.save();
                    ctx.translate(cx, cy); 
                    
                    let iceGrad = ctx.createLinearGradient(0, -130, 0, 10);
                    iceGrad.addColorStop(0, 'rgba(225, 245, 254, 0.4)'); 
                    iceGrad.addColorStop(0.5, 'rgba(129, 212, 250, 0.3)');
                    iceGrad.addColorStop(1, 'rgba(41, 182, 246, 0.5)'); 

                    ctx.fillStyle = iceGrad;
                    ctx.beginPath();
                    ctx.moveTo(0, -130 + pulse); 
                    ctx.lineTo(35, -90); ctx.lineTo(45, -30); 
                    ctx.lineTo(25, 10); ctx.lineTo(-25, 10); 
                    ctx.lineTo(-45, -30); ctx.lineTo(-35, -90);
                    ctx.closePath();
                    ctx.fill();

                    // Ice Reflections
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(-20, -100); ctx.lineTo(-30, -50); ctx.stroke();
                    
                    // Outline
                    ctx.strokeStyle = '#81d4fa'; ctx.lineWidth = 1; ctx.stroke(); 
                    ctx.restore();
                }
            }




            // 3. TABLET (Keep as fallback)
            else if(e.name==='Tablet') {
                 let baseC = e.active ? '#f1c40f' : '#555';
                 let innerC = e.active ? '#f39c12' : '#333';
                 ctx.fillStyle=baseC; ctx.fillRect(x, y, 100, 100); 
                 ctx.fillStyle=innerC; ctx.fillRect(x+10, y+10, 80, 80);
                 ctx.fillStyle= e.active ? '#fff' : '#ffd700'; 
                 ctx.fillRect(x+20, y+20, 60, 5); ctx.fillRect(x+20, y+40, 60, 5);
                 ctx.fillRect(x+20, y+60, 60, 5);
            }
            
            // 4. PORTAL (If you have one)
            else if (e.name === 'PortalHome') {
                 ctx.fillStyle = '#0ff'; ctx.fillRect(x,y,e.w*TILE,e.h*TILE);
            }
        }



            // --- PASTE THIS NEW PROJECTILE BLOCK ---
          else if(e.type==='proj') { 
                
                // 1. VISUAL: PHOENIX FIRE (Warrior Z)
                if(e.vfxType === 'phoenix_fire') {
                    let angle = Math.atan2(e.vy, e.vx);
                    let time = (Date.now() - e.birth) / 50; 
                    if(Math.random() < 0.4) {
                         part(e.x - e.vx*2, e.y - e.vy*2, Math.random()>.5?'#ff5722':'#ffff00', 1, 3+Math.random()*4, 'cloud');
                    }
                    ctx.save(); ctx.translate(x, y); ctx.rotate(angle); ctx.scale(2.5, 2.5); 
                    ctx.lineCap = 'round';
                    for(let k=0; k<2; k++) {
                        let phase = k === 0 ? 0 : Math.PI; 
                        let tailLen = 45;
                        ctx.beginPath();
                        for(let i=0; i<tailLen; i+=2) {
                            let progress = i / tailLen; 
                            let thickness = (1 - progress) * 6;
                            let wave = Math.sin(i * 0.2 - time + phase) * (5 + (i*0.2)); 
                            let px = -i; let py = wave; 
                            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                            let c = progress < 0.2 ? '#fff' : (progress < 0.5 ? '#ffeb3b' : '#ff5722');
                            ctx.strokeStyle = c; ctx.lineWidth = thickness; ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(px, py); 
                        }
                        ctx.stroke();
                    }
                    ctx.shadowColor = '#ff3d00'; ctx.shadowBlur = 20;
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(5, 0, 8, 5, 0, 0, 6.28); ctx.fill();
                    ctx.fillStyle = 'rgba(255, 152, 0, 0.6)'; ctx.beginPath(); ctx.arc(0, 0, 12, 0, 6.28); ctx.fill();
                    ctx.shadowBlur = 0; ctx.restore();
                } 
                
                // 2. VISUAL: STANDARD PROJECTILES (Mobs + Player)
                else {
                    let sc = e.scale || 1.0;





                   // --- A. CHAOS TITAN: SPINNING VOID STAR ---
                    if(e.kind === 'chaos_star') {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(Date.now() / 100); // Fast Spin
                        ctx.scale(sc, sc); 
                        
                        ctx.fillStyle = '#000'; // Black Core
                        ctx.strokeStyle = '#d500f9'; // Purple Edge
                        ctx.lineWidth = 2;
                        ctx.shadowColor = '#d500f9'; ctx.shadowBlur = 15;
                        
                        ctx.beginPath();
                        for(let i=0; i<8; i++) {
                            let r = (i%2===0) ? 10 : 4; 
                            let a = (i/8) * 6.28;
                            ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
                        }
                        ctx.closePath();
                        ctx.fill(); ctx.stroke();
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    }




                   // --- [SANDWICH START] ---
                    // --- B. HYDRA: LIQUID SPIT (Purple & Large) ---
                    else if(e.kind === 'hydra_spit') {
                        let ang = Math.atan2(e.vy, e.vx);
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(ang - 1.57); 
                        ctx.scale(sc, sc);

                        // Draw Blob (Purple)
                        ctx.fillStyle = '#d500f9'; // Neon Purple
                        ctx.shadowColor = '#e040fb'; ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(0, 0, 6, 0, Math.PI, false); // Bigger base
                        ctx.lineTo(0, 18); // Longer tail
                        ctx.closePath();
                        ctx.fill();
                        
                        // Toxic Shine (Lighter Purple)
                        ctx.fillStyle = '#ea80fc';
                        ctx.beginPath(); ctx.arc(-2, 2, 2, 0, 6.28); ctx.fill();
                        
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    }
// --- [SANDWICH END] ---

                    // --- C. GENERIC MOB ICONS (Rock, Fire) ---
                    else if(e.icon === 'ü™®' || e.icon === 'üî•') {
                        ctx.save();
                        ctx.translate(x, y);
                        if(e.icon === 'ü™®') ctx.rotate(Date.now() / 150); // Spin Rock
                        
                        ctx.font = (20 * sc) + "px sans-serif";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(e.icon, 0, 0);
                        ctx.restore();
                    }

                    // --- D. PLAYER ATTACKS (Keep Existing) ---
                    else {
                        ctx.shadowColor = e.color; ctx.shadowBlur = 15;
                        ctx.fillStyle = e.color; 
                        
                        if(e.icon==='üèπ') {
                            let ang = Math.atan2(e.vy, e.vx);
                            ctx.save(); ctx.translate(x+25, y+25); ctx.rotate(ang); ctx.scale(sc, sc);
                            ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.lineTo(5,-5); ctx.moveTo(10,0); ctx.lineTo(5,5);
                            ctx.lineWidth=3; ctx.strokeStyle = e.color || '#fff'; 
                            ctx.stroke(); ctx.restore();
                        }
                        else if(e.star) {
                            ctx.save(); ctx.translate(x, y); ctx.rotate(Date.now() / 200); 
                            drawStar(ctx, 0, 0, 5, 20 * sc, 10 * sc); ctx.restore();
                        } 
                        else if(e.icon === 'üß™') {
                            ctx.save(); ctx.translate(x, y); ctx.rotate(Date.now()/150); 
                            ctx.font = "24px sans-serif"; ctx.shadowBlur=0; ctx.fillText('üß™', -12, 8); ctx.restore();
                        }
                        else {
                            ctx.beginPath(); ctx.arc(x, y, (e.effect && e.effect.icon==='‚òÑÔ∏è')?20:8, 0, 6.28); ctx.fill(); 
                        }
                        ctx.shadowBlur=0;
                    }
                }
// --- [SANDWICH END] ---
            }













// --- PASTE THIS HERE ---
            else if(e.type === 'yaka_controller') {
               let px = Math.floor(e.x*TILE - S.cam.x + sx);
               let py = Math.floor(e.y*TILE - S.cam.y + sy);
               
               // 1. Draw Trail (The Web)
               if(e.trail.length > 1) {
                   ctx.beginPath();
                   let t0 = e.trail[0];
                   ctx.moveTo(Math.floor(t0.x*TILE-S.cam.x+sx)+25, Math.floor(t0.y*TILE-S.cam.y+sy)+25);
                   for(let i=1; i<e.trail.length; i++) {
                       let t = e.trail[i];
                       ctx.lineTo(Math.floor(t.x*TILE-S.cam.x+sx)+25, Math.floor(t.y*TILE-S.cam.y+sy)+25);
                   }
                   ctx.lineTo(px+25, py+25); // Connect to current position
                   
                   ctx.lineCap = 'round';
                   ctx.lineJoin = 'round';
                   
                   // 1. OUTER GLOW (The Aura) - Massive Blur
                   ctx.shadowColor = '#ff0000'; 
                   ctx.shadowBlur = 25; // Big glow
                   ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)'; 
                   ctx.lineWidth = 12; // Very thick faint outer line
                   ctx.stroke();

                   // 2. INNER GLOW (The Energy)
                   ctx.shadowColor = '#ff1744'; 
                   ctx.shadowBlur = 10;
                   ctx.strokeStyle = '#ff1744'; 
                   ctx.lineWidth = 6; // Thick solid red line
                   ctx.stroke();
                   
                   // 3. CORE (The Hot Center)
                   ctx.shadowBlur = 0;
                   ctx.strokeStyle = '#fff'; 
                   ctx.lineWidth = 2; // Bright white core
                   ctx.stroke();
               }

               // 2. Draw Arrow Head (The Needle)
               ctx.save();
               ctx.translate(px+25, py+25);
               let target = e.plan[e.nextIdx];
               if(target) ctx.rotate(Math.atan2(target.y - e.y, target.x - e.x));
               
               ctx.fillStyle = '#fff';
               ctx.shadowColor = '#f00'; ctx.shadowBlur = 10;
               ctx.beginPath();
               ctx.moveTo(10, 0); ctx.lineTo(-8, -4); ctx.lineTo(-4, 0); ctx.lineTo(-8, 4); 
               ctx.fill();
               ctx.restore();
               ctx.shadowBlur = 0;
            }




        } catch(err) { }
    });

    






S.vfxs.forEach((v, i) => {
        // (No skip lines here)

        let x = Math.floor(v.x*TILE - S.cam.x + sx), y = Math.floor(v.y*TILE - S.cam.y + sy);
        v.life--;
        
        ctx.shadowBlur=15; ctx.shadowColor='#fff';
        
        // ... (Then your optimized drawing blocks follow below) ...
        // ... rest of the existing code ...







// --- VISUAL: NEON BEAM (Ranger Ult) ---
        if(v.type === 'neon_beam') {
            // Calculate screen coordinates
            let x1 = Math.floor(v.x1*TILE - S.cam.x + sx) + 25;
            let y1 = Math.floor(v.y1*TILE - S.cam.y + sy) + 25;
            let x2 = Math.floor(v.x2*TILE - S.cam.x + sx) + 25;
            let y2 = Math.floor(v.y2*TILE - S.cam.y + sy) + 25;
            
            let alpha = v.life / v.maxLife;
            ctx.save();
            ctx.lineCap = 'round';
            
            // 1. OUTER GLOW (Thick Neon Green)
            ctx.shadowColor = '#76ff03'; 
            ctx.shadowBlur = 20;
            ctx.strokeStyle = `rgba(118, 255, 3, ${alpha})`; 
            ctx.lineWidth = 8; 
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            
            // 2. INNER CORE (Thin White Hot)
            ctx.shadowBlur = 0;
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`; 
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.restore();
            return; // Stop processing this VFX here
        }











        // --- 2. VISUAL: FREEZE (Transparent Ice) ---
   // --- VISUAL: FREEZE (Instant Snap Animation) ---
        if(v.type === 'glacial_cone') {
            ctx.shadowBlur = 0;
            let cx = x + 25; 
            let cy = y + 40;
            let prog = 1 - (v.life / v.maxLife);
            
            let alpha = v.life < 40 ? v.life/40 : 1.0; 

            ctx.save();
            ctx.translate(cx, cy);
            ctx.globalAlpha = alpha;

            v.boulders.forEach(b => {
                // INSTANT POP-UP: Speed increased to 12
                // This makes them smash up from the ground immediately
                let myProg = (prog - b.delay) * 12; 
                
                if(myProg < 0) return;
                if(myProg > 1) myProg = 1;
                
                let scale = myProg;
                // Faster bounce recovery
                if(myProg > 0.8) scale = 1.0 + Math.sin((myProg-0.8)*15) * 0.1;

                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.scale(scale, scale);

                // 1. BASE SHADOW
                ctx.fillStyle = 'rgba(0, 60, 100, 0.15)';
                ctx.beginPath();
                ctx.moveTo(b.pts[0].x, b.pts[0].y + 15); 
                for(let i=1; i<b.pts.length; i++) ctx.lineTo(b.pts[i].x, b.pts[i].y + 15);
                ctx.fill();

                // 2. MAIN BODY
                let grad = ctx.createLinearGradient(-30, -60, 30, 60); 
                grad.addColorStop(0, 'rgba(255, 255, 255, 0.95)');   
                grad.addColorStop(0.3, 'rgba(200, 240, 255, 0.55)'); 
                grad.addColorStop(0.6, 'rgba(129, 212, 250, 0.45)'); 
                grad.addColorStop(1, 'rgba(2, 119, 189, 0.6)');      
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(b.pts[0].x, b.pts[0].y);
                for(let i=1; i<b.pts.length; i++) ctx.lineTo(b.pts[i].x, b.pts[i].y);
                ctx.closePath();
                ctx.fill();

                // 3. OUTLINE
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // 4. FRACTURES
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; 
                ctx.lineWidth = 1;
                ctx.beginPath();
                b.fractures.forEach(f => {
                    ctx.moveTo(f.x1, f.y1);
                    ctx.lineTo(f.x2, f.y2);
                });
                ctx.stroke();

                ctx.restore();
            });

            ctx.restore();
        }
















// ============================================
        // WARRIOR VFX: SWORD SWEEP (Z Skill)
        // ============================================
        // ============================================
        // WARRIOR VFX: SWORD SWEEP (Z Skill)
        // ============================================
      // ============================================
        // WARRIOR VFX: SWORD SWEEP (Z Skill)
        // ============================================
      // ============================================
        // WARRIOR VFX: SWORD SWEEP (Z Skill)
        // ============================================
        if(v.type === 'sword_sweep') {
             let x = Math.floor(v.x*TILE - S.cam.x + sx);
             let y = Math.floor(v.y*TILE - S.cam.y + sy);
             let prog = 1 - (v.life / v.maxLife);
             
             let baseAng = (v.dir === 0 ? -1.57 : v.dir === 1 ? 0 : v.dir === 2 ? 1.57 : 3.14);
             let swingArc = 1.5; 
             let currentRot = baseAng + ( (prog - 0.5) * swingArc * v.side );

             ctx.save();
             ctx.translate(x+25, y+25);
             ctx.scale(v.scale, v.scale); 
             ctx.rotate(currentRot);

             ctx.beginPath();
             ctx.arc(0, 0, 45, -0.5, 0.5, false);
             ctx.arc(0, 0, 25, 0.5, -0.5, true);
             ctx.closePath();

             ctx.fillStyle = v.color;
             ctx.globalAlpha = 0.8 * (1 - prog);
             ctx.fill();
             
             ctx.strokeStyle = v.color;
             // Use custom width if defined, else default to 2
             ctx.lineWidth = v.width || 2; 
             ctx.shadowColor = v.color;
             ctx.shadowBlur = 15;
             ctx.stroke();

             ctx.restore();
             ctx.globalAlpha = 1.0;
             ctx.shadowBlur = 0;
        }

        // ============================================
        // NEW: SHIELD AURA (The "Red Part")
        // ============================================
        if(v.type === 'shield_aura') {
             let x = Math.floor(v.x*TILE - S.cam.x + sx);
             let y = Math.floor(v.y*TILE - S.cam.y + sy);
             let prog = 1 - (v.life / v.maxLife);
             
             // Move with the shield
             let dist = prog * 60; 
             let dx=0, dy=0;
             if(v.dir===0) dy = -dist;
             if(v.dir===1) dx = dist;
             if(v.dir===2) dy = dist;
             if(v.dir===3) dx = -dist;

             ctx.save();
             ctx.translate(x+25+dx, y+25+dy);
             
             // Rotate to face direction
             let rot = 0;
             if(v.dir===1) rot = 1.57; if(v.dir===2) rot = 3.14; if(v.dir===3) rot = -1.57;
             ctx.rotate(rot);

             // Scale grows slightly
             let scale = 1.0 + (prog * 0.5); 
             ctx.scale(scale, scale);

             // FADE: Stay visible until end
             let alpha = prog > 0.8 ? (1 - ((prog-0.8)/0.2)) : 0.6;
             ctx.globalAlpha = alpha;

             // --- DRAW RED SHOCKWAVE CONE ---
             ctx.fillStyle = 'rgba(231, 76, 60, 0.4)'; // Red
             ctx.shadowColor = '#c0392b'; ctx.shadowBlur = 20;
             
             ctx.beginPath();
             // Draw a cone shape behind the shield
             ctx.moveTo(0, 0); 
             ctx.lineTo(-35, 40); // Wide bottom left
             ctx.quadraticCurveTo(0, 50, 35, 40); // Curved bottom
             ctx.lineTo(0, 0);
             ctx.fill();
             
             // Add "Rage" spikes
             ctx.strokeStyle = '#e74c3c';
             ctx.lineWidth = 3;
             ctx.beginPath();
             ctx.moveTo(0, 0); ctx.lineTo(-20 + Math.random()*10, 35);
             ctx.moveTo(0, 0); ctx.lineTo(20 - Math.random()*10, 35);
             ctx.stroke();

             ctx.restore();
             ctx.globalAlpha = 1.0;
             ctx.shadowBlur = 0;
        }

        // ============================================
        // WARRIOR VFX: SHIELD SLAM (The Shield Itself)
        // ============================================
        if(v.type === 'shield_slam') {
             let x = Math.floor(v.x*TILE - S.cam.x + sx);
             let y = Math.floor(v.y*TILE - S.cam.y + sy);
             let prog = 1 - (v.life / v.maxLife);
             let dist = prog * 60; 
             let dx=0, dy=0;
             if(v.dir===0) dy = -dist; if(v.dir===1) dx = dist; if(v.dir===2) dy = dist; if(v.dir===3) dx = -dist;

             ctx.save();
             ctx.translate(x+25+dx, y+25+dy);
             let rot = 0;
             if(v.dir===1) rot = 1.57; if(v.dir===2) rot = 3.14; if(v.dir===3) rot = -1.57;
             ctx.rotate(rot);
             let scale = 1.2 + (prog * 0.3); 
             ctx.scale(scale, scale);
             
             let alpha = prog > 0.8 ? (1 - ((prog-0.8)/0.2)) : 1.0;
             ctx.globalAlpha = alpha;
             ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 25;
             ctx.fillStyle = 'rgba(255, 215, 0, 0.65)'; 
             ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;

             ctx.beginPath();
             ctx.moveTo(0, -35); ctx.lineTo(28, -20); ctx.lineTo(22, 15);  
             ctx.lineTo(0, 40); ctx.lineTo(-22, 15); ctx.lineTo(-28, -20);
             ctx.closePath();
             ctx.fill(); ctx.stroke();

             ctx.beginPath();
             ctx.moveTo(0, -28); ctx.lineTo(0, 30);
             ctx.moveTo(-18, -5); ctx.lineTo(18, -5);
             ctx.lineWidth = 3; ctx.strokeStyle = '#fff'; ctx.stroke();
             
             ctx.restore();
             ctx.globalAlpha = 1.0;
             ctx.shadowBlur = 0;
        }






















if(v.type === 'explosion_cloud') {
            let cx = x + 25;
            let cy = y + 40;

            // --- OPTIMIZATION: HEAT HALO ---
            // Instead of blurring 40 individual puffs, we draw ONE big glow behind them.
            // This looks just as hot but is virtually free for the CPU.
            let prog = 1 - (v.life / v.maxLife);
            
            if(prog < 0.5) {
                ctx.save();
                ctx.translate(cx, cy - (prog * 60)); // Rise with the cloud
                ctx.fillStyle = `rgba(255, 87, 34, ${0.5 * (1 - prog * 2)})`; // Fading Orange
                ctx.beginPath();
                // A large soft circle behind the explosion
                ctx.arc(0, 0, 50 + (prog * 40), 0, 6.28);
                ctx.fill();
                ctx.restore();
            }

            // --- DRAW CLOUD PUFFS ---
            v.puffs.forEach(p => {
                // Physics: Move & Slow Down
                p.x += p.vx; 
                p.y += p.vy;
                p.vx *= 0.85; // Air resistance
                p.vy *= 0.85;

                let alpha = 1.0;
                
                // COLOR LOGIC: White -> Yellow -> Orange -> Red -> Black
                let color;
                if(prog < 0.15) {
                    color = '#ffffff'; // FLASH
                } else if(prog < 0.30) {
                    color = '#fff176'; // YELLOW
                } else if(prog < 0.50) {
                    color = '#ff9800'; // ORANGE
                } else if(prog < 0.70) {
                    color = '#bf360c'; // BURNT RED
                } else {
                    color = '#212121'; // SMOKE
                    alpha = v.life / (v.maxLife * 0.3); 
                }

                ctx.save();
                ctx.translate(cx + p.x, cy + p.y - (prog * 60)); // Mushroom cloud rise
                
                let scale = 0.5 + (prog * 3.5); 
                ctx.scale(scale, scale);
                ctx.rotate(p.rot); 

                ctx.globalAlpha = alpha;
                ctx.fillStyle = color;
                
                // Draw Cluster (Lumpy Shape)
                ctx.beginPath();
                ctx.arc(0, 0, p.r, 0, 6.28);
                ctx.arc(p.r*0.6, p.r*0.4, p.r*0.7, 0, 6.28);
                ctx.arc(-p.r*0.5, p.r*0.5, p.r*0.6, 0, 6.28);
                ctx.fill();

                // REMOVED: The expensive inner glow logic inside the loop
                
                ctx.restore();
            });
            ctx.globalAlpha = 1.0;
        }



















        ctx.shadowBlur=15; ctx.shadowColor='#fff';
        if(v.type==='slash') {
            ctx.strokeStyle='#fff'; ctx.lineWidth=6; 
            ctx.beginPath(); ctx.arc(x+25, y+25, 40, v.ang-0.5, v.ang+0.5); ctx.stroke();
        }
                
        // --- NEW: VOID NUKE (Destructive Visual) ---
        if(v.type === 'void_nuke') {
             ctx.save();
             ctx.translate(x+25, y+25); // Center on enemy
             
             let prog = 1 - (v.life / v.maxLife); // 0.0 to 1.0
             let explodeSize = 1 + (prog * 4.0);  // Expands fast!
             
             ctx.scale(explodeSize, explodeSize);
             ctx.rotate(v.rot + (prog * 2)); // Spin it!

             // Layer 1: The Initial White Flash (Disruptive)
             if(prog < 0.2) {
                 ctx.globalAlpha = 1 - (prog * 5);
                 ctx.fillStyle = '#fff';
                 ctx.beginPath(); ctx.arc(0,0, 20, 0, 6.28); ctx.fill();
                 ctx.globalAlpha = 1.0;
             }

             // Layer 2: The Black Void Star (The Tear)
             ctx.fillStyle = '#000';
             ctx.beginPath();
             for(let i=0; i<8; i++) { // Draw a jagged 8-point star
                 let angle = (i/8)*6.28;
                 let r = (i%2===0) ? 15 : 5; // Spike vs Core
                 ctx.lineTo(Math.cos(angle)*r, Math.sin(angle)*r);
             }
             ctx.fill();

             // Layer 3: Neon Purple Outline (The Energy)
             ctx.strokeStyle = '#d500f9';
             ctx.lineWidth = 2;
             ctx.shadowColor = '#d500f9'; ctx.shadowBlur = 20;
             ctx.stroke();

             // Layer 4: Chaos Lightning
             if(v.life % 2 === 0) {
                 ctx.strokeStyle = '#fff';
                 ctx.lineWidth = 1;
                 ctx.beginPath();
                 ctx.moveTo(0,0);
                 ctx.lineTo((Math.random()-0.5)*40, (Math.random()-0.5)*40);
                 ctx.stroke();
             }

             ctx.restore();
             ctx.shadowBlur = 0;
        }



        if(v.type==='quake') {
            ctx.strokeStyle='#8d6e63'; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(x,y+25); ctx.lineTo(x+50,y+25); ctx.stroke();
        }
        
        // DRAW YAKA ARROW (The Glowing Thread)
       // DRAW YAKA ARROW (The Glowing Web)
        if(v.type === 'yaka_trail') {
             let px = Math.floor(v.x*TILE - S.cam.x + sx); // Not used but keeps syntax safe
             
             // Fade out logic
             let alpha = v.life / v.maxLife;
             
             ctx.beginPath();
             if(v.trail.length > 0) {
                 let t0 = v.trail[0];
                 ctx.moveTo(Math.floor(t0.x*TILE-S.cam.x+sx)+25, Math.floor(t0.y*TILE-S.cam.y+sy)+25);
                 for(let i=1; i<v.trail.length; i++) {
                     let t = v.trail[i];
                     ctx.lineTo(Math.floor(t.x*TILE-S.cam.x+sx)+25, Math.floor(t.y*TILE-S.cam.y+sy)+25);
                 }
             }

             ctx.lineCap = 'round'; ctx.lineJoin = 'round';

             // Draw the lingering web
             ctx.globalAlpha = alpha;
             
             // Thick Glow
             ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 20;
             ctx.strokeStyle = '#d50000'; ctx.lineWidth = 8; 
             ctx.stroke();
             
             // Core
             ctx.shadowBlur = 0;
             ctx.strokeStyle = '#ff8a80'; ctx.lineWidth = 2;
             ctx.stroke();

             ctx.globalAlpha = 1.0;
        }





        ctx.shadowBlur=0;




        // 3. MARK DEAD
        if(v.life<=0) v.dead = true;
    });

    // 4. CLEANUP (Double Check this line is here!)
    S.vfxs = S.vfxs.filter(v => !v.dead);
    // ------------------------------------------




    // --- PASTE THIS NEW BLOCK ---
    // --- LIGHTNING DRAWING ---
    S.lighting.forEach((l, idx) => {
        l.life--; 
        let progress = l.life / l.maxLife; // 1.0 to 0.0
        
        ctx.lineCap = 'round'; 
        ctx.lineJoin = 'round';

        if(l.type === 'heavy_storm') {
            // FADE OUT LOGIC: Flash bright at start, fade slowly
            let alpha = progress; 
            
            // 1. MASSIVE OUTER GLOW (The Atmosphere)
            ctx.shadowColor = '#00e5ff'; 
            ctx.shadowBlur = 40 * alpha; // Huge blur
            ctx.strokeStyle = `rgba(0, 229, 255, ${alpha * 0.5})`;
            ctx.lineWidth = 18; // Very Thick
            ctx.beginPath(); 
            l.segs.forEach((s,i) => { if(i==0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); }); 
            ctx.stroke();

            // 2. INNER CORE (The Electricity)
            ctx.shadowBlur = 10;
            ctx.strokeStyle = `rgba(224, 255, 255, ${alpha})`;
            ctx.lineWidth = 6;
            ctx.beginPath(); 
            l.segs.forEach((s,i) => { if(i==0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); }); 
            ctx.stroke();

            // 3. PURE WHITE CENTER (The Hot Plasma)
            ctx.shadowBlur = 0;
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 3;
            ctx.stroke();

            // 4. DRAW BRANCHES (Thinner, erratic)
            ctx.strokeStyle = `rgba(0, 229, 255, ${alpha * 0.6})`;
            ctx.lineWidth = 2;
            l.branches.forEach(branch => {
                ctx.beginPath();
                branch.forEach((s,i) => { if(i==0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); });
                ctx.stroke();
            });

        } else {
            // Old fallback style
            ctx.strokeStyle=`rgba(150,220,255,${l.life/10})`; 
            ctx.lineWidth=3; ctx.shadowBlur=10; ctx.shadowColor='#fff';
            ctx.beginPath(); 
            l.segs.forEach((s,i) => { if(i==0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); }); 
            ctx.stroke();
        }

        if(l.life<=0) l.dead = true;
    });
    S.lighting = S.lighting.filter(l => !l.dead);
    ctx.shadowBlur=0;
    // ----------------------------






    S.shockwaves.forEach((w, i) => {
        w.r += 0.3; w.a -= 0.05; ctx.strokeStyle=`rgba(255,100,0,${w.a})`; ctx.lineWidth=5; ctx.shadowColor=w.c||'#fff'; ctx.shadowBlur=10;
        ctx.beginPath(); ctx.arc(w.x*TILE-S.cam.x+sx, w.y*TILE-S.cam.y+sy, w.r*TILE, 0, 6.28); ctx.stroke(); ctx.shadowBlur=0;
        if(w.a<=0) w.dead = true;
    });
    S.shockwaves = S.shockwaves.filter(w => !w.dead);
}

function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let x = cx, y = cy;
    let step = Math.PI / spikes;
    ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step;
        x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath(); ctx.fill();
}






function drawHero(x, y, overrideDir = null) { // <--- Added overrideDir argument
    let dir = (overrideDir !== null) ? overrideDir : S.p.dir; // Use override if provided
    let cls = S.p.class || 'warrior';
    
    // Animation Vars
    let isMoving = (S.input.keys['arrowup']||S.input.keys['arrowdown']||S.input.keys['arrowleft']||S.input.keys['arrowright']);
    let tick = Date.now() / 150;
    let bob = Math.sin(tick) * 1.5;
    let walk = isMoving ? Math.sin(tick * 3) : 0;
    
    // Setup Context
    ctx.save();
    
    // 1. POSITION & SCALE (1.3x)
    ctx.translate(x + 25, y + 42); 
    ctx.scale(1.3, 1.3); 
    
    // MIRROR FOR LEFT VIEW
    if (dir === 3) ctx.scale(-1, 1); 




// --- COLOR PALETTES ---
    let cSkin='#ffe0bd', cEye='#111';
    let cMain, cSec, cAcc, cDark, cBoot, cHair, cHigh;

    // --- CHECK POISON STATUS ---
 // --- CHECK STATUS EFFECTS ---
    let isPoisoned = (S.p.poisonedUntil && S.p.poisonedUntil > Date.now());
    let isBurned   = (S.p.burnedUntil && S.p.burnedUntil > Date.now());








    if(cls === 'warrior') {




        cMain='#eceff1'; cSec='#1565c0'; cAcc='#ffd700'; cDark='#455a64'; cBoot='#37474f';
        cHair='#3e2723'; cHigh='#ffffff'; // Metallic Highlight
    } else if(cls === 'mage') { 
        cMain='#4527a0'; cSec='#7c4dff'; cAcc='#00e5ff'; cDark='#311b92'; cBoot='#1a1a1a';
        cHair='#ffe082'; cHigh='#b388ff'; // Magic Sheen
    } else { 
        // RANGER
        cMain='#37474f'; cSec='#ff6d00'; cAcc='#ffeb3b'; cDark='#263238'; cBoot='#212121';
        cHair='#5d4037'; cHigh='#ff9e80'; // Cloth Texture
    }

// --- APPLY POISON TINT ---
    if(isPoisoned) {
        cSkin = '#ce93d8'; // Purple Skin
        cMain = '#7b1fa2'; // Dark Purple Clothes
        cAcc  = '#e1bee7'; // Light Purple accents
    }
// --- APPLY BURN TINT ---
    if(isBurned) {
        cSkin = '#ffab91'; // Reddish Skin
        cMain = '#bf360c'; // Burnt Red Clothes
        cAcc  = '#ff5722'; // Bright Orange Accents
    }





    // --- RIDING LIFT ---
    let lift = S.p.isRiding ? 12 : 0;
    ctx.translate(0, -lift);

    // --- DROP SHADOW ---
    if(!S.p.isRiding) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(0, 0, 10, 4, 0, 0, 6.28); ctx.fill();
    }

    // ============================
    // 1. DRAW LEGS (Boots with Soles)
    // ============================
    const drawBoot = (bx, by, w, h, color) => {
        ctx.fillStyle = color; ctx.fillRect(bx, by, w, h); // Boot Body
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(bx, by + h - 2, w, 2); // Sole/Shadow
    };

    if(dir === 0 || dir === 2) { 
        drawBoot(-7, -12 + (walk*2), 5, 12, cBoot);
        drawBoot(2, -12 - (walk*2), 5, 12, cBoot);
    } else { 
        drawBoot(-4 + (walk*4), -12, 6, 12, cDark); // Back Leg (Shadowed)
        drawBoot(-4 - (walk*4), -13, 6, 12, cBoot); // Front Leg
    }

    // ============================
    // 2. DRAW BODY
    // ============================
    let bodyY = -24 + bob;
    
    // BACK CAPE/HAIR (Layer 1)
    if(dir !== 2) { 
        if(cls === 'mage') {
            ctx.fillStyle = cHair;
            if(dir === 0) ctx.fillRect(-11, bodyY-12, 22, 22); 
            else ctx.fillRect(-8, bodyY-8, 10, 18); 
        }
        ctx.fillStyle = (cls==='mage') ? cDark : cSec; 
        if(dir === 0) ctx.fillRect(-10, bodyY+10, 20, 10);
        else ctx.fillRect(-9, bodyY+8, 6, 10);
    }

    // TORSO
    ctx.fillStyle = cMain;
    if(dir === 0 || dir === 2) { 
        ctx.fillRect(-9, bodyY, 18, 14); 
        ctx.fillStyle = cDark; ctx.fillRect(-9, bodyY+10, 18, 3); // Belt
        
        // Neck Shadow (Depth)
        ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(-5, bodyY, 10, 2);

        if(dir === 2) { // Front Details
            if(cls==='warrior') { // Armor Plate
                ctx.fillStyle = cSec; ctx.fillRect(-3, bodyY+2, 6, 8); ctx.fillRect(-6, bodyY+4, 12, 4);
                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillRect(-3, bodyY+2, 2, 2);
            }
            if(cls==='mage') { ctx.fillStyle = cAcc; ctx.fillRect(-2, bodyY, 4, 14); }
            if(cls==='rogue') { ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.moveTo(-9, bodyY); ctx.lineTo(-6, bodyY); ctx.lineTo(9, bodyY+14); ctx.lineTo(6, bodyY+14); ctx.fill(); }
        }
    } else { // Side
        ctx.fillRect(-6, bodyY, 12, 14);
        ctx.fillStyle = cDark; ctx.fillRect(-6, bodyY+10, 12, 3);
    }

    // ============================
    // 3. DRAW HEAD & HAIR
    // ============================
    let headY = bodyY - 14;
    
    // A. FACE SKIN (Hidden on Back View)
    if(dir !== 0) {
        ctx.fillStyle = cSkin;
        ctx.fillRect(-8, headY, 16, 16);
    }

    // B. HAIR
    ctx.fillStyle = cHair;
    if (cls === 'warrior') {
        if (dir === 2) { ctx.fillRect(-9, headY, 2, 8); ctx.fillRect(7, headY, 2, 8); }
        else if (dir === 0) { ctx.fillRect(-8, headY+2, 16, 12); } 
        else { ctx.fillRect(-8, headY, 14, 14); }
    } 
    else if (cls === 'mage') {
        if (dir === 2) { ctx.fillRect(-11, headY-2, 5, 20); ctx.fillRect(6, headY-2, 5, 20); } 
        else if (dir !== 0) { ctx.fillRect(-6, headY-2, 12, 20); }
    } 
    else { // ROGUE
        if (dir === 2) { 
            ctx.fillRect(-9, headY, 18, 4); ctx.fillRect(-8, headY+2, 3, 3); 
            ctx.fillRect(0, headY+2, 4, 3); ctx.fillRect(6, headY+2, 2, 4);
            ctx.fillRect(-9, headY, 2, 10); ctx.fillRect(7, headY, 2, 10);
        } else if (dir === 0) { ctx.fillRect(-9, headY-2, 18, 16); } 
        else { ctx.fillRect(-8, headY, 14, 4); ctx.fillRect(-10, headY+4, 6, 10); }
    }

    // C. HAT / HELMET (With Shading)
    if(cls === 'warrior') { 
        ctx.fillStyle = cMain; 
        ctx.fillRect(-9, headY-5, 18, 10); 
        // Metallic Shine on Helmet
        ctx.fillStyle = cHigh; ctx.fillRect(-6, headY-4, 4, 3);

        if(dir === 0 || dir === 2) { 
            ctx.fillStyle = cMain; ctx.fillRect(-10, headY-2, 2, 14); ctx.fillRect(8, headY-2, 2, 14); 
            if(dir === 0) ctx.fillRect(-5, headY+2, 10, 8); 
        } else { ctx.fillStyle = cMain; ctx.fillRect(0, headY-2, 9, 14); }
        
        // Crest
        ctx.fillStyle = cSec; 
        if (dir !== 1 && dir !== 3) ctx.fillRect(-2, headY-8, 4, 16); 
        else { ctx.fillRect(-9, headY-8, 18, 4); ctx.fillRect(7, headY-8, 4, 16); }
    } 
    else if(cls === 'mage') { 
        ctx.fillStyle = cMain; 
        ctx.beginPath(); ctx.moveTo(-14, headY); ctx.lineTo(14, headY); ctx.lineTo(0, headY-20); ctx.fill();
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; // Brim Shadow
        ctx.fillRect(-14, headY, 28, 2);
        ctx.fillStyle = cAcc; ctx.fillRect(-8, headY-2, 16, 2);
    } 
    else { // ROGUE CAP
        ctx.fillStyle = cSec; 
        if(dir === 2 || dir === 0) { 
            ctx.beginPath(); ctx.ellipse(0, headY, 10, 4, 0, 0, 6.28); ctx.fill();
            ctx.beginPath(); ctx.ellipse(0, headY-3, 9, 5, 0, 0, 6.28); ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.ellipse(-3, headY-5, 4, 2, 0, 0, 6.28); ctx.fill(); // Highlight
            ctx.strokeStyle = cAcc; ctx.lineWidth = 3; 
            ctx.beginPath(); ctx.moveTo(4, headY-3); ctx.quadraticCurveTo(12, headY-12, 8, headY-18); ctx.stroke();
        } else { 
            ctx.beginPath(); ctx.moveTo(-10, headY); ctx.lineTo(10, headY); ctx.lineTo(6, headY-5); ctx.lineTo(-8, headY-5); ctx.fill();
            ctx.strokeStyle = cAcc; ctx.lineWidth = 3; 
            ctx.beginPath(); ctx.moveTo(0, headY-3); ctx.quadraticCurveTo(-10, headY-8, -14, headY-2); ctx.stroke();
        }
    }

    // D. EYES
    if(dir !== 0) {
        ctx.fillStyle = (cls==='mage') ? cAcc : cEye; // Mage has Glowing Eyes?
        if(dir === 2) { ctx.fillRect(-5, headY+6, 3, 3); ctx.fillRect(2, headY+6, 3, 3); } 
        else { ctx.fillRect(3, headY+6, 3, 3); }
    }

    // E. SCARF
    if(cls === 'rogue') {
        ctx.fillStyle = cAcc; 
        if(dir===2 || dir===0) ctx.fillRect(-7, headY+12, 14, 4);
        else ctx.fillRect(-4, headY+12, 8, 4);
    }

    // ============================
    // 4. DRAW ARMS
    // ============================
    ctx.fillStyle = cMain;
    
    if(dir === 0 || dir === 2) { 
        let armS = (dir===2 && isMoving) ? -walk : 0;
        ctx.fillStyle = (cls==='warrior') ? cMain : cSec; 
        ctx.fillRect(-14, bodyY, 5, 5); ctx.fillRect(9, bodyY, 5, 5);

        // Arm Shadow (Under Shoulder)
        ctx.fillStyle = (cls==='warrior') ? cDark : cMain; 
        ctx.fillRect(-13, bodyY+3+armS, 4, 2); ctx.fillRect(9, bodyY+3-armS, 4, 2);

        ctx.fillStyle = (cls==='warrior') ? cMain : cSkin; 
        ctx.fillRect(-13, bodyY + 5 + armS, 4, 7); 
        ctx.fillRect(9, bodyY + 5 - armS, 4, 7);
        
        ctx.fillStyle = (cls==='mage') ? cSkin : cDark; 
        ctx.fillRect(-13, bodyY + 10 + armS, 4, 3);
        ctx.fillRect(9, bodyY + 10 - armS, 4, 3);

    } else { 
        ctx.fillStyle = (cls==='warrior') ? cMain : cSec;
        ctx.fillRect((walk*3), bodyY + 2, 4, 6);
        ctx.fillStyle = (cls==='warrior') ? cMain : cSkin;
        ctx.fillRect((walk*3), bodyY + 8, 4, 6);
    }

    // ============================
    // 5. CARRY ITEM
    // ============================
    if (S.carry && S.carry.icon) {
        ctx.save();
        if (dir === 3) ctx.scale(-1, 1); 
        ctx.font = "20px serif"; ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.shadowColor="#000"; ctx.shadowBlur=4;
        ctx.fillText(S.carry.icon, 0, headY - 20 + bob);
        ctx.shadowBlur=0;
        ctx.restore();
    }

    ctx.restore();
}







function drawFarmMob(x, y, m) {
    let b = Math.sin(Date.now()/200)*2;
    if(m.name === 'Dog') {
        ctx.fillStyle = '#8d6e63';
        ctx.fillRect(x+15, y+25-b, 20, 15); // Body
        ctx.fillRect(x+30, y+20-b, 12, 12); // Head
        ctx.fillStyle = '#3e2723';
        ctx.fillRect(x+15, y+40-b, 5, 5); ctx.fillRect(x+30, y+40-b, 5, 5);
        ctx.fillRect(x+40, y+25-b, 3, 5); // Ear
    }
    if(m.name === 'Chicken') {
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x+25, y+30-b, 10, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#f39c12'; ctx.beginPath(); ctx.moveTo(x+35,y+28-b); ctx.lineTo(x+40,y+30-b); ctx.lineTo(x+35,y+32-b); ctx.fill();
        ctx.fillStyle = '#c0392b'; ctx.fillRect(x+22, y+20-b, 6, 4);
    }
    if(m.name === 'Cow') {
        ctx.fillStyle = '#fff'; ctx.fillRect(x+10, y+20-b, 30, 20);
        ctx.fillStyle = '#000'; ctx.fillRect(x+15, y+25-b, 10, 8); ctx.fillRect(x+30, y+22-b, 5, 5);
        ctx.fillStyle = '#fff'; ctx.fillRect(x+38, y+20-b, 10, 15); // Head
        ctx.fillStyle = '#000'; ctx.fillRect(x+38, y+20-b, 3, 15); ctx.fillRect(x+46, y+22-b, 2, 2);
    }
}

function drawMob(x, y, m) {
    let b = Math.sin(Date.now()/200)*3;

    // --- 1. SETUP SCALE & LIFT ---
    let sc = 1.4; 
    let yLift = 0; 

    if (m.boss) {
        if (m.name === "Chaos Titan") { sc = 3.0; yLift = 75; }
        else if (m.name.includes("Dragon")) { sc = 2.6; yLift = 50; }
        else if (m.name.includes("Hydra")) { sc = 2.6; yLift = 45; }
        else { sc = 1.8; yLift = 20; }
    }
    
    // --- 2. APPLY TRANSFORM ---
    ctx.save(); 
    // Move to center, apply Lift, Scale, move back
    ctx.translate(x+25, y+25 - yLift); 
    ctx.scale(sc, sc); 
    ctx.translate(-(x+25), -(y+25));

    let tint = null;    const now = Date.now();
    if(m.status.burn > now) tint = '#e74c3c'; 
    else if(m.status.freeze > now) tint = '#4fc3f7'; 
    else if(m.status.poison > 0) tint = '#8e44ad'; 

    // --- HEALTH BAR & NAME (Moved UP to avoid overlapping the higher sprites) ---
    ctx.fillStyle='#fff'; ctx.font='bold 12px monospace'; ctx.strokeStyle='#000'; ctx.lineWidth=2;
    ctx.strokeText(m.name, x, y-35+b); ctx.fillText(m.name, x, y-35+b);
    ctx.fillStyle = '#444'; ctx.fillRect(x, y-30+b, 50, 6);
    ctx.fillStyle = '#e74c3c'; ctx.fillRect(x, y-30+b, 50*(Math.max(0,m.hp)/m.maxHp), 6);

    const drawEyes = (ex, ey) => {
        ctx.fillStyle='#000'; ctx.fillRect(ex, ey, 4, 4);
        ctx.fillStyle='#fff'; ctx.fillRect(ex+1, ey+1, 2, 2); 
    };

    // --- MONSTER DRAWING (All Y coordinates shifted -10px to -15px) ---








   if(m.name.includes('Boar')) {
        let faceDir = (m.x < S.p.x) ? -1 : 1; 

        ctx.save();
        ctx.translate(x+25, y+25); 
        ctx.scale(faceDir, 1); 

        // --- ANIMATION FIX: Position based ---
        // If x/y don't change, 'walk' stays constant. Legs stop moving!
        let walk = Math.sin((m.x + m.y) * 0.8) * 4;

        // 1. BACK LEGS (Darker)
        ctx.fillStyle = '#212121'; 
        ctx.beginPath();
        ctx.ellipse(-10 + walk, 12, 4, 6, 0, 0, 6.28); // Back L
        ctx.ellipse(10 - walk, 12, 4, 6, 0, 0, 6.28);  // Front L
        ctx.fill();

        // 2. MAIN BODY (Heavy, Dark Fur)
        // Dark Grey to contrast Green Grass
        ctx.fillStyle = tint || '#424242'; 
        ctx.beginPath();
        // Teardrop shape: Big chest, small hip
        ctx.moveTo(-15, 5); 
        ctx.bezierCurveTo(-20, -15, 10, -20, 18, 0); // Top curve
        ctx.quadraticCurveTo(20, 12, -15, 12);       // Bottom curve
        ctx.fill();

        // 3. FRONT LEGS (Lighter)
        ctx.fillStyle = '#616161'; 
        ctx.beginPath();
        ctx.ellipse(-6 - walk, 14, 4, 6, 0, 0, 6.28); // Back R
        ctx.ellipse(14 + walk, 14, 4, 6, 0, 0, 6.28); // Front R
        ctx.fill();

        // 4. MANE (The Mohawk)
        ctx.fillStyle = '#212121';
        ctx.beginPath();
        ctx.moveTo(-10, -10);
        ctx.lineTo(-5, -18); ctx.lineTo(0, -12);
        ctx.lineTo(5, -20);  ctx.lineTo(10, -12);
        ctx.lineTo(18, -5);  ctx.lineTo(-12, -5);
        ctx.fill();

        // 5. SNOUT & FACE
        ctx.fillStyle = '#8d6e63'; // Brown snout
        ctx.beginPath(); ctx.ellipse(-18, 2, 6, 5, 0, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#000'; // Nose tip
        ctx.beginPath(); ctx.ellipse(-22, 2, 2, 4, 0, 0, 6.28); ctx.fill();

        // 6. TUSK (The defining feature)
        ctx.fillStyle = '#fff'; 
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-16, 5);
        ctx.quadraticCurveTo(-14, -5, -22, -8); // Curve Up
        ctx.lineTo(-20, -2);
        ctx.fill(); ctx.stroke();

        // 7. EYE (Angry Red)
        ctx.fillStyle = '#ff1744';
        ctx.beginPath(); ctx.arc(-12, -2, 2.5, 0, 6.28); ctx.fill();

        ctx.restore(); 
    }








    else if(m.name==='Ent') {
        // Trunk (Textured)
        ctx.fillStyle = tint || '#4e342e'; 
        ctx.fillRect(x+15, y+5-b, 20, 35);
        // Bark Texture
        ctx.fillStyle = '#3e2723';
        ctx.fillRect(x+18, y+10-b, 2, 8); ctx.fillRect(x+28, y+25-b, 3, 10);

        // Leaves (Foliage Afro)
        ctx.fillStyle = tint || '#2e7d32'; 
        ctx.beginPath(); ctx.arc(x+15, y-5-b, 12, 0, 6.28); ctx.fill(); 
        ctx.beginPath(); ctx.arc(x+35, y-5-b, 12, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(x+25, y-15-b, 15, 0, 6.28); ctx.fill();
        
        // Glowing Eyes (Magic Wood)
        ctx.fillStyle = '#76ff03'; ctx.shadowColor='#76ff03'; ctx.shadowBlur=5;
        ctx.fillRect(x+20, y+12-b, 4, 4); ctx.fillRect(x+28, y+12-b, 4, 4);
        ctx.shadowBlur=0;
        
        // Branch Arms
        ctx.strokeStyle = '#4e342e'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(x+15, y+15-b); ctx.lineTo(x+5, y+25-b); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x+35, y+15-b); ctx.lineTo(x+45, y+25-b); ctx.stroke();
    }










    else if(m.name.includes('Scorpion')) {
        let isKing = m.boss || m.name.includes('King');
        
        // CONTRAST COLORS:
        // Background is SAND (#fff59d). 
        // We use BLACK (#1a1a1a) and RED/GOLD to stand out.
        let shellColor = isKing ? '#212121' : '#3e2723'; // Black vs Dark Brown
        let trimColor  = isKing ? '#ffd700' : '#8d6e63'; // Gold vs Lighter Brown
        let stingColor = isKing ? '#f50057' : '#d84315'; // Neon Pink vs Orange

        // Legs (Spiky and Dark)
        ctx.strokeStyle = '#000'; 
        ctx.lineWidth = isKing ? 4 : 2;
        ctx.lineCap = 'round';
        
        for(let i=0; i<4; i++) {
            let legMove = Math.sin(Date.now()/150 + i) * 3;
            // Left
            ctx.beginPath(); 
            ctx.moveTo(x+20, y+25-b); 
            ctx.lineTo(x+5, y+20-b+(i*6));  // Knee out
            ctx.lineTo(x-2, y+35-b+(i*6)+legMove); // Foot down
            ctx.stroke();
            // Right
            ctx.beginPath(); 
            ctx.moveTo(x+30, y+25-b); 
            ctx.lineTo(x+45, y+20-b+(i*6)); 
            ctx.lineTo(x+52, y+35-b+(i*6)+legMove); 
            ctx.stroke();
        }

        // Body (Armor Plates)
        ctx.fillStyle = tint || shellColor;
        ctx.strokeStyle = trimColor; ctx.lineWidth = 2;
        
        // Thorax
        ctx.beginPath(); ctx.ellipse(x+25, y+25-b, 14, 16, 0, 0, 6.28); 
        ctx.fill(); ctx.stroke();
        
        // Armor Segment Pattern
        ctx.fillStyle = trimColor;
        ctx.beginPath(); ctx.moveTo(x+25, y+10-b); ctx.lineTo(x+32, y+25-b); ctx.lineTo(x+18, y+25-b); ctx.fill();

        // Claws (Massive and Heavy)
        const drawClaw = (cx, cy, ang) => {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(ang);
            // Arm
            ctx.fillStyle = '#000'; ctx.fillRect(-4, -15, 8, 15);
            // Pincer
            ctx.fillStyle = tint || shellColor;
            ctx.strokeStyle = trimColor; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI, true); 
            ctx.lineTo(-5, 18); ctx.lineTo(0, 8); ctx.lineTo(5, 18); // Sharp tips
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            ctx.restore();
        };
        let sway = Math.sin(Date.now()/300) * 0.3;
        drawClaw(x+5, y+25-b, 0.6 + sway); 
        drawClaw(x+45, y+25-b, -0.6 - sway);

        // Tail (Vertebrae Look)
        ctx.fillStyle = shellColor;
        for(let i=0; i<5; i++) {
            let tx = x+25 + Math.sin(i*0.5)*5;
            let ty = (y+5-b) - (i*6); // Going UP
            ctx.beginPath(); ctx.arc(tx, ty, 6-(i*0.5), 0, 6.28); ctx.fill();
        }

        // Stinger (Glowing)
        ctx.fillStyle = stingColor;
        ctx.shadowColor = stingColor; ctx.shadowBlur = 10;
        ctx.beginPath(); 
        ctx.moveTo(x+25, y-25-b); 
        ctx.lineTo(x+18, y-15-b); 
        ctx.lineTo(x+32, y-15-b); 
        ctx.fill();
        ctx.shadowBlur = 0;
    }






    else if(m.name==='Mummy') {
        // Outline (Dusty)
        ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 1;
        
        // Body (Wrapped)
        ctx.fillStyle = tint || '#e0e0e0'; 
        ctx.fillRect(x+18, y+5-b, 14, 32); 
        
        // Bandage Lines (Stripes)
        ctx.fillStyle = '#bdbdbd';
        for(let i=0; i<6; i++) {
            ctx.fillRect(x+18, y+8-b + (i*5), 14, 1);
        }
        
        // Head (Wrapped)
        ctx.fillStyle = tint || '#eeeeee';
        ctx.fillRect(x+16, y-5-b, 18, 14);
        
        // Eyes (Hollow Dark with Glow)
        ctx.fillStyle = '#000';
        ctx.fillRect(x+18, y-2-b, 14, 4); // Eye slit
        ctx.fillStyle = '#ffeb3b'; // Glowing dots
        ctx.shadowColor='#ffeb3b'; ctx.shadowBlur=5;
        ctx.fillRect(x+20, y-1-b, 2, 2); ctx.fillRect(x+28, y-1-b, 2, 2);
        ctx.shadowBlur=0;
        
        // Arms (Zombie pose)
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(x+10, y+12-b, 8, 4); // Left
        ctx.fillRect(x+32, y+12-b, 8, 4); // Right
    }








   else if(m.name==='Stone Golem') {
        let hover = Math.sin(Date.now()/300) * 2;
        
        // 1. Floating Boulders (Shoulders)
        // They float independent of body to look magical
        ctx.fillStyle = tint || '#78909c'; // Blue Grey Stone
        
        // Left Shoulder
        ctx.fillRect(x+5, y+5-b-hover, 12, 15);
        ctx.strokeStyle = '#37474f'; ctx.lineWidth = 2; ctx.strokeRect(x+5, y+5-b-hover, 12, 15);
        
        // Right Shoulder
        ctx.fillRect(x+33, y+5-b+hover, 12, 15);
        ctx.strokeRect(x+33, y+5-b+hover, 12, 15);

        // 2. Main Torso (Heavy Block)
        ctx.fillStyle = '#546e7a'; 
        ctx.fillRect(x+15, y+10-b, 20, 25);
        
        // 3. Rune Carving (Glowing Chest)
        ctx.fillStyle = '#00e5ff'; // Cyan Rune
        ctx.shadowColor = '#00e5ff'; ctx.shadowBlur = 10;
        ctx.beginPath(); 
        ctx.moveTo(x+25, y+15-b); 
        ctx.lineTo(x+20, y+22-b); ctx.lineTo(x+30, y+22-b); 
        ctx.fill();
        ctx.shadowBlur = 0;

        // 4. Head (Floating slightly above)
        ctx.fillStyle = '#78909c';
        ctx.fillRect(x+20, y-2-b, 10, 10);
        // Eye (Single Cyclops Line)
        ctx.fillStyle = '#ff1744'; 
        ctx.fillRect(x+22, y+2-b, 6, 2);

        // 5. Heavy Fists (Ground dragging)
        ctx.fillStyle = '#37474f';
        ctx.fillRect(x+8, y+25-b-hover, 8, 10); // L
        ctx.fillRect(x+34, y+25-b+hover, 8, 10); // R
    }





   else if(m.name==='Cinder Wolf') {
        // 1. DIRECTION LOGIC (Fixed & Safe)
        // If mob is Left of player, Face Right (1). 
        // If mob is Right of player, Face Left (-1).
        let faceDir = (m.x < S.p.x) ? 1 : -1;
        
        let run = Math.sin(Date.now()/100) * 4;
        let breathe = Math.sin(Date.now()/200) * 1.5;

        ctx.save();
        // A. Move to CENTER of tile (Fixes offset bug)
        ctx.translate(x+25, y+25);
        // B. Flip axis
        ctx.scale(faceDir, 1);

        // --- DRAWING STARTS AT (0,0) ---

        // 2. SHADOW
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(0, 18, 14, 4, 0, 0, 6.28); ctx.fill();

        // 3. BACK LEGS (Darker)
        ctx.fillStyle = '#1a1a1a'; 
        // Hip
        ctx.beginPath(); ctx.arc(-12, 5, 6, 0, 6.28); ctx.fill();
        // Leg
        ctx.beginPath(); 
        ctx.moveTo(-12, 5); ctx.lineTo(-18-run, 15); ctx.lineTo(-14-run, 15); ctx.lineTo(-8, 8); 
        ctx.fill();

        // 4. MAIN BODY (Jagged Obsidian)
        ctx.fillStyle = tint || '#212121'; 
        ctx.beginPath();
        // Chest
        ctx.moveTo(10, 5 + breathe); 
        ctx.lineTo(15, -5 + breathe); // Neck base
        ctx.lineTo(5, -8 + breathe);  // Shoulder
        ctx.lineTo(-5, -5);           // Back
        ctx.lineTo(-15, 0);           // Hip
        ctx.lineTo(-10, 10);          // Flank
        ctx.lineTo(5, 12 + breathe);  // Belly
        ctx.fill();

        // 5. MAGMA RIBS (Glowing Core)
        ctx.strokeStyle = '#ff3d00'; ctx.lineWidth = 2; ctx.lineCap = 'round';
        ctx.shadowColor = '#ff3d00'; ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.moveTo(8, 0 + breathe); ctx.lineTo(4, 5 + breathe);
        ctx.moveTo(2, -2 + breathe); ctx.lineTo(-2, 4 + breathe);
        ctx.moveTo(-4, -2); ctx.lineTo(-8, 3);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // 6. FRONT LEGS
        ctx.fillStyle = '#263238'; 
        ctx.beginPath(); 
        ctx.moveTo(8, 5+breathe); ctx.lineTo(12+run, 18); ctx.lineTo(8+run, 18); ctx.lineTo(2, 8+breathe); 
        ctx.fill();

        // 7. SPIKY MANE (Fire)
        ctx.fillStyle = '#d50000'; 
        ctx.beginPath();
        ctx.moveTo(12, -5 + breathe);
        ctx.lineTo(10, -15 + breathe); ctx.lineTo(6, -8 + breathe);
        ctx.lineTo(0, -18 + breathe);  ctx.lineTo(-2, -6);
        ctx.lineTo(-10, -12);          ctx.lineTo(-8, -2);
        ctx.fill();

        // 8. HEAD (Wolf Profile)
        ctx.fillStyle = '#212121'; 
        ctx.beginPath();
        ctx.moveTo(14, -4 + breathe);
        ctx.lineTo(24, 2 + breathe); // Snout
        ctx.lineTo(22, 8 + breathe); // Jaw
        ctx.lineTo(12, 6 + breathe); // Cheek
        ctx.fill();

        // Ear
        ctx.beginPath(); ctx.moveTo(14, -4 + breathe); ctx.lineTo(12, -12 + breathe); ctx.lineTo(18, -6 + breathe); ctx.fill();

        // 9. EYE (Evil Red)
        ctx.fillStyle = '#ffea00'; 
        ctx.shadowColor = '#f00'; ctx.shadowBlur = 8;
        ctx.beginPath(); ctx.arc(18, 0 + breathe, 2, 0, 6.28); ctx.fill();
        ctx.shadowBlur = 0;

        // 10. TAIL (Wagging)
        let wag = Math.sin(Date.now()/100) * 2;
        ctx.strokeStyle = '#212121'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(-15, 0); ctx.quadraticCurveTo(-25, -5+wag, -22, 5+wag); ctx.stroke();

        ctx.restore();
    }




    // REPLACES THE CHAOS TITAN BLOCK (The Barbarian Design)
    else if(m.name === 'Chaos Titan') {
        let t = Date.now();
        let breath = Math.sin(t / 300) * 1.5;
        let glow = 0.5 + Math.abs(Math.sin(t / 500)) * 0.5; // Pulsing light



// --- NEW: COLOR LOGIC ---
        // If tint exists (Poison/Freeze), use it. Else use Dark Blue-Grey.
        let armorColor = tint || '#37474f'; 

        // 1. LIVING CAPE (Smoke & Fire)
        // Drawn first so it is behind him
        ctx.save();
        ctx.translate(x+25, y+20);
        let capeSway = Math.sin(t/400) * 3;
        
        // Smoke base
        ctx.fillStyle = 'rgba(33, 33, 33, 0.8)';
        ctx.beginPath();
        ctx.moveTo(-15, 0); 
        ctx.quadraticCurveTo(-25 - capeSway, 30, -20 + capeSway, 50); // Left edge
        ctx.lineTo(20 + capeSway, 50); 
        ctx.quadraticCurveTo(25 + capeSway, 30, 15, 0); // Right edge
        ctx.fill();
        
        // Burning edges
        ctx.strokeStyle = '#d50000'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-15, 0); ctx.lineTo(-20 + capeSway, 50);
        ctx.moveTo(15, 0); ctx.lineTo(20 + capeSway, 50);
        ctx.stroke();
        ctx.restore();

        // 2. THE WEAPON ("World Breaker" Greatsword)
        // Resting on right shoulder, pointing up/left
        ctx.save();
        ctx.translate(x+45, y+25+breath); // Shoulder pivot
        ctx.rotate(-0.4); // Angle
        
        // Blade (Massive Slab)
        ctx.fillStyle = '#212121'; // Obsidian
        ctx.beginPath();
        ctx.moveTo(-10, -50); ctx.lineTo(10, -50); // Tip width
        ctx.lineTo(8, 20); ctx.lineTo(-8, 20); // Base
        ctx.lineTo(0, -65); // Sharp Tip
        ctx.fill();
        
        // Magma Crack in Blade
        ctx.strokeStyle = `rgba(255, 61, 0, ${glow})`; 
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(-3, 0); ctx.lineTo(2, -20); ctx.lineTo(0, -45); ctx.stroke();
        
        // Guard & Hilt
        ctx.fillStyle = '#424242'; ctx.fillRect(-12, 15, 24, 6); // Crossguard
        ctx.fillStyle = '#5d4037'; ctx.fillRect(-3, 21, 6, 15); // Handle
        ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(0, 38, 4, 0, 6.28); ctx.fill(); // Pommel
        ctx.restore();

       // 3. LEGS (Heavy Plate Armor)
        // Dark Blue-Grey to contrast floor
        // (armorColor is now defined at the top of the function)
        let trimColor = '#ffd700'; // Gold Trim

        ctx.fillStyle = armorColor; // Uses the dynamic color
        // Left Leg
        ctx.fillRect(x+10, y+35-b, 12, 15);
        // Right Leg
        ctx.fillRect(x+35, y+35-b, 12, 15);
        
        // Boots (Spiked)
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.moveTo(x+8, y+45-b); ctx.lineTo(x+22, y+45-b); ctx.lineTo(x+15, y+52-b); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x+35, y+45-b); ctx.lineTo(x+49, y+45-b); ctx.lineTo(x+42, y+52-b); ctx.fill();

        // 4. ARMORED SKIRT (Tassets)
        // Instead of loincloth, metal plates hanging down
        ctx.fillStyle = '#263238'; // Darker plate
        ctx.beginPath();
        ctx.moveTo(x+15, y+35-b); ctx.lineTo(x+42, y+35-b); // Waist
        ctx.lineTo(x+38, y+48-b+breath); // Bottom R
        ctx.lineTo(x+28, y+42-b+breath); // Center notch
        ctx.lineTo(x+19, y+48-b+breath); // Bottom L
        ctx.fill();
        
        // Gold Trim on Skirt
        ctx.strokeStyle = trimColor; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(x+19, y+48-b+breath); ctx.lineTo(x+15, y+35-b); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x+38, y+48-b+breath); ctx.lineTo(x+42, y+35-b); ctx.stroke();

        // 5. TORSO (Massive V-Shape Armor)
        ctx.fillStyle = armorColor;
        ctx.beginPath();
        ctx.moveTo(x+5, y+10-b+breath);  // L Shoulder
        ctx.lineTo(x+52, y+10-b+breath); // R Shoulder
        ctx.lineTo(x+35, y+38-b);        // R Waist
        ctx.lineTo(x+22, y+38-b);        // L Waist
        ctx.fill();

        // 6. THE CHAOS CORE (Glowing Chest)
        ctx.fillStyle = `rgba(255, 111, 0, ${glow})`; // Pulsing Orange
        ctx.shadowColor = '#ff6f00'; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(x+28.5, y+22-b+breath, 5, 0, 6.28); ctx.fill();
        ctx.shadowBlur = 0;

        // 7. PAULDRONS (Shoulder Spikes)
        ctx.fillStyle = '#111'; // Black spikes
        // Left
        ctx.beginPath(); ctx.moveTo(x+5, y+15-b+breath); ctx.lineTo(x-5, y+5-b+breath); ctx.lineTo(x+15, y+5-b+breath); ctx.fill();
        // Right
        ctx.beginPath(); ctx.moveTo(x+52, y+15-b+breath); ctx.lineTo(x+62, y+5-b+breath); ctx.lineTo(x+42, y+5-b+breath); ctx.fill();

        // 8. ARMS (Gauntlets)
        ctx.fillStyle = armorColor;
        // Left Arm (Fist clenched)
        ctx.fillRect(x-2, y+15-b+breath, 10, 15);
        ctx.fillStyle = '#ffd700'; // Gold Gauntlet
        ctx.fillRect(x-4, y+28-b+breath, 14, 8);
        
        // Right Arm (Raising to hold sword)
        ctx.fillStyle = armorColor;
        ctx.fillRect(x+48, y+15-b+breath, 10, 15);
        ctx.fillStyle = '#ffd700'; // Gold Gauntlet
        ctx.fillRect(x+46, y+25-b+breath, 14, 8);

        // 9. HELMET (Dark Lord Style)
        let headY = y - 2 - b + breath;
        ctx.fillStyle = armorColor; // <--- CHANGED to use dynamic color
        ctx.fillRect(x+20, headY, 17, 16);
        
        // Crown Spikes
        ctx.beginPath(); 
        ctx.moveTo(x+20, headY); ctx.lineTo(x+18, headY-8); ctx.lineTo(x+24, headY); 
        ctx.moveTo(x+37, headY); ctx.lineTo(x+39, headY-8); ctx.lineTo(x+33, headY);
        ctx.fill();

        // T-VISOR (Glowing Face)
        ctx.fillStyle = '#ff1744'; // Red Light
        ctx.shadowColor = '#f00'; ctx.shadowBlur = 10;
        ctx.fillRect(x+22, headY+6, 13, 2); // Horizontal
        ctx.fillRect(x+27.5, headY+6, 2, 6); // Vertical
        ctx.shadowBlur = 0;
    }





    else if(m.name.includes('Skeleton')) {
        // 1. Legs (Bone White)
        ctx.fillStyle = tint || '#f5f5f5'; 
        ctx.fillRect(x+18, y+25-b, 4, 12); // L Leg
        ctx.fillRect(x+28, y+25-b, 4, 12); // R Leg
        
        // 2. Pelvis
        ctx.fillRect(x+18, y+22-b, 14, 4);

        // 3. Spine
        ctx.fillRect(x+23, y+10-b, 4, 12);

        // 4. Ribcage (Horizontal Lines)
        ctx.strokeStyle = tint || '#f5f5f5';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x+16, y+12-b); ctx.lineTo(x+34, y+12-b); // Top Rib
        ctx.moveTo(x+18, y+16-b); ctx.lineTo(x+32, y+16-b); // Mid Rib
        ctx.moveTo(x+20, y+20-b); ctx.lineTo(x+30, y+20-b); // Bottom Rib
        ctx.stroke();

        // 5. Skull (Detailed)
        ctx.fillStyle = tint || '#f5f5f5';
        ctx.beginPath(); 
        ctx.arc(x+25, y+2-b, 9, 0, Math.PI*2); // Cranium
        ctx.fill();
        ctx.fillRect(x+21, y+6-b, 8, 5); // Jaw area

        // Eyes (Hollow)
        ctx.fillStyle = '#212121';
        ctx.beginPath(); ctx.arc(x+22, y+2-b, 2.5, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(x+28, y+2-b, 2.5, 0, 6.28); ctx.fill();
        
        // 6. Arms & Sword
        ctx.fillStyle = '#f5f5f5';
        // Left Arm (Holding Sword)
        ctx.save();
        ctx.translate(x+12, y+10-b);
        ctx.rotate(-0.5); // Raise arm
        ctx.fillRect(0, 0, 3, 12);
        
        // Sword
        ctx.translate(0, 10);
        ctx.rotate(1.5); // Point forward
        ctx.fillStyle = '#90a4ae'; // Steel
        ctx.fillRect(0, -15, 3, 20); // Blade
        ctx.fillStyle = '#5d4037'; // Handle
        ctx.fillRect(0, 5, 3, 5);
        ctx.fillStyle = '#ffd700'; // Hilt
        ctx.fillRect(-3, 3, 9, 2);
        ctx.restore();

        // Right Arm (Hanging)
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(x+35, y+12-b, 3, 10);
    }






    else if(m.name==='Bat') {
        let flap = Math.sin(Date.now()/60) * 8; // Faster flap
        let hover = Math.cos(Date.now()/150) * 3;

        ctx.save();
        ctx.translate(x+25, y+20-b+hover);

        // 1. Wings (Webbed & Scalloped)
        ctx.fillStyle = '#212121'; // Black Wings
        ctx.beginPath();
        // Left Wing
        ctx.moveTo(-5, 0); 
        ctx.quadraticCurveTo(-15, -15+flap, -25, -5+flap); // Top arch
        ctx.quadraticCurveTo(-20, 5+flap, -15, 0+flap); // Scallop 1
        ctx.quadraticCurveTo(-10, 5+flap, -5, 5);      // Scallop 2
        
        // Right Wing
        ctx.moveTo(5, 0); 
        ctx.quadraticCurveTo(15, -15+flap, 25, -5+flap); 
        ctx.quadraticCurveTo(20, 5+flap, 15, 0+flap);
        ctx.quadraticCurveTo(10, 5+flap, 5, 5);
        ctx.fill();

        // 2. Body (Furry Oval)
        ctx.fillStyle = tint || '#424242'; // Dark Grey Body
        ctx.beginPath(); ctx.ellipse(0, 0, 6, 8, 0, 0, 6.28); ctx.fill();

        // 3. Ears (Large & Pointy)
        ctx.fillStyle = '#424242';
        ctx.beginPath(); 
        ctx.moveTo(-4, -6); ctx.lineTo(-6, -12); ctx.lineTo(-2, -7); ctx.fill(); // Left
        ctx.beginPath(); 
        ctx.moveTo(4, -6); ctx.lineTo(6, -12); ctx.lineTo(2, -7); ctx.fill(); // Right

        // 4. Face
        ctx.fillStyle = '#ffff00'; // Glowing Yellow Eyes (Contrast)
        ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 5;
        ctx.fillRect(-3, -2, 2, 2); 
        ctx.fillRect(1, -2, 2, 2);
        ctx.shadowBlur = 0;

        // Fangs
        ctx.fillStyle = '#fff';
        ctx.fillRect(-2, 2, 1, 2); ctx.fillRect(1, 2, 1, 2);

        ctx.restore();
    }






  else if(m.name.includes('Basilisk')) {
         // DIRECTION FIX: 
         // If mob is Left of player (m.x < p.x), face Right (1). 
         // If mob is Right of player, face Left (-1).
         let faceDir = (m.x < S.p.x) ? 1 : -1; 
         
         ctx.save();
         ctx.translate(x+25, y+25); 
         ctx.scale(faceDir, 1); 

         // --- DRAWING RELATIVE TO (0,0) ---
         let sway = Math.sin(Date.now()/250) * 2;

         // 1. Body (Coiled Lizard)
         ctx.fillStyle = tint || '#2e7d32'; // Deep Green
         ctx.beginPath();
         // Tail (Left side of local axis)
         ctx.moveTo(-20, 10);
         ctx.quadraticCurveTo(-10, 15, 0, 5); // Hip
         // Neck S-Curve
         ctx.bezierCurveTo(10, 0, 5, -10, 15+sway, -15); // Head position
         // Neck Thickness
         ctx.lineTo(20+sway, -10); 
         ctx.bezierCurveTo(10, -5, 15, 5, 0, 15); // Belly
         ctx.lineTo(-20, 10);
         ctx.fill();

         // 2. Underbelly (Stripes)
         ctx.strokeStyle = '#cddc39'; ctx.lineWidth = 1;
         ctx.beginPath();
         ctx.moveTo(0, 5); ctx.lineTo(0, 15);
         ctx.moveTo(5, 0); ctx.lineTo(8, 8);
         ctx.moveTo(10, -5); ctx.lineTo(12, 0);
         ctx.stroke();

         // 3. Head & Crest
         ctx.save();
         ctx.translate(18+sway, -12); // Move to Head
         
         // Head
         ctx.fillStyle = '#1b5e20'; 
         ctx.beginPath(); ctx.ellipse(0, 0, 8, 5, 0.2, 0, 6.28); ctx.fill();
         
         // Crest (Spikes)
         ctx.fillStyle = '#f9a825'; 
         ctx.beginPath();
         ctx.moveTo(-4, -4); ctx.lineTo(-6, -10); ctx.lineTo(-2, -5); 
         ctx.lineTo(2, -12); ctx.lineTo(4, -4); 
         ctx.fill();
         
         // Eye
         ctx.fillStyle = '#ffea00'; 
         ctx.beginPath(); ctx.arc(2, -1, 2.5, 0, 6.28); ctx.fill();
         ctx.fillStyle = '#000'; ctx.fillRect(1.5, -2.5, 1, 3); // Slit
         ctx.restore();

         // 4. Legs (Crawling)
         let walk = Math.sin(Date.now()/100) * 3;
         ctx.strokeStyle = '#1b5e20'; ctx.lineWidth = 3; ctx.lineCap = 'round';
         // Front Leg
         ctx.beginPath(); ctx.moveTo(5, 5); ctx.lineTo(10+walk, 15); ctx.stroke();
         // Back Leg
         ctx.beginPath(); ctx.moveTo(-10, 5); ctx.lineTo(-15-walk, 15); ctx.stroke();

         ctx.restore();
    }








    else if(m.name==='Mosquito') {
        let fly = Math.sin(Date.now()/30) * 5; // Very fast vibration
        
        ctx.save();
        ctx.translate(x+25, y+20-b); 

        // 1. WINGS (Angle them back like a dart)
        ctx.fillStyle = 'rgba(200, 240, 255, 0.5)';
        ctx.beginPath();
        // Right Wing (Angled Up)
        ctx.ellipse(5, -10+fly, 4, 12, 0.5, 0, 6.28); 
        // Left Wing (Angled Up)
        ctx.ellipse(-5, -10-fly, 4, 12, -0.5, 0, 6.28); 
        ctx.fill();

        // 2. LEGS (Long & Dangly)
        ctx.strokeStyle = '#212121'; ctx.lineWidth = 1;
        ctx.beginPath();
        // Front
        ctx.moveTo(2, 0); ctx.lineTo(8, 8); ctx.lineTo(6, 15);
        ctx.moveTo(-2, 0); ctx.lineTo(-8, 8); ctx.lineTo(-6, 15);
        // Back
        ctx.moveTo(2, 2); ctx.lineTo(5, 12+fly);
        ctx.moveTo(-2, 2); ctx.lineTo(-5, 12+fly);
        ctx.stroke();

        // 3. BODY (Needle Shape)
        // Abdomen (Red blood sack)
        ctx.fillStyle = tint || '#8d6e63';
        ctx.beginPath(); ctx.ellipse(0, 5, 4, 7, 0, 0, 6.28); ctx.fill();
        // Thorax (Black)
        ctx.fillStyle = '#212121';
        ctx.beginPath(); ctx.arc(0, -2, 4, 0, 6.28); ctx.fill();

        // 4. EYES (Huge Red Bug Eyes)
        ctx.fillStyle = '#d50000'; 
        ctx.beginPath(); ctx.arc(-2, -4, 2.5, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(2, -4, 2.5, 0, 6.28); ctx.fill();

        // 5. PROBOSCIS (The Needle)
        ctx.strokeStyle = '#111'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(0, -2); ctx.lineTo(0, 8); ctx.stroke();

        ctx.restore();
    }








    else if(m.name.includes('Magma')) {
        let flow = Math.sin(Date.now()/200) * 2;
        let sx = x+25, sy = y+25-b;

        // 1. Base Puddle (Spreading)
        ctx.fillStyle = 'rgba(191, 54, 12, 0.6)';
        ctx.beginPath(); ctx.ellipse(sx, sy+15, 18, 6, 0, 0, 6.28); ctx.fill();

        // 2. Rising Column (The Body)
        // Gradient: Hot at bottom, cooling at top
        let grad = ctx.createLinearGradient(sx, sy+15, sx, sy-15);
        grad.addColorStop(0, '#ffeb3b');   // Yellow Base (Heat source)
        grad.addColorStop(0.5, '#ff5722'); // Orange Mid
        grad.addColorStop(1, '#5d4037');   // Brown Top
        
        ctx.fillStyle = tint || grad;
        ctx.beginPath();
        // Gooey Shape
        ctx.moveTo(sx - 15, sy + 10);
        ctx.quadraticCurveTo(sx - 20 - flow, sy, sx - 10, sy - 15); // Left side
        ctx.quadraticCurveTo(sx, sy - 25 + flow, sx + 10, sy - 15); // Top Head
        ctx.quadraticCurveTo(sx + 20 + flow, sy, sx + 15, sy + 10); // Right side
        ctx.fill();

        // 3. Hardened Crust (Floating Armor)
        ctx.fillStyle = '#3e2723'; // Dark Rock
        // Left Shoulder
        ctx.beginPath(); ctx.arc(sx-12, sy-5+flow, 4, 0, 6.28); ctx.fill();
        // Right Shoulder
        ctx.beginPath(); ctx.arc(sx+12, sy-2-flow, 5, 0, 6.28); ctx.fill();
        // Face Mask (Broken)
        ctx.beginPath(); 
        ctx.moveTo(sx-8, sy-10); ctx.lineTo(sx+8, sy-10); 
        ctx.lineTo(sx+5, sy); ctx.lineTo(sx-5, sy); 
        ctx.fill();

        // 4. Eyes (Burning from inside the mask)
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#ff3d00'; ctx.shadowBlur = 10;
        ctx.fillRect(sx-4, sy-8, 2, 2);
        ctx.fillRect(sx+2, sy-8, 2, 2);
        ctx.shadowBlur = 0;

        // 5. Dripping Lava Particles
        if (Math.random() < 0.1) {
             part(sx + (Math.random()-0.5)*20, sy, '#ffeb3b', 1, 3);
        }
    }






    else if(m.name==='Fire Imp') {
        let dance = Math.sin(Date.now()/100) * 3;
        
        // 1. Body (Charred Wood / Coal)
        ctx.fillStyle = tint || '#212121'; 
        ctx.beginPath();
        ctx.moveTo(x+25, y+30-b); 
        ctx.lineTo(x+15, y+15-b); // Hip L
        ctx.lineTo(x+35, y+15-b); // Hip R
        ctx.fill();
        
        // Chest
        ctx.fillRect(x+18, y+5-b, 14, 12);

        // 2. Head (Flame Shape)
        // Core Head
        ctx.fillStyle = '#212121';
        ctx.fillRect(x+20, y-2-b, 10, 10);
        
        // Hair (Living Fire)
        ctx.fillStyle = '#ff5722';
        ctx.beginPath();
        ctx.moveTo(x+20, y-2-b);
        ctx.lineTo(x+15-dance, y-10-b); // Flame L
        ctx.lineTo(x+25, y-5-b);
        ctx.lineTo(x+35+dance, y-10-b); // Flame R
        ctx.lineTo(x+30, y-2-b);
        ctx.fill();

        // 3. Face
        ctx.fillStyle = '#ffd700'; // Yellow Eyes
        ctx.fillRect(x+21, y+1-b, 2, 2); ctx.fillRect(x+27, y+1-b, 2, 2);
        
        // Grin
        ctx.fillStyle = '#d50000';
        ctx.beginPath(); ctx.arc(x+25, y+5-b, 3, 0, Math.PI); ctx.fill();

        // 4. Limbs (Stick-like but hot)
        ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 2;
        // Arms holding fire
        ctx.beginPath(); ctx.moveTo(x+18, y+8-b); ctx.lineTo(x+10, y+5-b+dance); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x+32, y+8-b); ctx.lineTo(x+40, y+5-b-dance); ctx.stroke();
        
        // Fire in hands
        ctx.fillStyle = '#ffeb3b';
        ctx.beginPath(); ctx.arc(x+10, y+5-b+dance, 3, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(x+40, y+5-b-dance, 3, 0, 6.28); ctx.fill();
    }






   else if(m.name.includes('Slime')) {
        let wobble = Math.sin(Date.now()/150)*2;
        let sx = x+25, sy = y+25-b;
        
        // 1. Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath(); ctx.ellipse(sx, sy+12, 16, 5, 0, 0, 6.28); ctx.fill();

        // 2. LIQUID BODY (Gradient instead of flat color)
        // This makes it look round and 3D without a weird core
        let mainC = tint || '#00bcd4'; // Cyan
        let lightC = tint ? '#fff' : '#80deea'; // Lighter Cyan
        
        let grad = ctx.createRadialGradient(sx-5, sy-10, 2, sx, sy, 22);
        grad.addColorStop(0, lightC);   // Highlight spot
        grad.addColorStop(0.3, mainC);  // Main body
        grad.addColorStop(1, 'rgba(0, 151, 167, 0.8)'); // Darker edges
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        // Soft "Bun" shape
        ctx.moveTo(sx - 20 - wobble, sy + 10); 
        ctx.bezierCurveTo(sx - 20, sy - 20, sx - 10, sy - 30 + wobble, sx, sy - 30 + wobble); 
        ctx.bezierCurveTo(sx + 10, sy - 30 + wobble, sx + 20, sy - 20, sx + 20 + wobble, sy + 10);
        ctx.lineTo(sx - 20 - wobble, sy + 10);
        ctx.fill();

        // 3. INTERNAL BUBBLES (Subtle texture)
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        let bubY = Math.sin(Date.now()/200)*3;
        ctx.beginPath(); ctx.arc(sx-10, sy+5-bubY, 3, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(sx+12, sy-5+bubY, 2, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(sx+5, sy+8-bubY, 1.5, 0, 6.28); ctx.fill();

        // 4. FACE (Cute but simple)
        ctx.fillStyle = '#006064'; // Dark Teal Eyes
        ctx.beginPath(); ctx.arc(sx-7, sy-2, 2.5, 0, 6.28); ctx.fill(); 
        ctx.beginPath(); ctx.arc(sx+7, sy-2, 2.5, 0, 6.28); ctx.fill();
        
        // 5. Glossy Reflection (Wet look)
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.beginPath(); ctx.ellipse(sx+8, sy-18+wobble, 3, 6, 0.5, 0, 6.28); ctx.fill();
    }








    else if(m.name==='Goblin') {
        // Body (Hunched)
        ctx.fillStyle = tint || '#558b2f'; // Dark Green
        ctx.beginPath(); ctx.ellipse(x+25, y+20-b, 12, 10, 0, 0, 6.28); ctx.fill();
        
        // Loincloth (Brown Rags)
        ctx.fillStyle = '#5d4037';
        ctx.beginPath(); ctx.moveTo(x+18, y+25-b); ctx.lineTo(x+32, y+25-b); ctx.lineTo(x+25, y+35-b); ctx.fill();

        // Head (Big Ears)
        ctx.fillStyle = tint || '#7cb342'; // Light Green
        ctx.beginPath(); ctx.arc(x+25, y+10-b, 10, 0, 6.28); ctx.fill();
        // Ears
        ctx.beginPath(); ctx.moveTo(x+15, y+10-b); ctx.lineTo(x+5, y+5-b); ctx.lineTo(x+16, y+5-b); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x+35, y+10-b); ctx.lineTo(x+45, y+5-b); ctx.lineTo(x+34, y+5-b); ctx.fill();

        // Face
        drawEyes(x+21, y+8-b); drawEyes(x+26, y+8-b);
        ctx.fillStyle = '#1b5e20'; // Mouth
        ctx.fillRect(x+22, y+14-b, 6, 2);
        
        // Dagger (Weapon)
        ctx.fillStyle = '#bdc3c7'; ctx.strokeStyle = '#2c3e50';
        ctx.beginPath(); ctx.moveTo(x+35, y+20-b); ctx.lineTo(x+45, y+15-b); ctx.lineTo(x+38, y+22-b); ctx.fill(); ctx.stroke();
    }











   // REPLACES THE OLD HYDRA/FROG BLOCK
   // OPTIMIZED HYDRA (Low CPU Cost, Same Angry Look)
    else if(m.name.includes('Hydra')) { 
        let t = Date.now() / 200;
        let breathe = Math.sin(t) * 1.5;

        // 1. SIMPLE COLORS
        let mainCol = tint || '#66bb6a';
        let bellyCol = '#dcedc8'; 
        let spikeCol = '#7e57c2'; 

        // 2. FEET (Simple Circles)
        ctx.fillStyle = mainCol;
        ctx.beginPath(); 
        ctx.arc(x+10, y+35-b, 6, 0, 6.28); 
        ctx.arc(x+40, y+35-b, 6, 0, 6.28); 
        ctx.arc(x+15, y+45-b, 7, 0, 6.28); 
        ctx.arc(x+35, y+45-b, 7, 0, 6.28); 
        ctx.fill();
        
        // Claws (Simple Triangles)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        [x+12, x+42, x+17, x+37].forEach(cx => {
            ctx.moveTo(cx-2, y+48-b); ctx.lineTo(cx, y+52-b); ctx.lineTo(cx+2, y+48-b);
        });
        ctx.fill();

        // 3. BODY (Simple Ovals)
        ctx.fillStyle = mainCol;
        ctx.beginPath(); ctx.ellipse(x+25, y+38-b, 18, 12, 0, 0, 6.28); ctx.fill();
        ctx.fillStyle = bellyCol;
        ctx.beginPath(); ctx.ellipse(x+25, y+40-b, 12, 8, 0, 0, 6.28); ctx.fill();

        // 4. HEADS (Optimized Loop)
        // Hardcoded configs [angle, length, phase]
        let configs = [[-0.6, 22, 0], [0, 28, 2], [0.6, 22, 4]];

        ctx.strokeStyle = mainCol;
        ctx.lineWidth = 9; 
        ctx.lineCap = 'round';

        for(let i=0; i<3; i++) {
            let h = configs[i];
            let sway = Math.sin(t + h[2]) * 2;
            
            let headX = x + 25 + (h[0] * 30) + sway;
            let headY = y + 20 - h[1] - b + breathe;
            let neckBaseX = x + 25 + (h[0] * 8); 
            let neckBaseY = y + 32 - b;

            // A. NECK (Single Stroke - No Spikes/Dashes for speed)
            ctx.beginPath();
            ctx.moveTo(neckBaseX, neckBaseY);
            ctx.quadraticCurveTo(x + 25 + (h[0] * 15), y + 25, headX, headY);
            ctx.stroke();

            // B. HEAD
            ctx.save();
            ctx.translate(headX, headY);
            ctx.rotate(h[0] * 0.5);

            // Frills (Simple Triangles)
            ctx.fillStyle = spikeCol;
            ctx.beginPath(); 
            ctx.moveTo(-5, 0); ctx.lineTo(-10, -5); ctx.lineTo(-5, -5);
            ctx.moveTo(5, 0); ctx.lineTo(10, -5); ctx.lineTo(5, -5);
            ctx.fill();

            // Head Box (Rect)
            ctx.fillStyle = mainCol;
            ctx.fillRect(-7, -7, 14, 11); 
            
            // Snout (Rect)
            ctx.fillStyle = bellyCol;
            ctx.fillRect(-5, -1, 10, 5);

            // Eyes (Simple Circles)
            ctx.fillStyle = '#ffea00'; 
            ctx.beginPath(); 
            ctx.arc(-4, -3, 3, 0, 6.28); 
            ctx.arc(4, -3, 3, 0, 6.28); 
            ctx.fill();

            // Pupils (Rects are faster than ellipses)
            ctx.fillStyle = '#000'; 
            ctx.fillRect(-4.5, -4, 1, 2);
            ctx.fillRect(3.5, -4, 1, 2);

            // Angry Brows (Single Rect covering top of eyes)
            ctx.fillStyle = mainCol;
            ctx.fillRect(-8, -9, 16, 4);

            // Fangs (Simple Path)
            ctx.fillStyle = '#fff';
            ctx.beginPath(); 
            ctx.moveTo(-4, 4); ctx.lineTo(-3, 7); ctx.lineTo(-2, 4); 
            ctx.moveTo(4, 4); ctx.lineTo(3, 7); ctx.lineTo(2, 4); 
            ctx.fill();

            ctx.restore();
        }
    }





// RED DRAGON (Fixed Belly Position + Sparks)
    else if(m.name.includes('Dragon')) {
        let faceDir = (S.p.x > m.x) ? 1 : -1;

        ctx.save(); 
        ctx.translate(x+25, y+25); 
        ctx.scale(faceDir, 1); 
        ctx.translate(-(x+25), -(y+25)); 

        let flap = Math.sin(Date.now() / 150) * 5;

        // Wings
        ctx.fillStyle = '#8b0000'; 
        ctx.beginPath(); ctx.moveTo(x+20, y+20-b); ctx.lineTo(x+5, y-5-b+flap); ctx.lineTo(x+25, y+15-b); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x+30, y+20-b); ctx.lineTo(x+45, y-5-b+flap); ctx.lineTo(x+25, y+15-b); ctx.fill();

        // 1. TAIL (Drawn first so it's behind body)
        ctx.fillStyle = tint || '#c62828';
        ctx.beginPath(); 
        ctx.moveTo(x+25, y+35-b); 
        ctx.quadraticCurveTo(x+15, y+45-b, x+5+flap, y+40-b); 
        ctx.lineTo(x+20, y+35-b); 
        ctx.fill();

        // 2. BODY (Reshaped: Chest sticks out)
        ctx.fillStyle = tint || '#c62828';
        ctx.beginPath();
        ctx.moveTo(x+20, y+15-b);  // Neck Base
        ctx.lineTo(x+36, y+18-b);  // Chest Top (Protrudes right)
        ctx.lineTo(x+36, y+40-b);  // Belly Bottom
        ctx.lineTo(x+15, y+40-b);  // Back Bottom
        ctx.lineTo(x+15, y+20-b);  // Back Top
        ctx.fill();

        // 3. BELLY (Shifted to Front/Right Side)
        ctx.fillStyle = '#ffcc80'; 
        ctx.fillRect(x+28, y+18-b, 8, 22); 

        // Belly Lines (Texture)
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; 
        ctx.fillRect(x+28, y+24-b, 8, 2); 
        ctx.fillRect(x+28, y+30-b, 8, 2); 
        ctx.fillRect(x+28, y+36-b, 8, 2);

        // Head
        ctx.fillStyle = tint || '#c62828';
        ctx.beginPath(); ctx.moveTo(x+25, y+15-b); ctx.lineTo(x+35, y+5-b); ctx.lineTo(x+30, y+20-b); ctx.fill();
        ctx.fillRect(x+30, y+0-b, 15, 12); 
        ctx.fillStyle = '#b71c1c'; ctx.fillRect(x+40, y+4-b, 5, 8); 

        // Horns & Eye
        ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.moveTo(x+32, y+0-b); ctx.lineTo(x+28, y-8-b); ctx.lineTo(x+36, y+0-b); ctx.fill();
        ctx.fillStyle = '#ffeb3b'; ctx.fillRect(x+35, y+3-b, 4, 4);

        // ==========================================
        // ANIMATION: FAKE FIRE SPARKS (Circular + Colors)
        // ==========================================
        if(m.animTimer > 30) {
            for(let i=0; i<5; i++) {
                let sx = x + 45 + (Math.random() * 6); 
                let sy = y + 6 - b + (Math.random() - 0.5) * 8;
                
                let colors = ['#ffffff', '#fff176', '#ff9800', '#ff5722'];
                ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];

                ctx.beginPath();
                ctx.arc(sx, sy, 1.5 + Math.random(), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.restore(); 
    }



   else if(m.name.includes('Yeti') || m.name==='Ice Spirit') {
        
        // === ICE SPIRIT (Floating Crystal) ===
        if(m.name==='Ice Spirit') {
            let t = Date.now()/200;
            // Glow
            ctx.fillStyle = 'rgba(0, 229, 255, 0.3)';
            ctx.beginPath(); ctx.arc(x+25, y+15-b, 22, 0, 6.28); ctx.fill();
            
            // Core Crystal
            ctx.fillStyle = tint || '#e0f7fa'; 
            ctx.strokeStyle = '#00bcd4'; ctx.lineWidth = 2;
            ctx.save(); ctx.translate(x+25, y+15-b); ctx.rotate(Math.sin(t)*0.2); 
            ctx.beginPath();
            ctx.moveTo(0, -15); ctx.lineTo(10, 0); ctx.lineTo(0, 20); ctx.lineTo(-10, 0); ctx.closePath();
            ctx.fill(); ctx.stroke();
            ctx.restore();

            // Shards
            for(let i=0; i<3; i++) {
                let ang = t + (i * 2.09); 
                let rx = (x+25) + Math.cos(ang) * 20;
                let ry = (y+15-b) + Math.sin(ang) * 10; 
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.moveTo(rx, ry-6); ctx.lineTo(rx+5, ry); ctx.lineTo(rx, ry+6); ctx.lineTo(rx-5, ry); ctx.fill();
            }
        }




        
        // === YETI (Gorilla Beast) ===
       // --- [SANDWICH START] ---
        // === YETI (Gorilla Beast) ===
        else { 
            let sway = Math.sin(Date.now()/300) * 2;
            
            // --- ANIMATION CALCS ---
            let rotOffset = 0; // 0 = Down (Idle)
            let holdRock = false;

            if (m.throwAnim > 0) {
                m.throwAnim--; 
                // Smooth Arc: 0 -> 1 -> 0
                let progress = Math.sin((m.throwAnim / 40) * Math.PI);
                
                // Rotate arms UP (Negative radians to swing up)
                rotOffset = -2.8 * progress; 
                
                // Show rock during windup phase
                if(m.throwAnim > 15) holdRock = true;
            }

            // 1. Body Fur (Keep Original)
            ctx.fillStyle = tint || '#546e7a'; 
            ctx.beginPath();
            ctx.arc(x+15, y+15-b, 12, Math.PI, Math.PI*2); // L
            ctx.arc(x+35, y+15-b, 12, Math.PI, Math.PI*2); // R
            ctx.lineTo(x+35, y+42-b); 
            ctx.lineTo(x+15, y+42-b);
            ctx.fill();

            // 2. HELPER: Draw Original Arm Shape, but Pivot at Shoulder
            const drawPivotedArm = (shoulderX, shoulderY, isRight) => {
                ctx.save();
                ctx.translate(shoulderX, shoulderY); // Pivot Point
                
                // Apply Throw Rotation
                let dir = isRight ? -1 : 1; 
                ctx.rotate(rotOffset * dir);

                // --- ORIGINAL ARM OFFSETS ---
                // The arm center was roughly at (x+5, y+28). 
                // Shoulder is at (x+15, y+15).
                // Difference: dx = -10, dy = +13
                let armX = isRight ? 10 : -10;
                let armY = 13;
                
                let fistX = armX; // Fist aligns with arm
                let fistY = 25;   // Below arm

                // Original Tilt (0.2 for Left, -0.2 for Right)
                let baseTilt = isRight ? -0.2 : 0.2;

                // Draw Arm (Original Ellipse)
                ctx.fillStyle = tint || '#546e7a'; 
                ctx.beginPath();
                ctx.ellipse(armX, armY, 8, 15, baseTilt, 0, 6.28); 
                ctx.fill();

                // Draw Fist (Original Circle)
                ctx.fillStyle = '#37474f';
                ctx.beginPath(); 
                ctx.arc(fistX, fistY, 6, 0, 6.28); 
                ctx.fill();

                ctx.restore();
            };

            // 3. DRAW ROCK (Behind arms if holding)
            if(holdRock) {
                ctx.save();
                // Calculate position above head based on rotation
                // Lift rock up relative to rotation
                let lift = Math.abs(rotOffset) * 20; 
                ctx.translate(x+25, y+20-b - lift);
                ctx.rotate((Math.random()-0.5)*0.2); 
                
                ctx.font = "30px sans-serif"; 
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("ü™®", 0, 0); 
                ctx.restore();
            }

            // 4. DRAW ARMS (Using Pivot Helper)
            // Left Shoulder: x+15
            // Right Shoulder: x+35
            // Sway is applied to the pivot point for the idle breathing effect
            drawPivotedArm(x+15+sway, y+15-b, false);
            drawPivotedArm(x+35-sway, y+15-b, true);

            // 5. FACE (Original)
            ctx.fillStyle = '#81d4fa'; // Ice Blue Skin
            ctx.beginPath();
            ctx.moveTo(x+15, y+15-b);
            ctx.bezierCurveTo(x+15, y+30-b, x+35, y+30-b, x+35, y+15-b);
            ctx.bezierCurveTo(x+35, y+8-b, x+15, y+8-b, x+15, y+15-b);
            ctx.fill();

            // Fur Brow
            ctx.fillStyle = '#cfd8dc'; 
            ctx.beginPath(); 
            ctx.moveTo(x+12, y+12-b); 
            ctx.quadraticCurveTo(x+25, y+18-b, x+38, y+12-b); 
            ctx.lineTo(x+38, y+8-b);
            ctx.quadraticCurveTo(x+25, y+5-b, x+12, y+8-b);
            ctx.fill();

            // Glowing Eyes
            ctx.fillStyle = '#d50000';
            ctx.beginPath(); ctx.arc(x+20, y+18-b, 2, 0, 6.28); ctx.fill();
            ctx.beginPath(); ctx.arc(x+30, y+18-b, 2, 0, 6.28); ctx.fill();

            // Fangs
            ctx.fillStyle = '#fff';
            // Open mouth when throwing
            if(m.throwAnim > 10 && m.throwAnim < 30) {
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(x+25, y+25-b, 5, 0, 6.28); ctx.fill();
            } else {
                ctx.beginPath(); ctx.moveTo(x+20, y+22-b); ctx.lineTo(x+22, y+26-b); ctx.lineTo(x+24, y+22-b); ctx.fill();
                ctx.beginPath(); ctx.moveTo(x+26, y+22-b); ctx.lineTo(x+28, y+26-b); ctx.lineTo(x+30, y+22-b); ctx.fill();
            }
        }
// --- [SANDWICH END] ---
    }





    if(m.boss) { 
        ctx.fillStyle='#ffd700'; ctx.font='20px sans'; 
        let crownY = m.name==='Slime King' ? y+10-b : y-15-b; // y+20 -> y+10
        ctx.fillText('üëë', x+18, crownY); 
    }
    ctx.restore();
}







function drawNPC(x, y, n) {
    let b = Math.sin(Date.now()/300)*2;
    ctx.save(); ctx.translate(x+25, y+12); 
    ctx.scale(3.0, 3.0); 
    
    let hash = 0;
    for(let i=0; i<n.name.length; i++) hash = n.name.charCodeAt(i) + ((hash << 5) - hash);
    let hue = Math.abs(hash % 360);
    let clothColor = `hsl(${hue}, 60%, 50%)`;
    let hairColor = `hsl(${hue}, 40%, 30%)`;
	let skinColor = '#f5cba7';


 




if(n.name === "Shummi") {
        // 1. LEGS (Short 5px)
        ctx.fillStyle = '#c5a585'; 
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5);  

        // Cuffs
        ctx.fillStyle = '#d7ccc8'; 
        ctx.fillRect(-3.5, 10, 3, 1);
        ctx.fillRect(0.5, 10, 3, 1);

        // 2. SHOES
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-3.5, 11, 3, 1.5);
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 3. TORSO
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-4.5, -2, 9, 8); 

        // Stripes
        ctx.fillStyle = '#1a237e'; 
        ctx.fillRect(-4.5, -1, 9, 1);
        ctx.fillRect(-4.5, 1, 9, 1);
        ctx.fillRect(-4.5, 3, 9, 1);

        // Belt
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(-4.5, 5, 9, 1);
        ctx.fillStyle = '#ffd700'; 
        ctx.fillRect(-1, 5, 2, 1);

        // 4. ARMS (Ultra-Thin: 1.5px)
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-6, -1, 1.5, 3); 
        ctx.fillRect(4.5, -1, 1.5, 3);
        
        ctx.fillStyle = '#1a237e';
        ctx.fillRect(-6, 0, 1.5, 1);   ctx.fillRect(4.5, 0, 1.5, 1);
        ctx.fillRect(-6, 2, 1.5, 1);   ctx.fillRect(4.5, 2, 1.5, 1);
        
        ctx.fillStyle = '#f5cba7'; 
        ctx.fillRect(-6, 2, 1.5, 3);   // Hands
        ctx.fillRect(4.5, 2, 1.5, 3);

        // 5. HEAD
        ctx.fillStyle = '#f5cba7'; 
        ctx.fillRect(-3, -7, 6, 6);

        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); ctx.fillRect(1, -5, 1, 1);
        ctx.fillStyle = '#bf360c'; 
        ctx.fillRect(-1, -3, 2, 1);

        // 6. HAIR (Refined: Tip Raised 0.5px)
        ctx.fillStyle = '#212121'; 
        ctx.beginPath();
        
        // Left Sideburn
        ctx.moveTo(-4, -2.2);
        ctx.lineTo(-4, -8.2);
        
        // Top Dome
        ctx.quadraticCurveTo(0, -11.2, 4, -8.2);
        
        // Right Sideburn
        ctx.lineTo(4, -2.2);
        ctx.lineTo(3, -2.2);
        ctx.lineTo(3, -7.2);

        // Bangs
        ctx.lineTo(0, -6.2);   
        
        // [FIXED] Tip raised by 0.5px (from -4.2 to -4.7)
        // This makes the bang shorter over the left eye
        ctx.lineTo(-2, -5.2);  
        
        ctx.lineTo(-4, -6.2);  // Connect to Left Side
        
        ctx.fill();
    }




  // --- NOAH (The French Artist) ---
    else if(n.name === "Noah") {
     // 1. LEGS (Dark Trousers)
        ctx.fillStyle = '#1a1a1a'; 
        ctx.fillRect(-4, 5, 3, 5); ctx.fillRect(1, 5, 3, 5);
        ctx.fillStyle = '#000'; // Shoes
        ctx.fillRect(-5, 9, 4, 2); ctx.fillRect(1, 9, 4, 2);

        // 2. TORSO (Striped Shirt)
        ctx.fillStyle = '#fff'; ctx.fillRect(-4, -2, 8, 7); // White Base
        ctx.fillStyle = '#1a237e'; // Blue Stripes
        ctx.fillRect(-4, -1, 8, 1); ctx.fillRect(-4, 1, 8, 1); ctx.fillRect(-4, 3, 8, 1);
        
        // 3. ARMS & PALETTE
        // Left Arm (Holding Palette)
        ctx.fillStyle = '#fff'; ctx.fillRect(-6, -2, 2, 4); 
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(-6, 2, 2, 2); // Hand
        
        // THE PALETTE (Wooden Oval)
        ctx.fillStyle = '#d35400'; 
        ctx.beginPath(); ctx.ellipse(-7, 2, 3, 4, -0.2, 0, Math.PI*2); ctx.fill();
        // Paint Blobs
        ctx.fillStyle = '#e91e63'; ctx.fillRect(-8, 0, 1, 1); // Red
        ctx.fillStyle = '#f1c40f'; ctx.fillRect(-8, 2, 1, 1); // Yellow
        ctx.fillStyle = '#2980b9'; ctx.fillRect(-6, 4, 1, 1); // Blue
        
        // Right Arm (Holding Brush)
        ctx.fillStyle = '#fff'; ctx.fillRect(4, -2, 2, 4); 
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(4, 2, 2, 2);
        ctx.fillStyle = '#a1887f'; ctx.fillRect(7, 1, 1, 4); // Brush Handle
        ctx.fillStyle = '#e91e63'; ctx.fillRect(7, 0, 1, 1); // Red Tip

        // 4. SCARF (Red)
        ctx.fillStyle = '#c0392b'; 
        ctx.fillRect(-3, -2, 6, 2); // Around neck
        ctx.fillRect(2, -1, 2, 4);  // Draping down

        // 5. HEAD
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(-3, -7, 6, 5); // Face
        
        // Hair (No neck stain)
        ctx.fillStyle = '#212121'; 
        ctx.fillRect(-4, -8, 8, 2); // Top Hair (Under Brim)
        ctx.fillRect(-4, -7, 1, 4); // Left Sideburn
        ctx.fillRect(3, -7, 1, 4);  // Right Sideburn
        
        // Eyes (Asian Black Eyes) - FIXED POSITION
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); // Left Eye
        ctx.fillRect(1, -5, 1, 1);  // Right Eye (Moved closer to center to fix "strange" look)

        // Beret (Tilted)
        ctx.fillStyle = '#b71c1c'; 
        ctx.beginPath(); ctx.ellipse(1, -9, 7, 3, 0.3, 0, Math.PI*2); ctx.fill(); // Main Cap
        ctx.fillStyle = '#d32f2f'; // Lighter Top
        ctx.beginPath(); ctx.ellipse(1, -10, 5, 2, 0.3, 0, Math.PI*2); ctx.fill(); 
        ctx.fillStyle = '#111'; ctx.fillRect(0, -11, 2, 2); // Stem
    }


  // --- DORIS (Legendary Educator) ---
    else if(n.name === "Doris") {
        // 1. WINGS (Background Layer)
        ctx.save();
        ctx.translate(0, -2);
        ctx.fillStyle = '#f5f5f5'; ctx.shadowColor='#fff'; ctx.shadowBlur=5;
        // Geometric Feathers
        ctx.fillRect(-14, -6, 10, 2); ctx.fillRect(-12, -4, 8, 2); ctx.fillRect(-8, -2, 4, 2); 
        ctx.fillRect(4, -6, 10, 2);   ctx.fillRect(4, -4, 8, 2);   ctx.fillRect(4, -2, 4, 2);   
        ctx.shadowBlur=0;
        ctx.restore();

        // 2. LEGS & FEET
        ctx.fillStyle = '#ffcc80'; 
        ctx.fillRect(-3, 8, 2, 3); ctx.fillRect(1, 8, 2, 3);  
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-4, 10, 3, 2); ctx.fillRect(1, 10, 3, 2);

        // 3. DRESS (Blue Suit)
        ctx.fillStyle = '#0277bd'; 
        ctx.fillRect(-4, 2, 8, 6); 
        ctx.fillStyle = '#039be5'; 
        ctx.fillRect(-4, -2, 8, 5);
        
        // 4. ARMS
        ctx.fillStyle = '#039be5'; ctx.fillRect(-6, -2, 2, 5); 
        ctx.fillStyle = '#ffe0b2'; ctx.fillRect(-6, 3, 2, 2); 
        ctx.fillStyle = '#039be5'; ctx.fillRect(4, -2, 2, 5);
        ctx.fillStyle = '#ffe0b2'; ctx.fillRect(4, 3, 2, 2); 

        // 5. NECKLACE (Elegant Short Pearls)
        ctx.fillStyle = '#ffffff'; // Pearl White
        // A simple curved string of pearls near the neck
        ctx.fillRect(-3, -2, 1, 1); 
        ctx.fillRect(-2, -1, 1, 1);
        ctx.fillRect(-1, 0, 2, 1); // Center dip
        ctx.fillRect(1, -1, 1, 1);
        ctx.fillRect(2, -2, 1, 1);

       // 6. HEAD & HAIR
        ctx.fillStyle = '#ffe0b2'; ctx.fillRect(-3, -7, 6, 5); // Face
        

// --- ADDED BLUE EYES ---
        ctx.fillStyle = '#1e88e5'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);
        // -----------------------




        // Features
        ctx.fillStyle = '#d84315'; ctx.fillRect(-1, -3, 2, 1); // Smile (Lowered 1px)
        ctx.fillStyle = '#ffccbc'; ctx.fillRect(-3, -5, 1, 1); ctx.fillRect(2, -5, 1, 1); // Cheeks

        // Hair Art

        // Hair Art
        ctx.fillStyle = '#fff176'; 
        ctx.fillRect(-5, -11, 7, 4); // Left Mass 
        ctx.fillRect(2, -10, 3, 3);  // Right Mass 
        ctx.fillRect(-4, -7, 5, 2);  // Bang sweep
        ctx.fillRect(-6, -8, 2, 4);  // Left Curl 
        ctx.fillRect(4, -8, 2, 3);   // Right Curl 

        ctx.fillStyle = '#fbc02d';
        ctx.fillRect(-2, -10, 1, 2); // Part line
        
        ctx.fillStyle = '#b0bec5'; ctx.fillRect(-5, -5, 1, 2); ctx.fillRect(4, -5, 1, 2);
    }



/// --- JINGLE (Refined: Coat Outlines + #6e3e0b Hair) ---
    else if(n.name === "Jingle") {
        // 1. LEGS (Straight-Leg Blue Jeans - Separated)
        ctx.fillStyle = '#1e88e5'; 
        ctx.fillRect(-3.5, 6, 3, 5); // Left Leg
        ctx.fillRect(0.5, 6, 3, 5);  // Right Leg

        // Shoes (White Sneakers)
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. INNER TOP (Black - Visible in center)
        ctx.fillStyle = '#212121'; 
        ctx.fillRect(-2, -2, 4, 8); 

        // 3. COAT (Camel/Beige - Open Front)
        ctx.fillStyle = '#d7ccc8'; // Camel
        
        // Outline Style (Darker Camel)
        ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 0.5;
        
        // Left Panel
        ctx.fillRect(-5, -2, 3, 10); 
        ctx.strokeRect(-5, -2, 3, 10); // Outline
        
        // Right Panel
        ctx.fillRect(2, -2, 3, 10);  
        ctx.strokeRect(2, -2, 3, 10);  // Outline

        // Lapels (Shadow detail)
        ctx.fillStyle = '#bcaaa4'; 
        ctx.fillRect(-2, -2, 1, 4);
        ctx.fillRect(1, -2, 1, 4);

        // 4. ARMS (Coat Sleeves - 1.5px Width)
        ctx.fillStyle = '#d7ccc8'; // Matches Coat
        
        // Left Sleeve (x=-6.5 extends to -5, touches coat)
        ctx.fillRect(-6.5, -1, 1.5, 4); 
        ctx.strokeRect(-6.5, -1, 1.5, 4); // Outline
        
        // Right Sleeve (x=5 touches coat at 5)
        ctx.fillRect(5, -1, 1.5, 4);
        ctx.strokeRect(5, -1, 1.5, 4); // Outline

        // Hands (Skin)
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 3, 1.5, 2); 
        ctx.fillRect(5, 3, 1.5, 2);

        // 5. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);

        // 6. HAIR (Warm Brown #6e3e0b)
        ctx.fillStyle = '#6e3e0b'; 
        ctx.beginPath();
        ctx.moveTo(-4, -9);
        ctx.lineTo(4, -9);
        ctx.lineTo(5, -6); // Volume
        ctx.lineTo(5, -2); // Length
        ctx.lineTo(3, -2);
        ctx.lineTo(3, -7); // Frame face
        ctx.lineTo(-3, -7);
        ctx.lineTo(-3, -2);
        ctx.lineTo(-5, -2);
        ctx.lineTo(-5, -6);
        ctx.fill();
        
        // Top Volume
        ctx.fillRect(-4, -9, 8, 2);

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);
    }






// --- MARY (Green Sporty - Shummi/Cute Proportions) ---
    else if(n.name === "Mary") {
        // 1. LEGS (Short 5px height - Matching Shummi)
        ctx.fillStyle = skinColor; 
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5);

        // 2. SHORTS (Dark Green - Fitted to short legs)
        ctx.fillStyle = '#2e7d32'; // Dark Green
        ctx.fillRect(-3.5, 6, 3.5, 3); 
        ctx.fillRect(0, 6, 3.5, 3);
        
        // White Side Stripes
        ctx.fillStyle = '#fff';
        ctx.fillRect(-3.5, 6, 1, 3);
        ctx.fillRect(2.5, 6, 1, 3);

        // 3. SNEAKERS (Moved up to y=11)
        ctx.fillStyle = '#fff'; // White Socks
        ctx.fillRect(-3.5, 10, 3, 1); ctx.fillRect(0.5, 10, 3, 1);
        ctx.fillStyle = '#81c784'; // Light Green Shoes
        ctx.fillRect(-3.5, 11, 3, 1.5); ctx.fillRect(0.5, 11, 3, 1.5);

        // 4. BODY (Bright Green Sporty Top)
        ctx.fillStyle = '#4caf50'; 
        ctx.fillRect(-4.5, -2, 9, 8);
        
        // White Collar Rim
        ctx.fillStyle = '#fff';
        ctx.fillRect(-2.5, -2, 5, 1);

        // 5. ARMS (Ultra-Thin 1.5px - Matching Shummi)
        ctx.fillStyle = '#4caf50'; // Sleeve
        ctx.fillRect(-6, -1, 1.5, 3); 
        ctx.fillRect(4.5, -1, 1.5, 3);
        
        // Skin Arms
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6, 2, 1.5, 3); 
        ctx.fillRect(4.5, 2, 1.5, 3);

        // 6. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);

        // 7. HAIR (Black Sporty Ponytail)
        ctx.fillStyle = '#313b36'; // Jet Black
        ctx.fillRect(-4, -9, 8, 3); // Top
        ctx.fillRect(-5, -7, 2, 6); // Left Side
        ctx.fillRect(3, -7, 2, 6);  // Right Side
        
        // Ponytail (High and bouncy)
        ctx.beginPath(); 
        ctx.moveTo(4, -8); 
        ctx.quadraticCurveTo(9, -6, 7, 0); 
        ctx.lineTo(5, -2); 
        ctx.fill();

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); ctx.fillRect(1, -5, 1, 1);
    }




// --- SIMON (Refined: Added Brown Hair/Sideburns) ---
    else if(n.name === "Simon") {
        // 1. LEGS
        ctx.fillStyle = '#263238'; 
        ctx.fillRect(-5.5, 5, 5, 5); ctx.fillRect(0.5, 5, 5, 5);
        ctx.fillStyle = '#cfd8dc'; 
        ctx.fillRect(-4, 6, 2, 2); ctx.fillRect(2, 6, 2, 2);

        // 2. BODY
        ctx.fillStyle = '#ffffff'; 
        ctx.beginPath();
        ctx.moveTo(-7, -3); ctx.lineTo(7, -3); 
        ctx.lineTo(8, 5);   ctx.lineTo(-8, 5); 
        ctx.fill();
        
        // Buttons
        ctx.fillStyle = '#bdbdbd';
        ctx.fillRect(-2, -1, 1, 1); ctx.fillRect(1, -1, 1, 1);
        ctx.fillRect(-2, 2, 1, 1);  ctx.fillRect(1, 2, 1, 1);

        // Scarf
        ctx.fillStyle = '#c62828';
        ctx.beginPath(); ctx.moveTo(-3, -3); ctx.lineTo(0, 0); ctx.lineTo(3, -3); ctx.fill();

        // 3. ARMS
        ctx.fillStyle = '#ffffff'; 
        ctx.fillRect(-9, -2, 3, 4); ctx.fillRect(6, -2, 3, 4);
        
        ctx.strokeStyle = '#bdbdbd'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-9, -2, 3, 4); ctx.strokeRect(6, -2, 3, 4);

        ctx.fillStyle = skinColor;
        ctx.fillRect(-9, 2, 3, 2);  ctx.fillRect(6, 2, 3, 2);

        // 4. HEAD
        ctx.fillStyle = skinColor; 
        ctx.beginPath(); ctx.arc(0, -5, 5.5, 0, 6.28); ctx.fill(); 

        // [NEW] Brown Hair (Sideburns)
        ctx.fillStyle = '#5d4037'; 
        ctx.fillRect(-5.5, -7, 2, 4); // Left
        ctx.fillRect(3.5, -7, 2, 4);  // Right
        
        ctx.fillStyle = '#000'; 
        // Eyes (1x1, Position -5)
        ctx.fillRect(-3, -5, 1, 1); 
        ctx.fillRect(2, -5, 1, 1); 
        
        ctx.fillStyle = '#3e2723'; ctx.fillRect(-1.5, -3, 3, 1.5); // Goatee

        // 5. HAT
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 1; 
        ctx.beginPath(); 
        ctx.moveTo(-6, -9); 
        ctx.bezierCurveTo(-8, -14, -4, -15, 0, -14); 
        ctx.bezierCurveTo(4, -15, 8, -14, 6, -9);    
        ctx.fill(); ctx.stroke();
        // Brim
        ctx.fillRect(-5, -9, 10, 3);
    }





    // --- STEVE (Head Chef - Thinner Outline) ---
    else if(n.name === "Steve") {
        // 1. LEGS
        ctx.fillStyle = '#263238'; 
        ctx.fillRect(-4, 6, 3, 5); ctx.fillRect(1, 6, 3, 5);

        // 2. BODY
        ctx.fillStyle = '#ffffff'; 
        ctx.fillRect(-6, -2, 12, 9);
        ctx.fillStyle = '#1a237e'; ctx.fillRect(-5, 4, 10, 4); // Apron
        ctx.fillStyle = '#d32f2f'; ctx.beginPath(); ctx.moveTo(-3, -2); ctx.lineTo(0, 2); ctx.lineTo(3, -2); ctx.fill(); // Scarf

        // Buttons
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, 1, 1, 1); ctx.fillRect(1, 1, 1, 1); 
        ctx.fillRect(-2, 3, 1, 1); ctx.fillRect(1, 3, 1, 1); 

        // 3. ARMS (Thinner Outline)
        ctx.fillStyle = '#ffffff'; 
        ctx.fillRect(-8, -1, 2, 5); ctx.fillRect(6, -1, 2, 5);
        
        // **FIX: Thinner Line (0.5)**
        ctx.strokeStyle = '#bdbdbd'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-8, -1, 2, 5); ctx.strokeRect(6, -1, 2, 5);

        ctx.fillStyle = skinColor;
        ctx.fillRect(-8, 4, 2, 2); ctx.fillRect(6, 4, 2, 2);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-4, -9, 8, 7);
        ctx.fillStyle = '#90a4ae'; ctx.fillRect(-5, -8, 1, 4); ctx.fillRect(4, -8, 1, 4); // Hair
        ctx.fillStyle = '#000'; ctx.fillRect(-3, -7, 1, 1); ctx.fillRect(2, -7, 1, 1); // Eyes
        ctx.fillStyle = '#b0bec5'; ctx.fillRect(-5, -5, 10, 2); // Mustache

        // 5. HAT
        ctx.fillStyle = '#fff'; ctx.strokeStyle = '#bdbdbd'; ctx.lineWidth = 1; // Hat outline stays distinct
        ctx.beginPath(); ctx.arc(0, -14, 6, Math.PI, 0); ctx.lineTo(5, -9); ctx.lineTo(-5, -9); ctx.closePath();
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#fff'; ctx.fillRect(-5, -11, 10, 3);
    }





    // --- NICOLAS (Pilot - Hat Raised 1px) ---
    else if(n.name === "Nicolas") {
        // 1. LEGS (Lengthened)
        ctx.fillStyle = '#1a237e'; 
        ctx.fillRect(-4, 2, 3.5, 8); 
        ctx.fillRect(0.5, 2, 3.5, 8);
        ctx.fillStyle = '#000'; ctx.fillRect(-4.5, 9, 4, 1); ctx.fillRect(0.5, 9, 4, 1);

        // 2. BODY
        ctx.fillStyle = '#1a237e'; ctx.fillRect(-6, -6, 12, 8); 
        ctx.fillStyle = '#ffd700'; // Buttons
        ctx.fillRect(-2, -3, 1, 1); ctx.fillRect(1, -3, 1, 1);
        ctx.fillRect(-2, 0, 1, 1); ctx.fillRect(1, 0, 1, 1);

        // Tie
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(-2, -6); ctx.lineTo(0, -4); ctx.lineTo(2, -6); ctx.fill();
        ctx.fillStyle = '#000'; ctx.fillRect(-0.5, -5, 1, 2);
        // Epaulets
        ctx.fillStyle = '#ffd700'; ctx.fillRect(-7, -6, 2, 1); ctx.fillRect(5, -6, 2, 1);

        // 3. ARMS (Thinner Outline)
        ctx.fillStyle = '#1a237e'; 
        ctx.fillRect(-8, -5, 2, 5); ctx.fillRect(6, -5, 2, 5);
        
        // **FIX: Thinner Line (0.5)**
        ctx.strokeStyle = '#000'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-8, -5, 2, 5); ctx.strokeRect(6, -5, 2, 5);

        ctx.fillStyle = skinColor;
        ctx.fillRect(-8, 0, 2, 2); ctx.fillRect(6, 0, 2, 2);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-4, -12, 8, 6);

        // Aviators
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-4, -10, 3, 2); ctx.fillRect(1, -10, 3, 2);
        ctx.strokeStyle = '#333'; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(-1, -9.5); ctx.lineTo(1, -9.5); ctx.stroke();

        // 5. HAT (MOVED UP 1 PIXEL)
        // Visor: -13 (Was -12)
        ctx.fillStyle = '#000'; ctx.fillRect(-5, -13, 10, 2);
        
        // Cap: -13 (Was -12)
        ctx.fillStyle = '#fff'; 
        ctx.beginPath(); ctx.moveTo(-6, -13); ctx.lineTo(6, -13); 
        ctx.quadraticCurveTo(7, -17, 0, -17); ctx.quadraticCurveTo(-7, -17, -6, -13); ctx.fill();
        
        // Badge
        ctx.fillStyle = '#ffd700'; ctx.fillRect(-1, -16, 2, 2);
    }




// --- ELDER MAN (Refined: Eyes moved 0.5px Left) ---
    else if(n.name === "Elder Man") {
        // 1. ROBES (Shortened & Flared)
        ctx.fillStyle = '#37474f'; // Dark Grey Robe
        ctx.beginPath();
        ctx.moveTo(-5, -2); // Shoulders
        ctx.lineTo(5, -2);
        ctx.lineTo(7, 11);  // Bottom Right
        ctx.lineTo(-7, 11); // Bottom Left
        ctx.fill();

        // Robe Trim
        ctx.fillStyle = '#78909c'; 
        ctx.fillRect(-2, -2, 4, 13); 

        // 2. SHOES
        ctx.fillStyle = '#111';
        ctx.fillRect(-4, 11, 3, 1.5);
        ctx.fillRect(1, 11, 3, 1.5);

        // 3. HEAD
        ctx.fillStyle = skinColor; 
        ctx.fillRect(-3, -7, 6, 6);
        
        // Beard
        ctx.fillStyle = '#eeeeee'; 
        ctx.beginPath(); 
        ctx.moveTo(-3, -3); 
        ctx.lineTo(3, -3); 
        ctx.lineTo(0, 5); 
        ctx.fill();

        // Eyebrows (Original Position)
        ctx.fillStyle = '#eeeeee';
        ctx.fillRect(-3, -6, 2, 1); 
        ctx.fillRect(1, -6, 2, 1);

        // Eyes (Moved 0.5px LEFT)
        ctx.fillStyle = '#000';
        ctx.fillRect(-2.5, -5, 1, 1); // Was -2
        ctx.fillRect(1.5, -5, 1, 1);  // Was 2

        // 4. STAFF
        ctx.strokeStyle = '#6b4e2f'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(7, 11); ctx.lineTo(7, -8); ctx.stroke(); 
        
        // Orb
        ctx.fillStyle = '#00bcd4'; ctx.shadowColor = '#00e5ff'; ctx.shadowBlur = 5;
        ctx.beginPath(); ctx.arc(7, -10, 2, 0, 6.28); ctx.fill();
        ctx.shadowBlur = 0;

        // 5. ARMS
        ctx.fillStyle = '#37474f'; 
        ctx.fillRect(-7, -1, 2, 4); 
        ctx.fillRect(5, -1, 2, 4);

        // Hands
        ctx.fillStyle = skinColor;
        ctx.fillRect(-7, 3, 2, 2); 
        ctx.fillRect(5, 3, 2, 2);
    }






    // --- DAVID (Tall Proportions - Smaller/Neater Collar) ---
    else if(n.name === "David") {
        // 1. LEGS (Tall: Start y=2, Height 8)
        ctx.fillStyle = '#263238'; 
        ctx.fillRect(-3.5, 2, 3, 8); // Left
        ctx.fillRect(0.5, 2, 3, 8);  // Right
        
        // Shoes (y=10)
        ctx.fillStyle = '#3e2723'; 
        ctx.fillRect(-3.5, 10, 3, 1.5); 
        ctx.fillRect(0.5, 10, 3, 1.5);

        // 2. BODY (Higher Torso: y=-6)
        ctx.fillStyle = '#78909c'; // Grey Polo
        ctx.fillRect(-4.5, -6, 9, 8); 
        
        // Micro-Outline
        ctx.strokeStyle = '#546e7a'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-4.5, -6, 9, 8);
        
        // Polo Collar (Resized: Smaller and closer to neck)
        ctx.fillStyle = '#b0bec5'; 
        ctx.beginPath();
        // Left Side
        ctx.moveTo(-1.5, -6);   // Inner Neck
        ctx.lineTo(-3.0, -5.5); // Outer Top (Moved inward)
        ctx.lineTo(-3.0, -4.0); // Outer Bottom
        // V-Neck Point
        ctx.lineTo(0, -3.0);    // Center V
        // Right Side
        ctx.lineTo(3.0, -4.0);  // Outer Bottom 
        ctx.lineTo(3.0, -5.5);  // Outer Top
        ctx.lineTo(1.5, -6);    // Inner Neck
        ctx.fill();

        // Neck Opening (Skin)
        ctx.fillStyle = skinColor;
        ctx.beginPath(); 
        ctx.moveTo(-1.5, -6); 
        ctx.lineTo(0, -3.0); 
        ctx.lineTo(1.5, -6); 
        ctx.fill();

        // 3. ARMS (Higher Shoulders)
        // Sleeves (Start y=-5)
        ctx.fillStyle = '#78909c'; 
        ctx.fillRect(-6.5, -5, 1.5, 3); 
        ctx.strokeRect(-6.5, -5, 1.5, 3); // Outline
        
        ctx.fillRect(5, -5, 1.5, 3);
        ctx.strokeRect(5, -5, 1.5, 3);    // Outline
        
        // Skin Arms (Elongated for tall body)
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, -2, 1.5, 4); 
        ctx.fillRect(5, -2, 1.5, 4);

        // 4. HEAD (Tall: y=-12)
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -12, 6, 6);
        
        // Hair (Dark Brown - Neat)
        ctx.fillStyle = '#4e342e'; 
        ctx.fillRect(-4, -14, 8, 3); // Top
        ctx.fillRect(-4, -11, 1, 2); // Sideburns
        ctx.fillRect(3, -11, 1, 2);

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -10, 1, 1); 
        ctx.fillRect(1, -10, 1, 1);
    }






  // --- GRACE (Refined: Original Hair + Elegant Hat) ---
    else if(n.name === "Grace") {
        // 1. DRESS (Purple Gown)
        let dressGrad = ctx.createLinearGradient(0, -2, 0, 12);
        dressGrad.addColorStop(0, '#8e24aa'); 
        dressGrad.addColorStop(1, '#4a148c'); 
        
        ctx.fillStyle = dressGrad;
        ctx.beginPath();
        ctx.moveTo(-5, -2); 
        ctx.lineTo(5, -2);
        ctx.lineTo(8, 12);  
        ctx.lineTo(-8, 12); 
        ctx.fill();

        // 2. FUR STOLE
        ctx.fillStyle = '#fff'; ctx.shadowColor='#eee'; ctx.shadowBlur=3;
        ctx.beginPath(); 
        ctx.arc(-4, -1, 3, 0, 6.28); 
        ctx.arc(0, 0, 3, 0, 6.28); 
        ctx.arc(4, -1, 3, 0, 6.28);
        ctx.fill(); ctx.shadowBlur=0;

        // 3. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // 4. HAIR (Original Blonde Updo peeking out)
        ctx.fillStyle = '#fdd835'; 
        ctx.fillRect(-4, -7, 1, 4); // Left side
        ctx.fillRect(3, -7, 1, 4);  // Right side
        ctx.fillRect(-4, -8, 8, 2); // Bangs under brim

        // Eyes
        ctx.fillStyle = '#000';
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);

        // 5. HAT (Wide Brimmed Elegant Hat)
        ctx.fillStyle = '#fff'; // White to match Fur Stole
        // Brim
        ctx.beginPath(); ctx.ellipse(0, -9, 8, 2.5, 0, 0, Math.PI*2); ctx.fill();
        // Dome
        ctx.beginPath(); ctx.arc(0, -10, 3.5, Math.PI, 0); ctx.fill();
        // Hat Band (Purple to match dress)
        ctx.fillStyle = '#8e24aa';
        ctx.fillRect(-3.5, -10, 7, 1.5);

        // 6. JEWELRY
        // Necklace
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-2, -1, 1, 1); ctx.fillRect(0, 0, 1, 1); ctx.fillRect(2, -1, 1, 1);
        // Earrings
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(-5, -5, 1, 2); ctx.fillRect(4, -5, 1, 2);

        // 7. ARMS & BAG
        ctx.fillStyle = skinColor;
        ctx.fillRect(-7, 0, 2, 5); 
        ctx.fillRect(5, 0, 2, 5);

        ctx.fillStyle = '#c62828'; 
        ctx.fillRect(6, 5, 3, 3); 
        ctx.strokeStyle = '#ffd700'; ctx.lineWidth=1; 
        ctx.beginPath(); ctx.moveTo(7, 5); ctx.lineTo(7, 3); ctx.lineTo(8, 3); ctx.lineTo(8, 5); ctx.stroke();
    }

  // --- JACK (Refined: Thinner Arms, No Holes, Micro-Outlines) ---
    else if(n.name === "Jack") {
        // 1. LEGS (Short 5px)
        ctx.fillStyle = '#283593'; 
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5);  
        
        // Cuff
        ctx.fillStyle = '#e0e0e0'; 
        ctx.fillRect(-3.5, 10, 3, 1); ctx.fillRect(0.5, 10, 3, 1);

        // Loafers
        ctx.fillStyle = '#3e2723'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. BODY (Jacket over Tee)
        // A. Draw SOLID Jacket Base (Prevents holes)
        ctx.fillStyle = '#c47e33'; 
        ctx.fillRect(-4.5, -2, 9, 8);
        
        // Outline (Tiny)
        ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-4.5, -2, 9, 8);
        
        // B. Inner White T-Shirt (Layered on top)
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-1.5, -2, 3, 8); 

        // C. Jacket Lapels (Angled inwards)
        ctx.fillStyle = '#a86319'; 
        ctx.beginPath(); ctx.moveTo(-1.5, -2); ctx.lineTo(-1.5, 5); ctx.lineTo(-4.5, -2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(1.5, -2);  ctx.lineTo(1.5, 5);  ctx.lineTo(4.5, -2);  ctx.fill();

        // 3. ARMS (Thinner - 1.5px to match Fu Jing)
        ctx.fillStyle = '#c47e33'; 
        // Left Sleeve
        ctx.fillRect(-6.5, -1, 1.5, 3); 
        ctx.strokeRect(-6.5, -1, 1.5, 3); // Outline
        
        // Right Sleeve
        ctx.fillRect(5, -1, 1.5, 3);    
        ctx.strokeRect(5, -1, 1.5, 3);    // Outline
        
        // Skin Hands
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 2, 1.5, 3); 
        ctx.fillRect(5, 2, 1.5, 3);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // 5. HAT (Detailed Fisherman Beanie)
        ctx.fillStyle = '#b0bec5'; 
        ctx.beginPath(); ctx.arc(0, -9, 4.5, Math.PI, 0); ctx.fill(); 
        
        // Ribbing
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(-2, -12, 0.5, 3); ctx.fillRect(0, -12.5, 0.5, 3.5); ctx.fillRect(2, -12, 0.5, 3);

        // Folded Rim
        ctx.fillStyle = '#b0bec5'; ctx.fillRect(-4.5, -9, 9, 2.5);
        
        // Label Patch
        ctx.fillStyle = '#111'; ctx.fillRect(1.5, -8.5, 2, 1.5);

        // Sideburns
        ctx.fillStyle = '#212121'; ctx.fillRect(-4, -7, 1, 2); ctx.fillRect(3, -7, 1, 2);

        // Eyes
        ctx.fillStyle = '#000'; ctx.fillRect(-2, -5, 1, 1); ctx.fillRect(1, -5, 1, 1);
    }

   // --- JOHN (Refined: Arms shifted inward to close gaps) ---
    else if(n.name === "John") {
        // 1. LEGS
        ctx.fillStyle = '#616161'; 
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5);
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. BODY
        ctx.fillStyle = '#212121'; 
        ctx.fillRect(-4.5, -2, 9, 8);
        
        // Outline (Tiny)
        ctx.strokeStyle = '#000'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-4.5, -2, 9, 8);

        // Collar Detail
        ctx.fillStyle = '#424242'; 
        ctx.fillRect(-3, -2, 6, 1); 

        // 3. ARMS (Gap Fixed: Moved inward to touch body exactly)
        ctx.fillStyle = '#212121'; 
        
        // Left Sleeve (x=-6 touches body at -4.5)
        ctx.fillRect(-6, -1, 1.5, 4); 
        ctx.strokeRect(-6, -1, 1.5, 4); 
        
        // Right Sleeve (x=4.5 touches body at 4.5)
        ctx.fillRect(4.5, -1, 1.5, 4);
        ctx.strokeRect(4.5, -1, 1.5, 4);    
        
        // Watch (Adjusted for new arm position)
        ctx.fillStyle = '#cfd8dc'; 
        ctx.fillRect(-6.5, 3, 2.5, 1); 
	ctx.fillRect(4.5, 3, 2.5, 1); 

        // Hands
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6, 4, 1.5, 2); 
        ctx.fillRect(4.5, 4, 1.5, 2);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // 5. HAIR
        ctx.fillStyle = '#3e2723'; 
        ctx.beginPath();
        ctx.moveTo(-4, -6); ctx.lineTo(-4, -8);
        ctx.lineTo(-2, -9.5); ctx.lineTo(0, -10); ctx.lineTo(3, -9);
        ctx.lineTo(4, -8); ctx.lineTo(4, -6);
        ctx.lineTo(3, -7); ctx.lineTo(-3, -7);
        ctx.fill();

        // Loose Strand
        ctx.fillRect(1, -10.5, 1, 1);

        // Eyes
        ctx.fillStyle = '#000'; ctx.fillRect(-2, -5, 1, 1); ctx.fillRect(1, -5, 1, 1);
    }






// --- BIAN BAIN (Refined: Compact Soldier) ---
    else if(n.name === "Bian Bain") {
        // 1. LEGS (Camo Pants - Short 5px)
        ctx.fillStyle = '#33691e'; // Dark Green
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5);
        
        // Camo spots
        ctx.fillStyle = '#558b2f'; 
        ctx.fillRect(-2.5, 7, 1, 1); ctx.fillRect(1.5, 9, 1, 1);

        // Combat Boots
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-4, 11, 4, 1.5); ctx.fillRect(0, 11, 4, 1.5);

        // 2. BODY (Tactical Vest)
        ctx.fillStyle = '#33691e'; ctx.fillRect(-4.5, -2, 9, 8); // Shirt Base
        ctx.fillStyle = '#1b5e20'; ctx.fillRect(-4.5, -1, 9, 5);  // Vest/Armor
        
        // Belt/Pouches
        ctx.fillStyle = '#212121'; ctx.fillRect(-4.5, 5, 9, 1); 
        ctx.fillStyle = '#9e9d24'; ctx.fillRect(-3.5, 5, 2, 2); ctx.fillRect(1.5, 5, 2, 2); 

        // 3. ARMS
        ctx.fillStyle = '#33691e'; 
        ctx.fillRect(-7, -1, 2.5, 3); ctx.fillRect(4.5, -1, 2.5, 3); // Sleeves
        
        ctx.fillStyle = skinColor;
        ctx.fillRect(-7, 2, 2.5, 3); ctx.fillRect(4.5, 2, 2.5, 3); // Hands

        // 4. HEAD (Helmet)
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // Army Helmet
        ctx.fillStyle = '#1b5e20'; 
        ctx.beginPath(); ctx.arc(0, -8, 4.5, Math.PI, 0); ctx.fill(); // Dome
        ctx.fillRect(-4.5, -8, 9, 2); // Rim
        
        // Chinstrap
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-3, -1, 6, 1);

        // Eyes (Visible under rim)
        ctx.fillStyle = '#000';
        ctx.fillRect(-2, -5, 1, 1); ctx.fillRect(1, -5, 1, 1);
    }

  // --- FU JING (Refined: Clearer Number 10) ---
    else if(n.name === "Fu Jing") {
        // 1. LEGS (Black Leggings)
        ctx.fillStyle = '#212121'; 
        ctx.fillRect(-3, 6, 2.5, 5); 
        ctx.fillRect(0.5, 6, 2.5, 5);

        // 2. SHORTS (Layered Over)
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-3.5, 6, 3.5, 3); 
        ctx.fillRect(0, 6, 3.5, 3);

        // Sport Shoes
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); ctx.fillRect(0.5, 11, 3, 1.5);

        // 3. BODY (Argentina Jersey)
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-4.5, -2, 9, 8);
        
        // Stripes (Vertical)
        ctx.fillStyle = '#4fc3f7'; 
        ctx.fillRect(-3, -2, 2, 8); 
        ctx.fillRect(1, -2, 2, 8);

        // NUMBER 10 (Refined Pixel Art)
        ctx.fillStyle = '#111';
        // The "1"
        ctx.fillRect(-2, 1, 1, 4); // Vertical
        ctx.fillRect(-3, 1, 1, 1); // Serif
        // The "0"
        ctx.fillRect(1, 1, 2, 4);  // Base block
        ctx.fillStyle = '#4fc3f7'; // Middle hole (Jersey color)
        ctx.fillRect(1.5, 2, 1, 2); 

        // 4. ARMS (Thinner - 1.5px width)
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-6.5, -1, 1.5, 3); // Left Sleeve
        ctx.fillRect(5, -1, 1.5, 3);    // Right Sleeve
        
        // Trim
        ctx.fillStyle = '#4fc3f7';
        ctx.fillRect(-6.5, 1, 1.5, 1); 
        ctx.fillRect(5, 1, 1.5, 1);

        // Hands (Thinner)
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 2, 1.5, 3); 
        ctx.fillRect(5, 2, 1.5, 3);

        // 5. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // Hair (Short Sporty)
       ctx.fillStyle = '#424242';
        ctx.fillRect(-4, -9, 8, 3); 
        ctx.fillRect(-4, -6, 1, 2); ctx.fillRect(3, -6, 1, 2);

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); ctx.fillRect(1, -5, 1, 1);
    }

    // --- TOMO CHIU (Refined: Stout, Muted Colors) ---
    else if(n.name === "Tomo Chiu") {
        // 1. LEGS (Short & Baggy)
        // Muted Faded Denim
        ctx.fillStyle = '#546e7a'; 
        ctx.fillRect(-3.5, 8, 3, 3); // Starts lower (y=8), very short
        ctx.fillRect(0.5, 8, 3, 3);
        
        // High Top Sneakers (Chunky)
        ctx.fillStyle = '#eceff1'; 
        ctx.fillRect(-4, 11, 3.5, 2); ctx.fillRect(0.5, 11, 3.5, 2);
        ctx.fillStyle = '#263238'; // Dark detail
        ctx.fillRect(-3, 11, 1.5, 1.5); ctx.fillRect(1.5, 11, 1.5, 1.5);

        // 2. BODY (Wide Hoodie - Muted Slate Grey)
        ctx.fillStyle = '#37474f'; 
        ctx.fillRect(-5, -1, 10, 9); // Wide torso
        
        // Kangaroo Pocket (Slightly darker)
        ctx.fillStyle = '#263238'; 
        ctx.beginPath(); 
        ctx.moveTo(-3, 8); ctx.lineTo(3, 8); 
        ctx.lineTo(4, 5); ctx.lineTo(-4, 5); 
        ctx.fill();

        // 3. BLING (Gold Chain - Adjusted position)
        ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.arc(0, -2, 3, 0, Math.PI); ctx.stroke();

        // 4. ARMS (Tucked/Short)
        ctx.fillStyle = '#37474f'; // Matches Hoodie
        ctx.fillRect(-7.5, 0, 2.5, 5); // Sleeves
        ctx.fillRect(5, 0, 2.5, 5);
        
        // Hands
        ctx.fillStyle = skinColor;
        ctx.fillRect(-7.5, 5, 2.5, 2); ctx.fillRect(5, 5, 2.5, 2);

        // 5. HEAD
        ctx.fillStyle = skinColor; 
        ctx.beginPath(); ctx.arc(0, -5, 4.5, 0, 6.28); ctx.fill(); 
        
        // Eyes
        ctx.fillStyle = '#111';
        ctx.fillRect(-2, -5, 1, 1); ctx.fillRect(1, -5, 1, 1);
        
        // Stubble (Goatee)
        ctx.fillStyle = '#333'; 
        ctx.fillRect(-1, -2, 2, 1);

        // 6. HAT (Backwards Snapback - Matching Grey)
        ctx.fillStyle = '#212121'; // Dark Grey Cap
        ctx.beginPath(); ctx.arc(0, -8, 4.5, Math.PI, 0); ctx.fill(); // Dome
        ctx.fillRect(-4.5, -8, 9, 2); // Rim
        
        // Snap (Backwards strap - Red accent)
        ctx.fillStyle = '#d32f2f';
        ctx.fillRect(-2, -7, 4, 1); 
    }








// --- MARK (Asian Dad - Brick Red, Fixed Hole, SMALLER Baby) ---
    else if(n.name === "Mark") {
        // 1. LEGS (Compact 5px height)
        ctx.fillStyle = '#1565c0'; // Denim Blue
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5); 
        
        // Cuffs
        ctx.fillStyle = '#cfd8dc'; 
        ctx.fillRect(-3.5, 10, 3, 1); 
        ctx.fillRect(0.5, 10, 3, 1); 

        // Shoes
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. BODY (Brick Red)
        ctx.fillStyle = '#c62828'; // Brick Red Base
        ctx.fillRect(-5, -2, 10, 8); // Main Torso
        
        // Right Side Filler (Prevents hole)
        ctx.fillRect(4, -1, 2, 6); 
        
        // Stripes (Dark Maroon)
        ctx.fillStyle = '#7f0000'; 
        ctx.fillRect(-5, 0, 10, 1); 
        ctx.fillRect(-5, 3, 10, 1);

        // 3. BABY BLANKET (Much Smaller Bundle)
        ctx.fillStyle = '#81d4fa'; // Light Cyan
        ctx.beginPath(); 
        // Reduced size for a tiny baby look
        ctx.ellipse(0, 2, 4.2, 2.5, 0.2, 0, Math.PI*2); 
        ctx.fill();

        // 4. ARMS (Holding the bundle)
        // Sleeves
        ctx.fillStyle = '#c62828'; 
        ctx.fillRect(-7, -1, 2, 4); 
        ctx.fillRect(5, -1, 2, 4);
        
        // Forearms (Skin)
        ctx.fillStyle = skinColor;
        ctx.fillRect(-7, 3, 4, 2); // Left arm
        ctx.fillRect(3, 3, 4, 2);  // Right arm

        // 5. BABY HEAD (Upper Layer - Small)
        ctx.fillStyle = '#ffe0b2'; 
        // Radius reduced to 2.0
        ctx.beginPath(); ctx.arc(-3.0, 0.5, 2.0, 0, Math.PI*2); ctx.fill();
        
        // Baby Eyes (Adjusted for tiny head)
        ctx.fillStyle = '#111'; 
        // Upper Eye
        ctx.fillRect(-3.2, -0.5, 0.8, 0.8); 
        // Lower Eye
        ctx.fillRect(-3.8, 1.0, 0.8, 0.8); 

        // 6. MARK'S HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // Hair (Neat Black)
        ctx.fillStyle = '#424242'; 
        ctx.fillRect(-4, -9, 8, 3); 
        ctx.fillRect(-4, -6, 1, 3); ctx.fillRect(3, -6, 1, 3);

        // Mark's Eyes
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);
    }



// --- JUSSI (Finnish Guy - Tall "Nicolas" Proportions) ---
    else if(n.name === "Jussi") {
        // 1. LEGS (Long: Start at y=2, Height 8 - Matches Nicolas)
        ctx.fillStyle = '#263238'; // Dark Grey Trousers
        ctx.fillRect(-3.5, 2, 3, 8); // Left
        ctx.fillRect(0.5, 2, 3, 8);  // Right

        // Shoes (At y=10)
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-3.5, 10, 3, 1.5); 
        ctx.fillRect(0.5, 10, 3, 1.5);

        // 2. BODY (Higher Torso: y=-6 to 2)
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-4.5, -6, 9, 8);
        
        // Finnish Cross (Blue) - Adjusted for new torso height
        ctx.fillStyle = '#0277bd'; 
        ctx.fillRect(-4.5, -3, 9, 2);  // Horizontal (Chest)
        ctx.fillRect(-1.5, -6, 2, 8);  // Vertical (Center-Left)

        // Micro-Outline
        ctx.strokeStyle = '#bdbdbd'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-4.5, -6, 9, 8);

        // 3. ARMS (Longer & Higher - Matches Nicolas)
        ctx.fillStyle = '#fff'; 
        
        // Left Sleeve
        ctx.fillRect(-6.5, -5, 1.5, 5); 
        ctx.strokeRect(-6.5, -5, 1.5, 5); // Outline
        
        // Right Sleeve
        ctx.fillRect(5, -5, 1.5, 5);
        ctx.strokeRect(5, -5, 1.5, 5);    // Outline

        // Hands (Skin)
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 0, 1.5, 2); 
        ctx.fillRect(5, 0, 1.5, 2);

        // 4. HEAD (Higher: Starts at y=-12)
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -12, 6, 6);

        // 5. HAIR (Blonde)
        ctx.fillStyle = '#fdd835'; 
        ctx.fillRect(-4, -14, 8, 3); // Top
        ctx.fillRect(-4, -11, 1, 3); // Side L
        ctx.fillRect(3, -11, 1, 3);  // Side R

        // Eyes
        ctx.fillStyle = '#29b6f6'; 
        ctx.fillRect(-2, -10, 1, 1); 
        ctx.fillRect(1, -10, 1, 1);
    }




// --- SUKIE (Mid-Bob, Brown Glasses, Purple Jacket + Red Tee) ---
    else if(n.name === "Sukie") {
        // 1. LEGS (Classic Blue Jeans)
        ctx.fillStyle = '#1976d2'; 
        ctx.fillRect(-3.5, 6, 3, 5); // Left
        ctx.fillRect(0.5, 6, 3, 5);  // Right

        // Shoes (Grey Sneakers)
        ctx.fillStyle = '#9e9e9e'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. INNER BODY (Brick Red T-Shirt)
        ctx.fillStyle = '#c62828'; // Brick Red
        ctx.fillRect(-2, -2, 4, 8); 

        // 3. JACKET (Light Purple - Open Front)
        ctx.fillStyle = '#d1c4e9'; // Lavender/Light Purple
        
        // Left Panel (Slightly longer than shirt)
        ctx.fillRect(-5, -2, 3, 9); 
        // Right Panel
        ctx.fillRect(2, -2, 3, 9);

        // Micro-Outline (Darker Purple)
        ctx.strokeStyle = '#9575cd'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-5, -2, 3, 9);
        ctx.strokeRect(2, -2, 3, 9);

        // 4. ARMS (Jacket Sleeves - 1.5px Width)
        ctx.fillStyle = '#d1c4e9'; 
        
        // Left Sleeve
        ctx.fillRect(-6.5, -1, 1.5, 4); 
        ctx.strokeRect(-6.5, -1, 1.5, 4); // Outline
        
        // Right Sleeve
        ctx.fillRect(5, -1, 1.5, 4);
        ctx.strokeRect(5, -1, 1.5, 4);    // Outline

        // Hands (Skin)
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 3, 1.5, 2); 
        ctx.fillRect(5, 3, 1.5, 2);

        // 5. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);

        // 6. GLASSES (Brown Frames)
        ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 0.5; // Brown
        // Lenses
        ctx.strokeRect(-2.5, -5, 2, 1.5);
        ctx.strokeRect(0.5, -5, 2, 1.5);
        // Bridge
        ctx.beginPath(); ctx.moveTo(-0.5, -4.5); ctx.lineTo(0.5, -4.5); ctx.stroke();

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);

        // 7. HAIR (Mid-Length Bob - Dark Brown)
        ctx.fillStyle = '#3e2723'; 
        
        // Top Volume
        ctx.fillRect(-4, -9, 8, 2);
        
        // Bob Sides (Extends down to y=-3, covering ears/jaw)
        ctx.fillRect(-5, -7, 2, 5); // Left Side
        ctx.fillRect(3, -7, 2, 5);  // Right Side
        
        // Bangs (Straight across)
        ctx.fillRect(-3, -7, 6, 1.5);
    }







// --- A GAN (Chic Mom - Cute Proportions) ---
    else if(n.name === "A Gan") {
        // 1. LEGS (Short 5px - Denim)
        ctx.fillStyle = '#1565c0'; // Denim Blue
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5);
        
        // Cuffs (Light Blue)
        ctx.fillStyle = '#90caf9'; 
        ctx.fillRect(-3.5, 10, 3, 1); 
        ctx.fillRect(0.5, 10, 3, 1);

        // Sneakers (White)
        ctx.fillStyle = '#fff';
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. BODY (Striped Top)
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-4.5, -2, 9, 8);
        
        // Stripes (Dark Grey lines)
        ctx.fillStyle = '#212121'; 
        ctx.fillRect(-4.5, 0, 9, 1);
        ctx.fillRect(-4.5, 2, 9, 1);
        ctx.fillRect(-4.5, 4, 9, 1);

        // 3. RIGHT ARM (Holding Orange - Thin 1.5px)
        // Sleeve
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(4.5, -1, 1.5, 3);
        ctx.fillStyle = '#212121'; ctx.fillRect(4.5, 1, 1.5, 1); // Stripe on sleeve
        
        // Arm
        ctx.fillStyle = skinColor;
        ctx.fillRect(4.5, 2, 1.5, 3);
        
        // Orange
        ctx.fillStyle = '#ff6d00'; 
        ctx.beginPath(); ctx.arc(5.25, 5.5, 2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#43a047'; ctx.fillRect(5, 4, 1, 1); // Tiny Leaf

        // 4. LEFT ARM & BABY (Tiny Hip Carry)
        // Sleeve
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-6, -1, 1.5, 3);
        ctx.fillStyle = '#212121'; ctx.fillRect(-6, 1, 1.5, 1);

        // Forearm (Hooked under baby)
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6, 2, 1.5, 3); // Down
        ctx.fillRect(-6, 4.5, 4, 1.5); // Across

        // BABY (Tiny Bundle)
        ctx.fillStyle = '#81d4fa'; // Light Blue Blanket
        ctx.beginPath(); ctx.ellipse(-4, 3.5, 3.5, 2.5, -0.4, 0, Math.PI*2); ctx.fill();
        
        // Baby Head
        ctx.fillStyle = '#ffe0b2'; 
        ctx.beginPath(); ctx.arc(-5, 2, 1.8, 0, Math.PI*2); ctx.fill();
        
        // Baby Face (Tiny dots)
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-5.5, 1.5, 0.5, 0.5); 
        ctx.fillRect(-4.5, 1.5, 0.5, 0.5);

        // 5. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // Hair (Dark Brown Bob)
        ctx.fillStyle = '#3e2723'; 
        ctx.fillRect(-4, -9, 8, 3); // Top
        ctx.fillRect(-5, -8, 2, 7); // Left Side
        ctx.fillRect(3, -8, 2, 7);  // Right Side

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);
    }




   // --- JOSH (Hiker/Photographer - Ponytail & Cute Proportions) ---
    else if(n.name === "Josh") {
        // 0. BACKPACK (Brown)
        ctx.fillStyle = '#5d4037'; 
        ctx.fillRect(-5, -3, 10, 8);

        // 1. LEGS (Short 5px)
        ctx.fillStyle = skinColor; 
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5);
        
        // Khaki Shorts
        ctx.fillStyle = '#8d6e63'; 
        ctx.fillRect(-3.5, 6, 3.5, 3); 
        ctx.fillRect(0, 6, 3.5, 3);

        // Sneakers
        ctx.fillStyle = '#fff';
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. BODY (Two-Tone Shirt)
        ctx.fillStyle = '#37474f'; // Dark Blue-Grey Body
        ctx.fillRect(-4.5, -2, 9, 8);

        // 3. ARMS (Thin 1.5px)
        ctx.fillStyle = '#78909c'; // Lighter Grey Sleeves
        ctx.fillRect(-6.5, -1, 1.5, 3); 
        ctx.fillRect(5, -1, 1.5, 3);
        
        // Hands
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 2, 1.5, 3); 
        ctx.fillRect(5, 2, 1.5, 3);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // HAIR (Blonde Ponytail Style)
        ctx.fillStyle = '#fdd835'; 
        
        // Top Mass (Swept back)
        ctx.beginPath();
        ctx.moveTo(-4, -7);
        ctx.lineTo(-4, -9); // Left hairline
        ctx.quadraticCurveTo(0, -10, 4, -9); // Top curve
        ctx.lineTo(4, -7); // Right hairline
        ctx.fill();
        
        // The Ponytail (Sweeping out and down)
        ctx.beginPath();
        ctx.moveTo(2, -8); // Start at back right
        ctx.quadraticCurveTo(7, -8, 6, -4); // Curve out and drop down
        ctx.lineTo(4, -4); // Tip thickness
        ctx.quadraticCurveTo(5, -7, 2, -7); // Return to head
        ctx.fill();
        
        // Sideburns (Fade)
        ctx.fillStyle = '#fbc02d'; 
        ctx.fillRect(-4, -7, 1, 2); 
        ctx.fillRect(3, -7, 1, 2);

        // Goatee
        ctx.fillStyle = '#fbc02d'; 
        ctx.fillRect(-1, -2, 2, 1.5);

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);

        // 5. CAMERA (Hanging around neck)
        ctx.fillStyle = '#111'; // Body
        ctx.fillRect(-2, 2, 4, 3);
        ctx.fillStyle = '#cfd8dc'; // Lens ring
        ctx.beginPath(); ctx.arc(0, 3.5, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#111'; // Lens glass
        ctx.beginPath(); ctx.arc(0, 3.5, 0.5, 0, Math.PI*2); ctx.fill();
        
        // Strap
        ctx.strokeStyle = '#263238'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-2, 2); ctx.lineTo(-3, -1); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(2, 2); ctx.lineTo(3, -1); ctx.stroke();
    }

   // --- PAULINE (Sporty/Hiker - Cute Proportions) ---
    else if(n.name === "Pauline") {
        // 0. BACKPACK (Red - Scaled down)
        ctx.fillStyle = '#c62828'; 
        ctx.fillRect(-5, -3, 10, 8); // Slightly smaller to fit compact body

        // 1. LEGS (Short 5px - Black Leggings)
        ctx.fillStyle = '#212121'; 
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5);
        
        // Side Stripe (Cyan)
        ctx.fillStyle = '#4dd0e1'; 
        ctx.fillRect(-3.5, 6, 1, 5); 
        ctx.fillRect(2.5, 6, 1, 5);

        // Sneakers (White)
        ctx.fillStyle = '#fff';
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. BODY (Cyan Vest/Torso)
        ctx.fillStyle = '#00838f'; // Dark Cyan
        ctx.fillRect(-4.5, -2, 9, 8);
        
        // Zipper Line
        ctx.fillStyle = '#006064'; 
        ctx.fillRect(-0.5, -2, 1, 8);

        // 3. ARMS (Thin 1.5px - Long Sleeves)
        ctx.fillStyle = '#4dd0e1'; // Light Cyan Sleeves
        ctx.fillRect(-6, -1, 1.5, 5); // Left
        ctx.fillRect(4.5, -1, 1.5, 5); // Right

        // Hands
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6, 4, 1.5, 2); 
        ctx.fillRect(4.5, 4, 1.5, 2);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // Hair (Blonde Ponytail)
        ctx.fillStyle = '#fff176'; 
        ctx.fillRect(-4, -9, 8, 3); // Top
        ctx.fillRect(-5, -8, 2, 6); // Sides
        
        // Ponytail (Bouncy)
        ctx.beginPath(); 
        ctx.moveTo(4, -8); 
        ctx.quadraticCurveTo(9, -6, 7, 0); 
        ctx.lineTo(5, -2); 
        ctx.fill();

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);
    }





   // --- ANGUS (Fashion/Hoodie - Cute Proportions) ---
    else if(n.name === "Angus") {
        // 1. LEGS (Short 5px - Khaki Cargos)
        ctx.fillStyle = '#d7ccc8'; // Light Beige/Khaki
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5);
        
        // Chunky White Sneakers
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. BODY (Black Hoodie)
        ctx.fillStyle = '#212121'; // Black
        ctx.fillRect(-4.5, -2, 9, 8); 
        
        // Kangaroo Pocket (Dark Grey)
        ctx.fillStyle = '#424242'; 
        ctx.beginPath(); 
        ctx.moveTo(-2.5, 6); ctx.lineTo(2.5, 6); 
        ctx.lineTo(3.5, 3); ctx.lineTo(-3.5, 3); 
        ctx.fill();

        // White Drawstrings
        ctx.fillStyle = '#eee';
        ctx.fillRect(-1.5, 0, 0.5, 3); 
        ctx.fillRect(1, 0, 0.5, 3);

        // 3. ARMS (Thin 1.5px - Long Sleeves)
        ctx.fillStyle = '#212121'; 
        ctx.fillRect(-6.5, -1, 1.5, 5); // Left
        ctx.fillRect(5, -1, 1.5, 5);    // Right
        
        // Hands poking out
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 4, 1.5, 1); 
        ctx.fillRect(5, 4, 1.5, 1);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // HAIR (Light Gray Buzz Cut)
        ctx.fillStyle = '#e0e0e0'; // Very Light Gray
        ctx.fillRect(-3, -9, 6, 2); // Short top cap
        
        // EYES
        ctx.fillStyle = '#111';
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);
    }








// --- FANG (The Reader - Cute Proportions + Eyes) ---
    else if(n.name === "Fang") {
        // 1. LEGS (Short 5px - Smart Trousers)
        ctx.fillStyle = '#455a64'; // Dark Slate Grey
        ctx.fillRect(-3.5, 6, 3, 5); 
        ctx.fillRect(0.5, 6, 3, 5);
        
        // Shoes
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. BODY (Oxford Shirt)
        ctx.fillStyle = '#e3f2fd'; // Pale Blue
        ctx.fillRect(-4.5, -2, 9, 8);
        
        // Button Placket
        ctx.fillStyle = '#bbdefb';
        ctx.fillRect(-0.5, -2, 1, 8);
        
        // White Collar
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.moveTo(-1.5, -2); ctx.lineTo(-3.5, -1); ctx.lineTo(-1.5, 0); ctx.fill();
        ctx.beginPath(); ctx.moveTo(1.5, -2); ctx.lineTo(3.5, -1); ctx.lineTo(1.5, 0); ctx.fill();

        // 3. ARMS & BOOK
        ctx.fillStyle = '#e3f2fd'; // Sleeves
        
        // Left Arm (Down)
        ctx.fillRect(-6.5, -1, 1.5, 4); 
        ctx.fillStyle = skinColor; ctx.fillRect(-6.5, 3, 1.5, 2); // Left Hand

        // Right Arm (Bent up holding book)
        ctx.fillStyle = '#e3f2fd';
        ctx.fillRect(5, -1, 1.5, 3); 
        ctx.fillStyle = skinColor; ctx.fillRect(5, 2, 1.5, 2); // Right Hand

        // THE BOOK (Held in Right Hand - Scaled down)
        ctx.fillStyle = '#5d4037'; // Leather Cover
        ctx.fillRect(3.5, 1, 4, 5);
        ctx.fillStyle = '#fff'; // Pages
        ctx.fillRect(4, 1.5, 3, 4);
        // Text lines
        ctx.fillStyle = '#999';
        ctx.fillRect(4.5, 2.5, 2, 0.5); 
        ctx.fillRect(4.5, 3.5, 2, 0.5);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);

        // Eyes (Added Here)
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);

        // Hair (Neat Side Part)
        ctx.fillStyle = '#424242';
        ctx.fillRect(-4, -9, 8, 3); // Top
        ctx.fillRect(-4, -6, 1, 2); // Side
        ctx.fillRect(3, -6, 1, 2);  // Side

        // GLASSES (Fine Detail)
        ctx.strokeStyle = '#111'; ctx.lineWidth = 0.5;
        // Left Lens
        ctx.strokeRect(-2.5, -5, 2, 1.5);
        // Right Lens
        ctx.strokeRect(0.5, -5, 2, 1.5);
        // Bridge
        ctx.beginPath(); ctx.moveTo(-0.5, -4.5); ctx.lineTo(0.5, -4.5); ctx.stroke();
    }


// --- AVON (B&W Striped Long Sleeve, Long Skirt, Glasses) ---
    else if(n.name === "Avon") {
        // 1. LEGS (Mostly hidden by skirt)
        ctx.fillStyle = skinColor; 
        ctx.fillRect(-3, 6, 2.5, 5); 
        ctx.fillRect(0.5, 6, 2.5, 5);
        
        // Flats (Black)
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. SKIRT (Navy Maxi - High Waisted)
        ctx.fillStyle = '#1a237e'; // Navy
        ctx.beginPath();
        ctx.moveTo(-3.5, 4); // High Waist (Starts at y=4)
        ctx.lineTo(3.5, 4);
        ctx.lineTo(6, 11);   // Hem (Ankle length)
        ctx.lineTo(-6, 11);
        ctx.fill();

        // 3. BODY (B&W Striped Long Sleeve)
        ctx.fillStyle = '#fff'; // White Base
        ctx.fillRect(-4.5, -2, 9, 6); // Tucked into skirt
        
        // Black Horizontal Stripes
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-4.5, -1, 9, 1);
        ctx.fillRect(-4.5, 1, 9, 1);
        ctx.fillRect(-4.5, 3, 9, 1);

        // 4. ARMS (Long Sleeves with Stripes)
        // Left Sleeve
        ctx.fillStyle = '#fff'; ctx.fillRect(-6, -1, 1.5, 5); 
        ctx.fillStyle = '#111'; // Stripes
        ctx.fillRect(-6, -1, 1.5, 1); ctx.fillRect(-6, 1, 1.5, 1); ctx.fillRect(-6, 3, 1.5, 1);

        // Right Sleeve
        ctx.fillStyle = '#fff'; ctx.fillRect(4.5, -1, 1.5, 5);
        ctx.fillStyle = '#111'; // Stripes
        ctx.fillRect(4.5, -1, 1.5, 1); ctx.fillRect(4.5, 1, 1.5, 1); ctx.fillRect(4.5, 3, 1.5, 1);

        // Hands
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6, 4, 1.5, 2); 
        ctx.fillRect(4.5, 4, 1.5, 2);

        // 5. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // Hair (Dark Brown Ponytail)
        ctx.fillStyle = '#4e342e'; 
        ctx.fillRect(-4, -9, 8, 4); 
        // Ponytail
        ctx.beginPath(); ctx.moveTo(4, -6); ctx.quadraticCurveTo(8, -2, 6, 4); ctx.lineTo(4, 2); ctx.fill();

        // GLASSES (Black Wireframes)
        ctx.strokeStyle = '#111'; ctx.lineWidth = 0.5;
        // Lenses
        ctx.strokeRect(-2.5, -5, 2, 1.5);
        ctx.strokeRect(0.5, -5, 2, 1.5);
        // Bridge
        ctx.beginPath(); ctx.moveTo(-0.5, -4.5); ctx.lineTo(0.5, -4.5); ctx.stroke();

        // EYES (Behind glasses)
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);
    }




    // --- SHARON (Coat/Tights - Cute Proportions) ---
    else if(n.name === "Sharon") {
        // 1. LEGS (Short 5px - Dark Tights)
        ctx.fillStyle = '#37474f'; // Dark Grey Tights
        ctx.fillRect(-3, 6, 2.5, 5); 
        ctx.fillRect(0.5, 6, 2.5, 5);
        
        // Boots
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. SKIRT (Charcoal - Short)
        ctx.fillStyle = '#424242'; 
        ctx.fillRect(-4, 5, 8, 3);

        // 3. BODY (Patterned Shirt)
        ctx.fillStyle = '#e0f7fa'; // Light Blue base
        ctx.fillRect(-4, -2, 8, 7);
        // Button Placket
        ctx.fillStyle = '#006064'; 
        ctx.fillRect(-0.5, -2, 1, 7); 
        
        // 4. COAT (Camel - Open Front)
        ctx.fillStyle = '#d7ccc8'; 
        ctx.fillRect(-6, -2, 2, 9); // Left Panel
        ctx.fillRect(4, -2, 2, 9);  // Right Panel

        // 5. ARMS (Thin 1.5px - Coat Sleeves)
        ctx.fillStyle = '#d7ccc8'; 
        ctx.fillRect(-6.5, -1, 1.5, 5); // Left
        ctx.fillRect(5, -1, 1.5, 5);    // Right
        
        // Hands
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 4, 1.5, 2); 
        ctx.fillRect(5, 4, 1.5, 2);

        // 6. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        
        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);

        // Hair (Black Long)
        ctx.fillStyle = '#424242'; 
        ctx.fillRect(-4, -9, 8, 3); // Top
        ctx.fillRect(-5, -6, 2, 8); // Left Side
        ctx.fillRect(3, -6, 2, 8);  // Right Side
    }






// --- DAPHNE (Elegant Pianist - Evening Gown & Sheet Music) ---
    else if(n.name === "Daphne") {
        // 1. LEGS (Mostly hidden by gown)
        ctx.fillStyle = skinColor; 
        ctx.fillRect(-3, 6, 2.5, 5); 
        ctx.fillRect(0.5, 6, 2.5, 5);
        
        // Heels (Black)
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. DRESS (Midnight Blue Evening Gown)
        let dressGrad = ctx.createLinearGradient(0, -2, 0, 12);
        dressGrad.addColorStop(0, '#1a237e'); // Deep Blue top
        dressGrad.addColorStop(1, '#3949ab'); // Slightly lighter hem
        ctx.fillStyle = dressGrad;
        
        ctx.beginPath();
        ctx.moveTo(-4.5, -2); // Top Left (Off shoulder)
        ctx.lineTo(4.5, -2);  // Top Right
        ctx.lineTo(8, 11);    // Flare Bottom Right
        ctx.lineTo(-8, 11);   // Flare Bottom Left
        ctx.fill();

        // Sash (Silver/Light Blue)
        ctx.fillStyle = '#9fa8da'; 
        ctx.fillRect(-4, 4, 8, 2);

        // 3. ARMS (Sleeveless/Skin - Thin 1.5px)
        ctx.fillStyle = skinColor; 
        ctx.fillRect(-6, -1, 1.5, 5); // Left Arm
        ctx.fillRect(4.5, -1, 1.5, 5); // Right Arm

        // 4. SHEET MUSIC (Held in Right Hand)
        ctx.fillStyle = '#fff'; // Paper
        ctx.fillRect(5, 2, 4, 5); 
        // Musical Lines (Tiny details)
        ctx.fillStyle = '#111'; 
        ctx.fillRect(6, 3, 2, 0.5);
        ctx.fillRect(6, 4, 2, 0.5);
        ctx.fillRect(6, 5, 2, 0.5);

        // 5. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);

     

        // 6. HAIR (Elegant Brown Updo - Lighter Chestnut)
        ctx.fillStyle = '#6d4c41'; 
        ctx.fillRect(-4, -9, 8, 3); // Top mass
        ctx.fillRect(-5, -7, 2, 4); // Side curls
        ctx.fillRect(3, -7, 2, 4);
        
        // The Bun (Top Knot)
        ctx.beginPath(); ctx.arc(0, -9.5, 2.5, 0, Math.PI*2); ctx.fill();
    }







// --- PAM (Stylish Elder: Black Bob, Hat, Layers) ---
    else if(n.name === "Pam") {
        // 1. LEGS (Slim Black Trousers)
        ctx.fillStyle = '#212121'; 
        ctx.fillRect(-3.5, 6, 3, 5); // Left
        ctx.fillRect(0.5, 6, 3, 5);  // Right

        // Shoes (Stylish Dark Brown Loafers)
        ctx.fillStyle = '#3e2723'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. INNER TOP (Deep Burgundy)
        ctx.fillStyle = '#880e4f'; 
        ctx.fillRect(-2, -2, 4, 8); 

        // 3. OUTER CARDIGAN (Taupe/Beige - Open Front)
        ctx.fillStyle = '#d7ccc8'; 
        
        // Left Panel (Drapes down)
        ctx.fillRect(-5, -2, 3, 9); 
        // Right Panel
        ctx.fillRect(2, -2, 3, 9);

        // Micro-Outline (Darker Beige)
        ctx.strokeStyle = '#a1887f'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-5, -2, 3, 9);
        ctx.strokeRect(2, -2, 3, 9);

        // 4. NECKLACE (Statement Gold Pendant)
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(-1, -1, 2, 2); 

        // 5. ARMS (Cardigan Sleeves - 1.5px Width)
        ctx.fillStyle = '#d7ccc8'; 
        
        // Left Sleeve
        ctx.fillRect(-6.5, -1, 1.5, 4); 
        ctx.strokeRect(-6.5, -1, 1.5, 4); // Outline
        
        // Right Sleeve
        ctx.fillRect(5, -1, 1.5, 4);
        ctx.strokeRect(5, -1, 1.5, 4);    // Outline

        // Hands (Skin)
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 3, 1.5, 2); 
        ctx.fillRect(5, 3, 1.5, 2);

        // 6. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);

        // 7. HAIR (Dyed Black - Charcoal Grey for visibility)
        ctx.fillStyle = '#424242'; 
        // Side Bob (Visible under hat)
        ctx.fillRect(-5, -7, 2, 4); // Left
        ctx.fillRect(3, -7, 2, 4);  // Right

        // 8. HAT (Wide Brim - Matches Cardigan)
        // Brim
        ctx.fillStyle = '#d7ccc8'; 
        ctx.beginPath(); ctx.ellipse(0, -9, 8, 2.5, 0, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#a1887f'; ctx.lineWidth = 0.5; ctx.stroke(); 

        // Dome
        ctx.beginPath(); ctx.arc(0, -10, 4, Math.PI, 0); ctx.fill();

        // Hat Band (Matches Blouse)
        ctx.fillStyle = '#880e4f'; 
        ctx.fillRect(-4, -10, 8, 1.5);

        // 9. EARRINGS (Gold Dots)
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(-5, -5, 1, 1); 
        ctx.fillRect(4, -5, 1, 1);

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);
    }






// --- BOHAN (Normal Dude: Grey Tee + Jeans + Messy Hair) ---
    else if(n.name === "Bohan") {
        // 1. LEGS (Classic Blue Jeans)
        ctx.fillStyle = '#1565c0'; // Denim
        ctx.fillRect(-3.5, 6, 3, 5); // Left
        ctx.fillRect(0.5, 6, 3, 5);  // Right

        // Shoes (White Sneakers)
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. BODY (Grey T-Shirt)
        ctx.fillStyle = '#78909c'; // Blue-Grey
        ctx.fillRect(-4.5, -2, 9, 8); 
        
        // Micro-Outline
        ctx.strokeStyle = '#546e7a'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-4.5, -2, 9, 8);

        // 3. ARMS (Short Sleeves)
        ctx.fillStyle = '#78909c'; // Sleeve
        ctx.fillRect(-6.5, -1, 1.5, 3); // Left
        ctx.fillRect(5, -1, 1.5, 3);    // Right
        
        // Skin Arms
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 2, 1.5, 3); 
        ctx.fillRect(5, 2, 1.5, 3);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);

        // 5. HAIR (Casual Brown Messy)
        ctx.fillStyle = '#4e342e'; 
        ctx.fillRect(-4, -9, 8, 3); // Top mass
        ctx.fillRect(-4, -6, 1, 2); // Sideburns
        ctx.fillRect(3, -6, 1, 2);

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);
    }

    // --- CORNI (Normal Dude: Green Tee + Khakis + Crew Cut) ---
    else if(n.name === "Corni") {
        // 1. LEGS (Khaki/Beige Chinos)
        ctx.fillStyle = '#8d6e63'; // Khaki Brown
        ctx.fillRect(-3.5, 6, 3, 5); // Left
        ctx.fillRect(0.5, 6, 3, 5);  // Right

        // Shoes (Black)
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-3.5, 11, 3, 1.5); 
        ctx.fillRect(0.5, 11, 3, 1.5);

        // 2. BODY (Dark Green T-Shirt)
        ctx.fillStyle = '#2e7d32'; // Forest Green
        ctx.fillRect(-4.5, -2, 9, 8);
        
        // Micro-Outline
        ctx.strokeStyle = '#1b5e20'; ctx.lineWidth = 0.5;
        ctx.strokeRect(-4.5, -2, 9, 8);

        // 3. ARMS (Short Sleeves)
        ctx.fillStyle = '#2e7d32'; // Sleeve
        ctx.fillRect(-6.5, -1, 1.5, 3); // Left
        ctx.fillRect(5, -1, 1.5, 3);    // Right
        
        // Skin Arms
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6.5, 2, 1.5, 3); 
        ctx.fillRect(5, 2, 1.5, 3);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);

        // 5. HAIR (Crew Cut / Buzz Cut)
        ctx.fillStyle = '#403d3d'; // Black hair
        
        // Top: Short and flat, sits tight on head
        ctx.fillRect(-3, -9, 6, 2); 
        
        // Sides: Fade (Very short, just a tiny bit visible)
        ctx.fillRect(-3.5, -7, 0.5, 1.5); 
        ctx.fillRect(3, -7, 0.5, 1.5);

        // Eyes
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); 
        ctx.fillRect(1, -5, 1, 1);
    }



    else if(n.gender === 'F') {
        // 1. LEGS (Skin) & SHOES (Dark) - ORIGINAL DESIGN
        ctx.fillStyle = skinColor; ctx.fillRect(-3, 8, 2, 3); ctx.fillRect(1, 8, 2, 3);
        ctx.fillStyle = '#444';    ctx.fillRect(-3, 10, 2, 1); ctx.fillRect(1, 10, 2, 1);

        // 2. DRESS (Body + Flared Skirt)
        ctx.fillStyle = clothColor;
        ctx.fillRect(-4, -1, 8, 6); // Top
        ctx.beginPath(); ctx.moveTo(-4, 5); ctx.lineTo(4, 5); ctx.lineTo(6, 9); ctx.lineTo(-6, 9); ctx.fill(); // Skirt

        // 3. ARMS (Skin)
        ctx.fillStyle = skinColor;
        ctx.fillRect(-6, 0, 2, 5); // Left Arm
        ctx.fillRect(4, 0, 2, 5);  // Right Arm
        ctx.fillRect(-6, 5, 2, 1); // Hands
        ctx.fillRect(4, 5, 2, 1);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6); 
        ctx.fillStyle = hairColor; 
        ctx.fillRect(-4, -8, 8, 3); // Top Hair
        ctx.fillRect(-5, -7, 2, 8); // Side L
        ctx.fillRect(3, -7, 2, 8);  // Side R

        // --- EYES (Inside Female Block Only) ---
        ctx.fillStyle='#000'; ctx.fillRect(-2, -5, 1, 1); ctx.fillRect(1, -5, 1, 1);
    } 
    else {
        // 1. LEGS (Pants) & SHOES (Dark) - ORIGINAL DESIGN
        ctx.fillStyle = '#37474f'; 
        ctx.fillRect(-4, 6, 3, 5); ctx.fillRect(1, 6, 3, 5);
        ctx.fillStyle = '#111';    
        ctx.fillRect(-5, 10, 4, 1); ctx.fillRect(1, 10, 4, 1);

        // 2. SHIRT & BELT
        ctx.fillStyle = clothColor;
        ctx.fillRect(-5, -1, 10, 7);
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(-5, 6, 10, 1); // Belt

        // 3. ARMS (Sleeves + Hands)
        ctx.fillStyle = clothColor; ctx.fillRect(-7, -1, 2, 4); ctx.fillRect(5, -1, 2, 4);
        ctx.fillStyle = skinColor;  ctx.fillRect(-7, 3, 2, 3);  ctx.fillRect(5, 3, 2, 3);

        // 4. HEAD
        ctx.fillStyle = skinColor; ctx.fillRect(-3, -7, 6, 6);
        ctx.fillStyle = hairColor; 
        ctx.fillRect(-4, -9, 8, 3); // Top
        ctx.fillRect(-4, -6, 1, 2); // Side L
        ctx.fillRect(3, -6, 1, 2);  // Side R

        // --- EYES (Inside Male Block Only) ---
        ctx.fillStyle='#000'; ctx.fillRect(-2, -5, 1, 1); ctx.fillRect(1, -5, 1, 1);
    }

    ctx.restore();
    
    // --- NAME TAG ---
    ctx.fillStyle='#fff'; ctx.font='bold 16px monospace'; 
    ctx.shadowColor='#000'; ctx.shadowBlur=4; 
    ctx.fillText(n.name, x+5, y-45+b); 
    ctx.shadowBlur=0;
    
  








   // --- QUEST MARKER LOGIC ---
    let q = QUESTS[S.qStep];
    
    // Condition 1: Normal Main Quest
    let isMainQuest = (q && q.type==='talk' && q.target===n.name);
    
    // Condition 2: Epilogue (Boss Dead + Haven't talked yet + Is Noah or Doris)
    let isEpilogue = (S.bossDead && !S.epilogueSeen && (n.name === "Noah" || n.name === "Doris"));

    // Draw the Exclamation Mark if either condition is true
    if(isMainQuest || isEpilogue) {
        ctx.fillStyle='#e74c3c'; 
        ctx.font='bold 34px monospace'; 
        ctx.fillText('!', x+20, y-35+b); 
    }
}



function drawStruct(x, y, e) {
    let w = e.w * TILE, h = e.h * TILE;
    if(e.kind==='Fountain' || e.kind==='Healing Crystal') {
        ctx.fillStyle= e.kind==='Fountain' ? '#3498db' : '#2ecc71';
        ctx.beginPath(); ctx.arc(x+w/2, y+h-40, e.kind==='Fountain'?30:15, 0, 6.28); ctx.fill();
        ctx.fillStyle='#fff'; ctx.font='30px monospace'; ctx.fillText('‚úö', x+w/2-10, y+h-30);
    } 






else if(e.kind==='House' || e.kind==='TuckShop' || e.kind==='FarmHouse' || e.kind==='Church') {

        if(e.kind==='TuckShop') {
            // --- TUCK SHOP (Awning Moved Left) ---

            // 1. Dimensions
            let roofEnd = y + 70;
            let floorY = y + h;
            let centerX = x + w/2;

            // 2. Walls (Wide Base)
            ctx.fillStyle = '#d7ccc8'; 
            ctx.fillRect(x + 5, roofEnd, w - 10, h - 70);
            
            // Base Trim
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(x + 5, floorY - 8, w - 10, 8);

            // 3. STRIPED AWNING (Moved 5px Left -> Starts at x)
            let awnY = roofEnd;
            let stripeW = 12.5;
            let numStripes = (w - 10) / stripeW;
            
            for(let i=0; i<numStripes; i++) {
                ctx.fillStyle = (i%2===0) ? '#c62828' : '#fff'; 
                // Main fabric (Removed "+ 5")
                ctx.fillRect(x + (i*stripeW), awnY, stripeW, 20);
                
                // Scalloped edge (Removed "+ 5")
                ctx.beginPath();
                ctx.arc(x + (i*stripeW) + stripeW/2, awnY + 20, stripeW/2, 0, Math.PI);
                ctx.fill();
            }

            // 4. BIG DISPLAY WINDOW
            let winY = awnY + 25;
            let winH = floorY - winY - 10;
            let winW = 100; 

            ctx.fillStyle = '#81d4fa'; ctx.fillRect(x + 20, winY, winW, winH); 
            ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 4; ctx.strokeRect(x + 20, winY, winW, winH);
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath(); 
            ctx.moveTo(x+20, winY+winH); ctx.lineTo(x+20+40, winY); 
            ctx.lineTo(x+20+70, winY); ctx.lineTo(x+20+30, winY+winH); 
            ctx.fill();

            // 5. ENTRANCE DOOR
            let doorX = x + w - 55;
            let doorW = 40;

            ctx.fillStyle = '#c62828'; ctx.fillRect(doorX, winY, doorW, winH);
            ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 3; ctx.strokeRect(doorX, winY, doorW, winH);
            ctx.fillStyle = '#81d4fa'; ctx.fillRect(doorX + 5, winY + 5, 30, 20);
            ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(doorX + 5, winY + winH/2 + 5, 3, 0, 6.28); ctx.fill();

            // 6. ROOF (Trapezoid Shape)
            ctx.fillStyle = '#37474f'; // Dark Slate
            ctx.beginPath();
            ctx.moveTo(x - 5, roofEnd + 5);       // Bottom Left Overhang
            ctx.lineTo(x + 20, y + 20);           // Top Left Corner
            ctx.lineTo(x + w - 20, y + 20);       // Top Right Corner
            ctx.lineTo(x + w + 5, roofEnd + 5);   // Bottom Right Overhang
            ctx.closePath();
            ctx.fill();

            // 7. SIGNAGE ("TUCK SHOP")
            // Chains
            ctx.fillStyle = '#ffd700'; 
            ctx.fillRect(centerX - 40, y + 20, 2, 25); // Left Chain
            ctx.fillRect(centerX + 40, y + 20, 2, 25); // Right Chain

            // Board
            ctx.fillStyle = '#3e2723'; 
            ctx.fillRect(centerX - 50, y + 45, 100, 25); 
            
            // Text
            ctx.fillStyle = '#fff'; ctx.font = 'bold 16px monospace'; 
            ctx.textAlign = 'center'; ctx.fillText("TUCK SHOP", centerX, y + 62); ctx.textAlign = 'left';
        }






else if(e.kind==='FarmHouse') {




            let lvl = S.farm.houseLevel;
            ctx.fillStyle = '#5d4037'; ctx.fillRect(x+10, y+50, w-20, h-50); 
            ctx.fillStyle = '#c0392b'; 
            ctx.beginPath(); ctx.moveTo(x, y+50); ctx.lineTo(x+w/2, y); ctx.lineTo(x+w, y+50); ctx.fill();
            
            ctx.fillStyle = '#3e2723'; ctx.fillRect(x+w/2-25, y+h-60, 50, 60); 
            if(lvl === 2) {
                ctx.fillStyle = '#8d6e63'; ctx.fillRect(x+w-50, y+60, 40, 40); 
                ctx.fillStyle = '#81d4fa'; ctx.fillRect(x+w-45, y+65, 30, 30);





            }






        // --- FIXED VINTAGE CHURCH ---
        } else if (e.kind === 'Church') {
            const cx = x + w/2;
            const gy = y + h;
            
            // Dimensions
            const wallH = 140; 
            const wallTop = gy - wallH; // The top point of the wall
            const eaveY = wallTop + 40; // Where the roof slope starts

            // 1. STONE FOUNDATION
            ctx.fillStyle = '#546e7a';
            ctx.fillRect(x + 10, gy - 10, w - 20, 10);
            ctx.fillStyle = '#455a64';
            ctx.fillRect(x + 10, gy - 3, w - 20, 3);

            // 2. MAIN FA√áADE (The Fix: Draw shape, not just rect)
            ctx.fillStyle = '#b0bec5'; 
            ctx.beginPath();
            ctx.moveTo(x + 20, gy - 10);      // Bottom Left
            ctx.lineTo(x + 20, eaveY);        // Top Left (Eave height)
            ctx.lineTo(cx, wallTop);          // Peak
            ctx.lineTo(x + w - 20, eaveY);    // Top Right (Eave height)
            ctx.lineTo(x + w - 20, gy - 10);  // Bottom Right
            ctx.fill();

            // 3. TEXTURE: QUOINS (Corner Stones)
            ctx.fillStyle = '#90a4ae'; 
            for(let i = eaveY; i < gy - 20; i += 20) {
                ctx.fillRect(x + 20, i, 15, 8);      // Left
                ctx.fillRect(x + w - 35, i + 10, 15, 8); // Right
            }

            // 4. THE DOOR (1.5 Tiles High)
            const doorW = 60; 
            const doorH = 75;
            const doorX = cx - doorW/2;
            const doorY = gy - 10 - doorH;

            // Door Arch Frame
            ctx.fillStyle = '#78909c';
            ctx.beginPath();
            ctx.arc(cx, doorY, doorW/2 + 6, Math.PI, 0); 
            ctx.fillRect(doorX - 6, doorY, doorW + 12, doorH); 
            ctx.fill();

            // Wooden Doors
            ctx.fillStyle = '#3e2723'; 
            ctx.beginPath(); ctx.arc(cx, doorY, doorW/2, Math.PI, 0); 
            ctx.fillRect(doorX, doorY, doorW, doorH);
            ctx.fill();

            // Hinges
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(cx - 1, doorY - 20, 2, doorH + 20); // Split
            ctx.fillRect(doorX + 5, doorY + 20, 10, 4); 
            ctx.fillRect(doorX + doorW - 15, doorY + 20, 10, 4); 

            // 5. SIDE WINDOWS (Lancet)
            const winY = eaveY + 15;
            ctx.fillStyle = '#37474f'; 
            ctx.beginPath(); ctx.ellipse(x + 45, winY, 6, 20, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(x + w - 45, winY, 6, 20, 0, 0, Math.PI*2); ctx.fill();
            // Glow
            ctx.fillStyle = '#0288d1'; ctx.beginPath(); ctx.ellipse(x + 45, winY+5, 3, 10, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#0288d1'; ctx.beginPath(); ctx.ellipse(x + w - 45, winY+5, 3, 10, 0, 0, Math.PI*2); ctx.fill();

            // 6. ROOF (The Fix: Overhangs correctly now)
            ctx.fillStyle = '#263238'; 
            ctx.beginPath();
            ctx.moveTo(x, eaveY + 10);
            ctx.lineTo(cx, wallTop - 10); // Slight peak overlap
            ctx.lineTo(x + w, eaveY + 10);
            ctx.fill();
            
            // Roof Trim
            ctx.strokeStyle = '#37474f'; ctx.lineWidth = 4; ctx.lineJoin = 'round';
            ctx.beginPath(); ctx.moveTo(x+5, eaveY+10); ctx.lineTo(cx, wallTop-10); ctx.lineTo(x+w-5, eaveY+10); ctx.stroke();

            // 7. BELL TOWER (Sitting on top)
            const towerW = 50;
            const towerBaseY = wallTop - 20;
            const towerTopY = y + 20; 
            
            // Base
            ctx.fillStyle = '#90a4ae'; 
            ctx.fillRect(cx - towerW/2, towerBaseY, towerW, 60);
            
            // Tower Roof
            ctx.fillStyle = '#263238';
            ctx.beginPath();
            ctx.moveTo(cx - towerW/2 - 5, towerBaseY);
            ctx.lineTo(cx, towerTopY);
            ctx.lineTo(cx + towerW/2 + 5, towerBaseY);
            ctx.fill();

            // Vent
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(cx - 10, towerBaseY + 15, 20, 25);
            ctx.fillStyle = '#546e7a'; 
            ctx.fillRect(cx - 10, towerBaseY + 20, 20, 2);
            ctx.fillRect(cx - 10, towerBaseY + 28, 20, 2);

            // 8. ROSE WINDOW (Centered under tower)
            const roseY = eaveY - 10;
            ctx.fillStyle = '#455a64'; ctx.beginPath(); ctx.arc(cx, roseY, 16, 0, 6.28); ctx.fill();
            ctx.fillStyle = '#1565c0'; ctx.beginPath(); ctx.arc(cx, roseY, 12, 0, 6.28); ctx.fill();
            ctx.strokeStyle = '#90a4ae'; ctx.lineWidth = 2; 
            ctx.beginPath(); ctx.moveTo(cx-12, roseY); ctx.lineTo(cx+12, roseY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, roseY-12); ctx.lineTo(cx, roseY+12); ctx.stroke();

            // 9. CROSS
            ctx.fillStyle = '#111'; 
            ctx.fillRect(cx - 2, y, 4, 30);  
            ctx.fillRect(cx - 10, y + 10, 20, 4);
            ctx.fillStyle = '#ffd700'; ctx.fillRect(cx-2, y, 4, 4); // Gold Tip

        } 




else {
        // --- FINAL TUDOR COTTAGE (Big Door, Big Windows) ---

        // 1. Setup Dimensions
        let roofEnd = y + 70; 
        let floorY = y + h;
        let centerX = x + w/2;

        // 2. Walls (Cream Plaster)
        ctx.fillStyle = '#fdf5e6'; 
        ctx.fillRect(x + 15, roofEnd, w - 30, h - 70);

        // 3. Timber Framing (Dark Beams)
        ctx.fillStyle = '#4e342e'; 
        // Vertical Posts
        ctx.fillRect(x + 15, roofEnd, 6, h - 70); // Left
        ctx.fillRect(x + w - 21, roofEnd, 6, h - 70); // Right
        // Horizontal Beams
        ctx.fillRect(x + 15, roofEnd, w - 30, 6); // Top
        ctx.fillRect(x + 15, floorY - 10, w - 30, 6); // Bottom

        // 4. MASSIVE DOOR (Grand Arch)
        // Width: 60px, Height: ~80px
        ctx.fillStyle = '#3e2723'; 
        ctx.beginPath();
        ctx.arc(centerX, floorY - 50, 30, Math.PI, 0); // Top Arch (Radius 30)
        ctx.fillRect(centerX - 30, floorY - 50, 60, 50); // Body
        ctx.fill();
        
        // Door Frame (Thick Stone)
        ctx.strokeStyle = '#757575'; ctx.lineWidth = 5; ctx.stroke();
        
        // Door Details
        ctx.fillStyle = '#1a1a1a'; // Center split
        ctx.fillRect(centerX - 1, floorY - 78, 2, 78); 
        ctx.fillStyle = '#ffd700'; // Knobs
        ctx.beginPath(); ctx.arc(centerX - 8, floorY - 30, 4, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(centerX + 8, floorY - 30, 4, 0, 6.28); ctx.fill();

        // 5. BIGGER & LOWER WINDOWS
        const drawWin = (wx) => {
            let wy = roofEnd + 45; // Moved down significantly
            let ww = 32; // Wider
            let wh = 42; // Taller

            // Frame & Glass
            ctx.fillStyle = '#5d4037'; ctx.fillRect(wx - 3, wy - 3, ww + 6, wh + 6); // Frame
            ctx.fillStyle = '#81d4fa'; ctx.fillRect(wx, wy, ww, wh); // Glass
            
            // Lattice
            ctx.fillStyle = '#5d4037'; 
            ctx.fillRect(wx + ww/2 - 1, wy, 2, wh); // Vert
            ctx.fillRect(wx, wy + wh/2 - 1, ww, 2); // Horiz
            
            // Flower Box
            ctx.fillStyle = '#8d6e63'; ctx.fillRect(wx - 5, wy + wh - 5, ww + 10, 10);
            // Flowers
            ctx.fillStyle = '#4caf50'; ctx.fillRect(wx - 2, wy + wh - 8, ww + 4, 5); // Leaves
            ctx.fillStyle = '#e91e63'; 
            ctx.beginPath(); ctx.arc(wx + 8, wy + wh - 3, 4, 0, 6.28); ctx.fill();
            ctx.beginPath(); ctx.arc(wx + ww - 8, wy + wh - 3, 4, 0, 6.28); ctx.fill();
        };
        // Spaced out to fit the new big door
        drawWin(x + 25);
        drawWin(x + w - 57);

        // 6. ROOF (Clean Triangle with Texture)
        ctx.save(); 
        
        ctx.beginPath();
        ctx.moveTo(x, roofEnd + 5);        // Bottom Left
        ctx.lineTo(centerX, y + 10);       // Peak
        ctx.lineTo(x + w, roofEnd + 5);    // Bottom Right
        ctx.closePath();
        
        ctx.fillStyle = '#5d4037'; ctx.fill(); // Fill Base
        ctx.clip(); // Clip Texture

        // Shingles
        ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;
        for(let i = y; i < roofEnd; i += 8) {
            ctx.beginPath(); ctx.moveTo(x, i); ctx.lineTo(x + w, i); ctx.stroke();
        }
        
        ctx.restore();

        // 7. Chimney & Smoke
        ctx.fillStyle = '#795548'; ctx.fillRect(x + w - 40, y + 25, 12, 30);
        ctx.fillStyle = '#3e2723'; ctx.fillRect(x + w - 42, y + 22, 16, 5); 
        
        let t = Date.now() / 600;
        ctx.fillStyle = 'rgba(220, 220, 220, 0.5)';
        ctx.beginPath(); ctx.arc(x + w - 34 + Math.sin(t)*3, y + 15 - (t*10)%20, 5, 0, 6.28); ctx.fill();
    }





    } else if (e.kind === 'ShippingBin') {
        ctx.fillStyle='#5d4037'; ctx.fillRect(x+5, y+10, 40, 30);
        ctx.fillStyle='#3e2723'; ctx.fillRect(x+10, y+15, 30, 20);
        ctx.fillStyle='#fff'; ctx.font='12px monospace'; ctx.fillText("BIN", x+15, y+30);
    } else if (e.kind === 'Chest') {
        ctx.fillStyle='#f39c12'; ctx.fillRect(x+5, y+15, 40, 30);
        ctx.fillStyle='#d35400'; ctx.fillRect(x+5, y+15, 40, 8); 
        ctx.fillStyle='#000'; ctx.fillRect(x+22, y+25, 6, 8); 
    } else {
        ctx.fillStyle='#444'; ctx.fillRect(x,y,w,h); ctx.strokeStyle='#222'; ctx.lineWidth=3; ctx.strokeRect(x,y,w,h);
    }
}





function drawEnv(x, y, k, e) {  // <--- Check this line
    let px = x, py = y;         // <--- THIS LINE IS CRITICAL. If missing, 'px' error occurs.
    ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth=2;
    
    
    if(k.includes('tree')) { 
        ctx.fillStyle='#5d4037'; ctx.fillRect(px+20, py+35, 10, 15); 
        ctx.fillStyle = k==='tree_f' ? '#145a32' : '#2ecc71'; 
        ctx.beginPath(); ctx.arc(px+25, py+25, 22, 0, 6.28); ctx.fill(); ctx.stroke();
    }
    else if(k==='flower') { ctx.fillStyle='#e91e63'; ctx.beginPath(); ctx.arc(px+25,py+35,4,0,6.28); ctx.fill(); }
    else if(k==='cactus') { ctx.fillStyle='#27ae60'; ctx.fillRect(px+22, py+15, 6, 35); ctx.fillRect(px+12, py+25, 26, 6); }
    else if(k==='ice_crystal') { ctx.fillStyle='#d6eaf8'; ctx.beginPath(); ctx.moveTo(px+10,py+45); ctx.lineTo(px+25,py+10); ctx.lineTo(px+40,py+45); ctx.fill(); }
    











// --- PASTE START ---

    // 1. ROCKS & DEBRIS (Void Shards, Magma Rocks, Rubble)
    else if(k==='rock' || k==='rubble' || k==='column' || k==='magma_rock' || k==='void_shard') {
        if(k==='magma_rock') {
            ctx.fillStyle='#3e2723'; ctx.beginPath(); ctx.arc(px+25, py+40, 10, 0, 6.28); ctx.fill();
            ctx.fillStyle='#ff5722'; ctx.fillRect(px+22, py+35, 6, 10); ctx.fillRect(px+18, py+38, 14, 4);
        } else if(k==='void_shard') {
            ctx.fillStyle='#9c27b0'; ctx.beginPath(); ctx.moveTo(px+25, py+40); ctx.lineTo(px+15, py+20); ctx.lineTo(px+25, py+5); ctx.lineTo(px+35, py+20); ctx.fill();
        } else {
            ctx.fillStyle='#7f8c8d'; ctx.beginPath(); ctx.arc(px+25,py+40,8,0,6.28); ctx.fill(); 
        }
    }

    // 2. DYNAMIC MUD (Swamp 2x2, 4x4, etc)
    // 2. DYNAMIC MUD (Swamp)
    else if(k==='big_mud') {
        let width = (e ? e.w : 2) * TILE;
        let height = (e ? e.h : 2) * TILE;
        let cx = px + width/2;
        let cy = py + height/2;
        
        // Flatten the perspective
        let rX = width * 0.45; 
        let rY = height * 0.25; 

        // 1. Shadow/Ground Seepage
        ctx.fillStyle='rgba(40, 30, 20, 0.4)';
        ctx.beginPath(); ctx.ellipse(cx, cy+15, rX+5, rY+5, 0, 0, 6.28); ctx.fill();

        // 2. Main Sludge Pile (Irregular)
        ctx.fillStyle='#3e2723'; 
        ctx.beginPath(); ctx.ellipse(cx, cy+5, rX, rY, 0, 0, 6.28); ctx.fill();
        
        // 3. Liquid Top
        ctx.fillStyle='#4a3b2a'; 
        ctx.beginPath(); ctx.ellipse(cx, cy-2, rX*0.9, rY*0.9, 0, 0, 6.28); ctx.fill();
        
        // 4. Bubbles
        let t = Date.now() / 300;
        let bubbleCount = Math.floor(e ? e.w * 3 : 5);
        ctx.fillStyle = 'rgba(93, 64, 55, 0.9)'; // Lighter mud bubble
        
        for(let i=0; i<bubbleCount; i++) {
            let offset = Math.sin(i*132) * (rX*0.6);
            let yOff = Math.cos(i*44) * (rY*0.5);
            // Throbbing size
            let bSize = 4 + Math.sin(t + i)*4;
            if(bSize > 0) {
                ctx.beginPath(); 
                ctx.arc(cx + offset, cy + yOff - 5, bSize, 0, 6.28); 
                ctx.fill();
                // Highlight
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.beginPath(); ctx.arc(cx+offset-1, cy+yOff-6, bSize/3, 0, 6.28); ctx.fill();
                ctx.fillStyle = 'rgba(93, 64, 55, 0.9)'; // Reset
            }
        }
    }




    // 3. DYNAMIC VOLCANO (Redesigned: Mountain Shape)
    // 3. DYNAMIC VOLCANO (Realistic 3D Version)
    // 3. ICONIC SHORT VOLCANO (Conical Shape)
   // 3. JAGGED VOLCANIC STUMP (Rugged, Cracked, Uneven)
   // 3. JAGGED VOLCANO V7 (Thick Steam + Wrinkles + Veins + Bubbles)
    else if(k === 'lava_crater') {
        let w = (e ? e.w : 2) * TILE;
        let h = (e ? e.h : 2) * TILE;
        
        let cx = px + w/2; 
        let cy = py + h - 5; 

        // --- GEOMETRY FIX: SHORTER & SQUATTER ---
        // 1. LOWER RIM (0.45 instead of 0.2) -> Makes it short
        let topY = py + (h * 0.45); 
        // 2. MOUTH WIDTH (0.22) -> Balanced for short height
        let rimRad = w * 0.22; 
        // 3. BASE WIDTH
        let baseW = w * 0.90; 

        let t = Date.now();
        let pulse = Math.sin(t / 250) * 0.1; 

        // Noise Function
        let seed = (e.x * 999.9) + (e.y * 111.1);
        const getJag = (index, amplitude) => {
            let x = Math.sin(seed + index) * 10000;
            return (x - Math.floor(x)) * amplitude;
        };

        // ===============================================
        // 1. MOUNTAIN BODY (Squat Cone)
        // ===============================================
        let bodyGrad = ctx.createLinearGradient(px, topY, px, cy);
        bodyGrad.addColorStop(0, '#3e2723');   // Ash Top
        bodyGrad.addColorStop(0.4, '#1a1a1a'); // Dark Rock
        bodyGrad.addColorStop(1, '#000000');   // Base
        
        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        ctx.moveTo(cx - rimRad, topY); 
        ctx.lineTo(cx - baseW*0.4 + getJag(1,4), topY + (h*0.25)); // Shorter slope
        ctx.lineTo(cx - baseW/2 + getJag(2,4), cy); 
        ctx.lineTo(cx, cy + 5); 
        ctx.lineTo(cx + baseW/2 + getJag(3,4), cy); 
        ctx.lineTo(cx + baseW*0.4 + getJag(4,4), topY + (h*0.25)); 
        ctx.lineTo(cx + rimRad, topY); 
        ctx.fill();

        // ===============================================
        // 2. RIPPED CRACKS (Black Shadows)
        // ===============================================
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; 
        ctx.beginPath();
        
        // Left Side Tear
        let lx = cx - (rimRad * 1.1); 
        let ly = topY + 8; // Start lower
        ctx.moveTo(lx, ly);
        ctx.lineTo(lx - 5, ly + 5);
        ctx.lineTo(lx + 2, ly + 15); 
        ctx.lineTo(lx - 6, ly + 25); 
        ctx.lineTo(lx - 2, ly + 25); 
        ctx.lineTo(lx + 4, ly + 15);
        ctx.lineTo(lx + 1, ly + 5);
        ctx.fill();

        // Right Side Tear
        let rx = cx + (rimRad * 1.0);
        let ry = topY + 5;
        ctx.moveTo(rx, ry);
        ctx.lineTo(rx + 6 + getJag(50,3), ry + 10);
        ctx.lineTo(rx + 2, ry + 20);
        ctx.lineTo(rx + 8, ry + 30);
        ctx.lineTo(rx + 4, ry + 30); 
        ctx.lineTo(rx - 1, ry + 20);
        ctx.lineTo(rx + 3, ry + 10);
        ctx.fill();

        // ===============================================
        // 3. MAGMA VEINS (Orange Rips)
        // ===============================================
        ctx.fillStyle = `rgba(255, 61, 0, ${0.8 + pulse})`;
        ctx.shadowColor = '#d84315'; ctx.shadowBlur = 10;
        ctx.beginPath();
        
        // Center Fissure (Adjusted for short height)
        let mx = cx + 5;
        let my = topY + 15;
        ctx.moveTo(mx, my);
        ctx.lineTo(mx + 6, my + 4);
        ctx.lineTo(mx + 2, my + 15);
        ctx.lineTo(mx + 10 + getJag(60,4), my + 25);
        ctx.lineTo(mx + 4, my + 25); 
        ctx.lineTo(mx - 3, my + 15);
        ctx.lineTo(mx + 1, my + 4);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Base glowing cracks
        ctx.strokeStyle = `rgba(255, 87, 34, ${0.6 + pulse})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(cx - 15, cy - 8); ctx.lineTo(cx - 25, cy - 4);
        ctx.moveTo(cx + 20, cy - 10); ctx.lineTo(cx + 30, cy - 5);
        ctx.stroke();

        // ===============================================
        // 4. THE RIM & LAVA
        // ===============================================
        let outerPoints = [];
        let innerPoints = [];
        let numPoints = 20;
        let pers = 0.4; // Slightly rounder perspective since we are lower

        for(let i=0; i<=numPoints; i++) {
            let ang = (i/numPoints) * Math.PI * 2;
            
            // Outer Rim
            let rOut = rimRad + getJag(100+i, 3); 
            let ox = cx + Math.cos(ang) * rOut;
            let oy = topY + Math.sin(ang) * (rOut * pers);
            outerPoints.push({x:ox, y:oy});

            // Inner Rim
            let thick = 2 + Math.abs(getJag(200+i, 4));
            let rIn = rOut - thick;
            let ix = cx + Math.cos(ang) * rIn;
            let iy = topY + 3 + Math.sin(ang) * (rIn * pers); 
            innerPoints.push({x:ix, y:iy});
        }

        // A. LAVA FILL
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(innerPoints[0].x, innerPoints[0].y);
        for(let p of innerPoints) ctx.lineTo(p.x, p.y);
        ctx.clip();
        
        let lGrad = ctx.createRadialGradient(cx, topY+5, 1, cx, topY+5, rimRad);
        lGrad.addColorStop(0, '#fff59d'); 
        lGrad.addColorStop(0.5, '#ff6f00'); 
        lGrad.addColorStop(1, '#bf360c'); 
        ctx.fillStyle = lGrad;
        ctx.fillRect(px, py, w, h);

        // Bubbles
        for(let i=0; i<3; i++) {
            let cycle = (t + i*700) % 2000; 
            if(cycle < 1000) { 
                let size = (cycle / 1000) * 4; 
                let alpha = 1 - (cycle / 1000); 
                let bx = cx + Math.sin(i*66) * (rimRad*0.4);
                let by = topY + 3 + Math.cos(i*66) * (rimRad*0.1); 
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha})`;
                ctx.beginPath(); ctx.arc(bx, by, size, 0, 6.28); ctx.fill();
            }
        }
        ctx.restore();

        // B. CRUST (Jagged Top)
        ctx.fillStyle = '#212121'; 
        ctx.beginPath();
        ctx.moveTo(outerPoints[0].x, outerPoints[0].y);
        for(let p of outerPoints) ctx.lineTo(p.x, p.y);
        for(let i=innerPoints.length-1; i>=0; i--) ctx.lineTo(innerPoints[i].x, innerPoints[i].y);
        ctx.closePath();
        ctx.fill();

        // C. INNER RIM HIGHLIGHT
        ctx.strokeStyle = `rgba(255, 87, 34, ${0.5 + pulse})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(innerPoints[0].x, innerPoints[0].y);
        for(let p of innerPoints) ctx.lineTo(p.x, p.y);
        ctx.stroke();

        // ===============================================
        // 5. ATMOSPHERE (Steam)
        // ===============================================
        for(let i=0; i<3; i++) {
            let cycleLen = 2000; 
            let offset = i * (cycleLen / 3); 
            let prog = ((t + offset) % cycleLen) / cycleLen; 
            
            let rise = prog * 35; // Lower rise
            let size = 3 + (prog * 10); 
            let alpha = (1 - prog) * 0.4; 
            let wiggle = Math.sin((t / 350) + i) * (3 + prog * 5);

            ctx.fillStyle = `rgba(100, 100, 100, ${alpha})`; 
            ctx.beginPath();
            ctx.arc(cx + wiggle, topY - rise, size, 0, Math.PI*2);
            ctx.fill();
        }
    }

    // --- PASTE END ---













    

    else { ctx.fillStyle='#7f8c8d'; ctx.beginPath(); ctx.arc(px+25,py+40,8,0,6.28); ctx.fill(); }
}






// --- PASTE THIS NEW FUNCTION ---
function lightning(x1, y1, x2, y2, isHeavy=false) {
    // Helper to make a jagged path
    const makePath = (sx, sy, ex, ey, displacement) => {
        let path = [];
        let currX = sx*TILE-S.cam.x; let currY = sy*TILE-S.cam.y;
        let destX = ex*TILE-S.cam.x; let destY = ey*TILE-S.cam.y;
        let dist = Math.hypot(destX-currX, destY-currY);
        let steps = Math.max(4, Math.floor(dist / 15)); 

        path.push({x:currX, y:currY});
        for(let i=1; i<steps; i++) {
            let t = i / steps;
            let nx = currX + (destX - currX) * t;
            let ny = currY + (destY - currY) * t;
            // Jitter
            nx += (Math.random() - 0.5) * displacement; 
            ny += (Math.random() - 0.5) * displacement;
            path.push({x:nx, y:ny});
        }
        path.push({x:destX, y:destY});
        return path;
    };

    let mainSegs = makePath(x1, y1, x2, y2, 40); // Main bolt: High jitter

    // If Heavy, generate branches
    let branches = [];
    if(isHeavy) {
        // Create 3 random branches splitting off the main bolt
        for(let k=0; k<3; k++) {
            let startNode = mainSegs[Math.floor(mainSegs.length * (0.3 + Math.random()*0.4))];
            if(startNode) {
                // Branch goes downwards and outwards
                let endX = x2 + (Math.random()-0.5)*8;
                let endY = y2 + (Math.random()*5);
                // Convert back to world coords for the helper, then to screen
                // Quick hack: just map relative pixel offsets
                let bx = startNode.x + (Math.random()-0.5)*150;
                let by = startNode.y + 100 + Math.random()*100;
                
                branches.push(makePath(startNode.x/TILE + S.cam.x/TILE, startNode.y/TILE + S.cam.y/TILE, 
                                       x2 + (Math.random()-0.5)*6, y2, 30));
            }
        }
    }

    S.lighting.push({
        segs: mainSegs, 
        branches: branches,
        life: 25,         // Lasts longer (fades out)
        maxLife: 25,
        type: isHeavy ? 'heavy_storm' : 'normal' 
    });
}

// ------------------------------





function popText(x, y, txt, c, outline=false, small=false) {
    let d = document.createElement('div'); 
    d.className='float-txt'; 
    d.innerText=txt; 
    d.style.color=c;
    
    // VISUAL FIX: Ensure it's on top
    d.style.zIndex = "3000"; 

    if(small) { d.style.fontSize = "24px"; }
    
    let rect = cvs.getBoundingClientRect();
    
    // VISUAL FIX: Add Random Offset so numbers don't stack
    let rX = (Math.random() - 0.5) * 30; 
    let rY = (Math.random() - 0.5) * 20;

    d.style.left = ((x*TILE - S.cam.x) + rect.left + 25 + rX) + 'px';
    d.style.top = ((y*TILE - S.cam.y) + rect.top + rY) + 'px';
    
    document.body.appendChild(d); 
    setTimeout(()=>d.remove(), 800);
}













// --- NEW UI HELPER (Optimized) ---
// --- NEW UI HELPER (Aligned & Snappy) ---
// --- NEW UI HELPER (Higher Position) ---
function popUiText(elemId, txt) {
    let el = document.getElementById(elemId);
    let wrapper = document.getElementById('game-wrapper');
    if(!el || !wrapper) return;

    // 1. TRIGGER FLASH
    el.classList.remove('shine-anim'); 
    setTimeout(() => el.classList.add('shine-anim'), 10);

    // 2. POSITIONING
    requestAnimationFrame(() => {
        let elRect = el.getBoundingClientRect();
        let wrapRect = wrapper.getBoundingClientRect();
        
        let left = (elRect.left - wrapRect.left) + (elRect.width / 2);
        let top;

        // --- POSITION FIX: MOVED UP ---
        // Changed 110 -> 60. Lower numbers = Higher on screen.
        if (elemId === 'hp-container' || elemId === 'lvl-val') {
            top = 60; 
        } else {
            // For Skill Bar (Bottom)
            top = (elRect.top - wrapRect.top) - 20;
        }

        // 3. CREATE TEXT
        let d = document.createElement('div');
        d.className = 'ui-pop-txt'; 
        d.innerText = txt;
        
        d.style.left = left + 'px';
        d.style.top = top + 'px';

        wrapper.appendChild(d);
        
        // Remove after 2 seconds
        setTimeout(() => d.remove(), 2000);
    });
}












function part(x, y, c, n, s=3, type='norm') { 
    if(S.parts.length>400) return;
    for(let i=0;i<n;i++) S.parts.push({
        x:x+(Math.random()-.5), y:y+(Math.random()-.5), 
        vx:(Math.random()-.5)*0.1, vy:(Math.random()-.5)*0.1, 
        c, life:type.includes('cloud')?50:20+Math.random()*10, s:s+Math.random()*2, type
    }); 
}





function drawStyledMinimap() {
    // 1. Clear Background (Transparent)
    miniCtx.clearRect(0, 0, MAP_S, MAP_S);

    // 2. Define The Zones
    const islands = [
        [25, 25, 18, '#a5d6a7', '#2e7d32'], // 1. Grass
        [75, 25, 16, '#66bb6a', '#1b5e20'], // 2. Forest
        [125, 25, 16, '#fff59d', '#fbc02d'], // 3. Sand
        [125, 75, 16, '#cfd8dc', '#455a64'], // 4. Ruins
        [75, 75, 16, '#bcaaa4', '#5d4037'], // 5. Swamp
        [25, 75, 16, '#e1f5fe', '#90a4ae'], // 6. Snow
        [25, 125, 16, '#ffab91', '#d84315'], // 7. Lava
        [75, 125, 16, '#9fa8da', '#283593'], // 8. Void
    ];

    // 3. Draw Roads (Original Solid Style)
    miniCtx.strokeStyle = '#d7ccc8'; 
    miniCtx.lineWidth = 4;
    miniCtx.lineCap = 'round';
    miniCtx.setLineDash([]); // Ensure solid lines

    miniCtx.beginPath();
    miniCtx.moveTo(25, 25); 
    miniCtx.lineTo(125, 25);
    miniCtx.lineTo(125, 75);
    miniCtx.lineTo(25, 75);
    miniCtx.lineTo(25, 125);
    miniCtx.lineTo(75, 125); 
    
    // Fake Road (If Unlocked)
    if (S.bossDead) miniCtx.lineTo(135, 135);
    
    miniCtx.stroke();

    // 4. Draw Islands (Original Colors)
    islands.forEach(isle => {
        let x = isle[0], y = isle[1], r = isle[2];
        miniCtx.beginPath();
        miniCtx.arc(x, y, r, 0, 6.28);
        
        // Original Inner Color
        miniCtx.fillStyle = isle[3]; 
        miniCtx.fill();
        
        // Original Border Color
        miniCtx.lineWidth = 3; 
        miniCtx.strokeStyle = isle[4]; 
        miniCtx.stroke();
    });

    // 5. Fake Island (If Unlocked)
    if (S.bossDead) {
        miniCtx.beginPath();
        miniCtx.arc(135, 135, 16, 0, 6.28); 
        miniCtx.fillStyle = '#a5d6a7'; 
        miniCtx.fill();
        miniCtx.lineWidth = 3;
        miniCtx.strokeStyle = '#2e7d32'; 
        miniCtx.stroke();
    }
}






// --- GAME OVER & MENU LOGIC ---

// FIND THIS FUNCTION
function triggerGameOver(killerName) {
    if (S.gameOver) return; // Prevent double death
    
    // --- ADD THIS LINE HERE ---
    S.p.hidden = false; 
    // --------------------------

    S.gameOver = true;
    S.run = false; // STOP the game loop
    
    S.audio.play('over'); // AUDIO

    // --- FIX: MOVE DEATH SCREEN TO FRONT (DOM ORDER) ---
    let dScreen = document.getElementById('death-screen');
    document.getElementById('game-wrapper').appendChild(dScreen);

    // Show Death Screen
    dScreen.style.display = 'flex';
    document.getElementById('death-msg').innerText = killerName || "Unknown Force";
}

function returnToMenu() {
// --- PASTE THIS NEW LINE HERE ---
    if(S.audio) S.audio.stopAmbience();
// --------------------------------



    S.audio.play('esc'); 
    
   // --- FORCE HOME MUSIC ---
    S.audio.currentBgmKey = null; // Forget current song
    S.audio.playBGM('home');      // Start Home theme (will rewind due to Step 1)


    // 1. Hide Death Screen and Game UI
    document.getElementById('death-screen').style.display = 'none';
    document.getElementById('hud-top').style.display = 'none';
    document.getElementById('quest-panel').style.display = 'none';
    
    // 2. Clear Skills (Visual only)
    let bar = document.getElementById('skill-bar');
    if(bar) bar.innerHTML = ''; 
    
    // 3. Show Main Menu
    document.getElementById('main-menu').style.display = 'block';
    Menu.goto('home'); // Go to title
    
    // 4. Reset Logic Flags
    S.gameOver = false;
    S.run = false; 
}












// --- NEW PORTRAIT SYSTEM (Direct Canvas Draw) ---

function drawPortrait(canvasId, name) {
    const cvs = document.getElementById(canvasId);
    if(!cvs) return;
    const ctx = cvs.getContext('2d');
    
    // Clear previous drawing
    ctx.clearRect(0, 0, cvs.width, cvs.height);
    ctx.save();

    // 1. GLOBAL HIGH-DPI SCALING (3x Resolution)
    ctx.scale(3, 3); 

    if (name === "Noah") {
        // ============================================
        // NOAH (FINAL: Original Scarf, Smooth & Slightly Narrower Shoulders)
        // ============================================
        
        // 1. Setup Position
        ctx.translate(250, 300); 
        ctx.scale(7.0, 7.0); 

        // ============================================
        // 2. UPPER BODY (Narrower & Smooth)
        // ============================================
        ctx.save(); // Start Clipping Mask

        // --- A. Define The Silhouette ---
        ctx.beginPath();
        
        // Collar (Y=5)
        ctx.moveTo(-4, 5);
        
        // Left Shoulder (Moved in: x=-9 instead of -10)
        ctx.lineTo(-9, 6); 
        // Curve (Control point moved in to -10.5)
        ctx.quadraticCurveTo(-10.5, 6.2, -10.5, 9); 
        
        // Left Sleeve (Straight down)
        ctx.lineTo(-10.5, 13); // Outer Sleeve
        ctx.lineTo(-7.5, 12);  // Inner Sleeve
        
        // Left Torso Side
        ctx.lineTo(-7, 15);    // Waist
        
        // Bottom Hem
        ctx.lineTo(7, 15);
        
        // Right Torso Side
        ctx.lineTo(7, 12);
        
        // Right Sleeve
        ctx.lineTo(7.5, 12);   // Inner Sleeve
        ctx.lineTo(10.5, 13);  // Outer Sleeve
        ctx.lineTo(10.5, 9);   // Top of Arm
        
        // Right Shoulder (Curve gently back)
        ctx.quadraticCurveTo(10.5, 6.2, 9, 6); 
        
        // Right Collar
        ctx.lineTo(4, 5);
        
        ctx.closePath();

        // --- B. Fill Base Color ---
        ctx.fillStyle = '#ffffff';
        ctx.fill();

        // --- C. Apply Clip ---
        ctx.clip();

        // --- D. Draw Stripes ---
        ctx.fillStyle = '#1a237e'; 
        ctx.fillRect(-15, 7, 30, 1.5);  
        ctx.fillRect(-15, 10, 30, 1.5); 
        ctx.fillRect(-15, 13, 30, 1.5); 

        ctx.restore(); // End Clipping

        // ============================================
        // 3. ARMS & HANDS (Aligned to new width)
        // ============================================
        
        // Left Hand
        ctx.fillStyle = '#f5cba7'; 
        ctx.fillRect(-10.5, 13, 3, 3); // Moved inward
        
        // Right Hand 
        ctx.fillStyle = '#f5cba7'; 
        ctx.fillRect(7.5, 13, 3, 3); // Moved inward

        // ============================================
        // 4. SCARF (EXACT ORIGINAL POSITION)
        // ============================================
        ctx.fillStyle = '#c0392b';  // Red
        
        // Main Loop
        ctx.beginPath(); 
        ctx.moveTo(-5, 6); 
        ctx.quadraticCurveTo(0, 10, 5, 6); 
        ctx.lineTo(5, 3); 
        ctx.lineTo(-5, 3); 
        ctx.fill();
        
        // Scarf Drop
        ctx.fillStyle = '#b71c1c'; 
        ctx.fillRect(2, 6, 3, 5); 

        // ============================================
        // 5. HEAD & FACE
        // ============================================
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(-5, -7, 10, 10); 
        ctx.fillRect(-6, -4, 1, 4); ctx.fillRect(5, -4, 1, 4);   
        
        // Nose
        ctx.fillStyle = '#e0b293'; ctx.fillRect(-1, -2, 2, 1); ctx.fillRect(0, -3, 1, 2);
        
        // Eyes
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-3, -4.5, 1, 1); 
        ctx.fillRect(2, -4.5, 1, 1);
        
        // Hair (Bangs)
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-4, -6, 3, 1); ctx.fillRect(1, -6, 3, 1); 

        // Mouth (Smile)
        ctx.fillStyle = '#d84315'; 
        ctx.fillRect(-1, 0.5, 2, 0.5); 
        ctx.fillRect(-1.5, 0, 0.5, 0.5); 
        ctx.fillRect(1, 0, 0.5, 0.5);    
        
        // Hair Back/Sides
        ctx.fillStyle = '#3e2723'; 
        ctx.fillRect(-5, -10, 10, 3); ctx.fillRect(-6, -9, 2, 4); 
        ctx.fillRect(-6, -6, 2, 5); ctx.fillRect(4, -6, 2, 5); ctx.fillRect(-1, -8, 2, 1);

        // ============================================
        // 6. BERET
        // ============================================
        ctx.fillStyle = '#b71c1c'; 
        ctx.beginPath(); ctx.ellipse(1, -9, 9, 4, 0.2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#d32f2f'; 
        ctx.beginPath(); ctx.ellipse(2, -10, 6, 2, 0.2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#111'; ctx.fillRect(1, -12, 2, 2); 

        // ============================================
        // 7. ACCESSORIES
        // ============================================
        
       // Brush (Left Hand) - Shifted UP significantly
        ctx.fillStyle = '#8d6e63'; 
        ctx.fillRect(-9.5, 8, 1, 8); // Handle (Y=8 to 16, passes through hand at 13)
        ctx.fillStyle = '#e91e63'; 
        ctx.fillRect(-9.5, 7, 1, 1); // Tip (Y=7, well above hand)

        // Palette (Right Hand)
        ctx.save(); 
        ctx.translate(8.5, 14); 
        ctx.rotate(-0.5);
        ctx.fillStyle = '#d35400'; ctx.beginPath(); ctx.ellipse(0, 0, 4, 6, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(-1, -2, 1.5, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#e91e63'; ctx.beginPath(); ctx.arc(1, 0, 1.5, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#2980b9'; ctx.beginPath(); ctx.arc(0, 2, 1.5, 0, 6.28); ctx.fill();
        ctx.restore(); 
    }



 else if (name === "Doris") {
        // ============================================
        // DORIS (Fixed Wings & Realistic Trumpet)
        // ============================================
        ctx.translate(150, 80); 
        ctx.scale(1.35, 1.35);   
        ctx.translate(-75, -75); 
        
        const cx = 75; 

        // 1. WINGS (Fixed: Attached to Back)
        ctx.save();
        const drawWing = (wx, wy, flip) => {
            ctx.save();
            ctx.translate(wx, wy);
            ctx.scale(flip, 1); 
            
            let wg = ctx.createLinearGradient(0, 0, 60, 50);
            wg.addColorStop(0, "#ffffff");
            wg.addColorStop(1, "#cfd8dc");

            ctx.fillStyle = wg;
            ctx.shadowColor = "rgba(255, 255, 255, 0.6)"; ctx.shadowBlur = 10;
            
            ctx.beginPath();
            // Root starts at (0,0) which we position right behind the shoulder blade
            ctx.moveTo(0, 0); 
            // Arch UP and OUT (High shoulder arch)
            ctx.quadraticCurveTo(10, -35, 60, -20); 
            // Wing Tip
            ctx.quadraticCurveTo(75, 0, 60, 20); 
            // Feathers (Scallops)
            ctx.quadraticCurveTo(55, 25, 50, 20); 
            ctx.quadraticCurveTo(45, 35, 35, 30); 
            ctx.quadraticCurveTo(30, 40, 20, 35); 
            // Return to lower back
            ctx.quadraticCurveTo(10, 45, 0, 10);   
            ctx.fill();
            
            ctx.restore();
        };
        // Move anchors IN (x=60, x=90) and UP (y=85) to hide connection behind body
        drawWing(60, 85, -1);
        drawWing(90, 85, 1);
        ctx.restore();

        // 2. HAIR BASE
        let hairBase = ctx.createLinearGradient(0, 40, 0, 100);
        hairBase.addColorStop(0, "#fff9c4"); hairBase.addColorStop(1, "#f0f4c3"); 
        ctx.fillStyle = hairBase;
        ctx.beginPath();
        ctx.moveTo(45, 92);
        ctx.quadraticCurveTo(35, 88, 38, 78);  ctx.quadraticCurveTo(30, 68, 35, 55);  ctx.quadraticCurveTo(28, 42, 45, 38);
        ctx.quadraticCurveTo(55, 28, 65, 32);  ctx.quadraticCurveTo(75, 25, 85, 32);  ctx.quadraticCurveTo(95, 28, 105, 38);
        ctx.quadraticCurveTo(122, 42, 115, 55); ctx.quadraticCurveTo(120, 68, 112, 78); ctx.quadraticCurveTo(115, 88, 105, 92);
        ctx.quadraticCurveTo(75, 100, 45, 92);
        ctx.fill();

        // 3. NECK
        ctx.fillStyle = "#d7ccc8"; ctx.fillRect(62, 90, 26, 20); 
        ctx.fillStyle = "#ffccbc"; ctx.fillRect(64, 90, 22, 18);

        // 4. CLOTHES (SMOOTH SHOULDERS)
        ctx.fillStyle = "#1565c0"; 
        ctx.beginPath();
        ctx.moveTo(30, 150); // Bottom Left Arm
        
        // Left Shoulder: Curves smoothly from arm up to collar
        ctx.quadraticCurveTo(30, 105, 60, 112);
        
        // Neck Dip
        ctx.quadraticCurveTo(75, 125, 90, 112);
        
        // Right Shoulder: Curves smoothly from collar down to arm
        ctx.quadraticCurveTo(120, 105, 120, 150);
        
        ctx.lineTo(30, 150); // Close bottom
        ctx.fill();

        // White Shirt V
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.moveTo(75, 135); ctx.lineTo(60, 112); ctx.lineTo(90, 112); ctx.fill();

        // Lapels (Adjusted to follow the new curve)
        ctx.fillStyle = "#0d47a1";
        // Left Lapel
        ctx.beginPath(); ctx.moveTo(38, 115); ctx.quadraticCurveTo(48, 112, 60, 112); ctx.lineTo(75, 135); ctx.fill(); 
        // Right Lapel
        ctx.beginPath(); ctx.moveTo(112, 115); ctx.quadraticCurveTo(102, 112, 90, 112); ctx.lineTo(75, 135); ctx.fill(); 

        // Buttons
        ctx.fillStyle = "#ffd700";
        ctx.beginPath(); ctx.arc(75, 140, 2.5, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(75, 148, 2.5, 0, 6.28); ctx.fill();

        // 5. NECKLACE
        ctx.fillStyle = "#fff"; ctx.shadowBlur = 5; ctx.shadowColor = "#eee";
        for(let i=0; i<9; i++) {
            let px = 60 + (i * 3.8); let py = 108 + Math.sin(i * 0.4) * 3;
            ctx.beginPath(); ctx.arc(px, py, 2.5, 0, Math.PI*2); ctx.fill();
        }
        ctx.shadowBlur = 0;

        // 6. FACE
        let skinGrad = ctx.createRadialGradient(cx, 75, 5, cx, 75, 45);
        skinGrad.addColorStop(0, "#fff3e0"); skinGrad.addColorStop(0.5, "#ffccbc"); skinGrad.addColorStop(1, "#d7ccc8");   
        ctx.fillStyle = skinGrad;
        ctx.beginPath(); ctx.moveTo(50, 65); ctx.quadraticCurveTo(47, 90, 62, 102); ctx.quadraticCurveTo(cx, 105, 88, 102); 
        ctx.quadraticCurveTo(103, 90, 100, 65); ctx.quadraticCurveTo(cx, 50, 50, 65); ctx.fill();

        // 7. FEATURES
        const paintEye = (ex, ey) => {
            ctx.fillStyle = "rgba(141, 110, 99, 0.3)"; ctx.beginPath(); ctx.ellipse(ex, ey - 2, 7, 4, Math.PI, 0, Math.PI); ctx.fill();
            ctx.fillStyle = "rgba(210, 190, 180, 0.15)"; ctx.beginPath(); ctx.arc(ex, ey, 8, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#fdfdfe"; ctx.beginPath(); ctx.ellipse(ex, ey, 5.5, 3, 0, 0, Math.PI*2); ctx.fill();


            // --- CHANGED TO BLUE IRIS ---
            ctx.fillStyle = "#1e88e5"; ctx.beginPath(); ctx.arc(ex, ey, 2.5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#1a1a1a"; ctx.beginPath(); ctx.arc(ex, ey, 1.2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(ex - 1, ey - 1, 0.8, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "#263238"; ctx.lineWidth = 1.5; ctx.lineCap = "round";
            ctx.beginPath(); ctx.moveTo(ex - 5, ey); ctx.quadraticCurveTo(ex, ey - 4.5, ex + 6, ey - 0.5); ctx.stroke();
        };
        paintEye(64, 74); paintEye(86, 74); 

        ctx.strokeStyle = "rgba(141, 110, 99, 0.6)"; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(59, 68); ctx.quadraticCurveTo(65, 66, 71, 69); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(79, 69); ctx.quadraticCurveTo(85, 66, 91, 68); ctx.stroke();

        ctx.fillStyle = "#fff3e0";
        ctx.beginPath(); ctx.moveTo(cx - 2, 65); ctx.lineTo(cx + 2, 65); ctx.lineTo(cx + 2, 85); ctx.lineTo(cx + 6, 85);
        ctx.quadraticCurveTo(cx, 94, cx - 6, 85); ctx.lineTo(cx - 2, 85); ctx.lineTo(cx - 2, 65); ctx.fill();
        ctx.fillStyle = "#ffe9d7";
        ctx.beginPath(); ctx.moveTo(cx + 1, 65); ctx.lineTo(cx + 2, 65); ctx.lineTo(cx + 2, 85); ctx.lineTo(cx + 6, 85);
        ctx.quadraticCurveTo(cx + 1, 93, cx, 94); ctx.quadraticCurveTo(cx + 3, 90, cx + 3, 85); ctx.lineTo(cx + 1, 85); ctx.lineTo(cx + 1, 65); ctx.fill();
        ctx.strokeStyle = "#ffdccb"; ctx.lineWidth = 1.5; ctx.lineCap = "round";
        ctx.beginPath(); ctx.moveTo(71, 85); ctx.quadraticCurveTo(65, 87, 63, 92); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(79, 85); ctx.quadraticCurveTo(85, 87, 87, 92); ctx.stroke();

        const addBlush = (bx, by) => {
            let bGrad = ctx.createRadialGradient(bx, by, 0, bx, by, 15);
            bGrad.addColorStop(0, "rgba(229, 115, 115, 0.14)"); bGrad.addColorStop(0.5, "rgba(229, 115, 115, 0.05)"); bGrad.addColorStop(1, "rgba(229, 115, 115, 0)"); 
            ctx.fillStyle = bGrad; ctx.beginPath(); ctx.ellipse(bx, by, 15, 10, 0, 0, Math.PI*2); ctx.fill();
        };
        addBlush(58, 85); addBlush(92, 85);

        let lipGrad = ctx.createLinearGradient(0, 90, 0, 96);
        lipGrad.addColorStop(0, "#c2185b"); lipGrad.addColorStop(1, "#f48fb1"); 
        ctx.fillStyle = lipGrad;
        ctx.beginPath(); ctx.moveTo(67, 92); ctx.quadraticCurveTo(cx, 96, 83, 92); ctx.quadraticCurveTo(cx, 100, 67, 92); ctx.fill();
        
        let blush = ctx.createRadialGradient(cx, 85, 1, cx, 85, 20);
        blush.addColorStop(0, "rgba(244, 143, 177, 0.0)"); blush.addColorStop(1, "rgba(244, 143, 177, 0)");
        ctx.fillStyle = blush; ctx.fillRect(45, 80, 60, 20);

        // 8. CURLY HAIR
        let seed = 1234;
        const myRandom = () => { let x = Math.sin(seed++) * 10000; return x - Math.floor(x); };
        const drawStaticCurl = (x, y, r, color) => {
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 1.3; ctx.lineCap = "round";
            ctx.arc(x, y, r, 0, Math.PI * 1.5); ctx.stroke();
        };
        for(let i=0; i<1600; i++) {
            let angle = myRandom() * Math.PI * 2; let dist = myRandom() * 45; 
            let hx = 75 + Math.cos(angle) * (dist * 0.9); let hy = 60 + Math.sin(angle) * (dist * 0.7);
            if (hy > 58 && hx > 48 && hx < 102) continue; 
            if (hy < 35 || hy > 95) continue; 
            let col = (i%3===0) ? "#fff9c4" : (i%3===1) ? "#fff59d" : "#ffffff";
            drawStaticCurl(hx, hy, 1.5 + myRandom()*2.5, col);
        }
        for(let j=0; j<40; j++) {
            let bx = 55 + (j*1.2); let by = 55 + Math.sin(j*0.5)*5; drawStaticCurl(bx, by, 2, "#fff9c4");
        }

        // 9. TRUMPET (REALISTIC SHAPE)
        ctx.save();
        // Position: In Hands
        ctx.translate(65, 135); 
        ctx.rotate(-0.4); 
        
        let brass = ctx.createLinearGradient(0, -5, 0, 10);
        brass.addColorStop(0, "#fbc02d"); 
        brass.addColorStop(0.4, "#fff59d"); 
        brass.addColorStop(0.6, "#fdd835"); 
        brass.addColorStop(1, "#f57f17"); 

        ctx.fillStyle = brass;
        
        // A. Bell Flare (Left)
        ctx.beginPath();
        ctx.moveTo(-10, -8);
        ctx.quadraticCurveTo(5, 0, -10, 8); 
        ctx.lineTo(-25, 4);
        ctx.lineTo(-25, -4);
        ctx.fill();

        // B. Main Tubing (Long Rectangle)
        ctx.fillRect(-25, -3, 60, 6);

        // C. Valve Block (Middle)
        ctx.fillRect(0, -8, 15, 16); // The Casing
        // Valve Stems (Buttons)
        ctx.fillStyle = "#fff176";
        ctx.fillRect(2, -11, 3, 3);
        ctx.fillRect(6, -11, 3, 3);
        ctx.fillRect(10, -11, 3, 3);

        // D. Loop (Bottom pipe)
        ctx.strokeStyle = "#f9a825"; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(-15, 3); ctx.quadraticCurveTo(-20, 10, 0, 10); ctx.lineTo(30, 10); ctx.quadraticCurveTo(40, 10, 35, 3); ctx.stroke();

        ctx.restore();

        // Hands & Earrings
        ctx.fillStyle = "#ffccbc";
        ctx.beginPath(); ctx.ellipse(58, 140, 6, 8, 0.6, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(92, 142, 6, 8, -0.6, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.shadowColor="#fff"; ctx.shadowBlur=4;
        ctx.beginPath(); ctx.arc(46, 85, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(104, 85, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur=0;
    }
    ctx.restore();
}




function showChat(name, txt, isIntro = false) {
    const stdBox = document.getElementById('rpg-chat');
    const spBox = document.getElementById('special-chat');
    
    const stdName = document.getElementById('chat-name');
    const stdText = document.getElementById('chat-text');
    
    const spName = document.getElementById('sp-name');
    const spText = document.getElementById('sp-text');

    // 1. Reset Everything (Hide both boxes)
    stdBox.style.display = 'none'; stdBox.style.opacity = 0;
    spBox.style.display = 'none'; spBox.style.opacity = 0;
    
// --- RESET THE PROMPT CLASS ---
    stdBox.classList.remove('no-prompt');


    // 2. Remove old positioning classes to prevent conflicts
    spBox.classList.remove('talk-noah', 'talk-doris');

    // 3. LOGIC SWITCH: Check if it is Noah or Doris
    if ((name === "Noah" || name === "Doris") && !isIntro) {
        
        spBox.style.display = 'flex';
        // Small delay to allow display:flex to render before opacity fade-in
        setTimeout(() => spBox.style.opacity = 1, 10);

        spName.innerText = name;
        spText.innerText = txt;

        const cn = document.getElementById('canvas-noah');
        const cd = document.getElementById('canvas-doris');
        
        // Hide both portraits first
        if(cn) cn.style.display = 'none';
        if(cd) cd.style.display = 'none';

        // --- APPLY SPECIFIC LAYOUT ---
        if(name === "Noah") {
            spBox.classList.add('talk-noah'); // Activate Noah CSS
            if(cn) { cn.style.display = 'block'; drawPortrait('canvas-noah', 'Noah'); }
        } 
        else if(name === "Doris") {
            spBox.classList.add('talk-doris'); // Activate Doris CSS
            if(cd) { cd.style.display = 'block'; drawPortrait('canvas-doris', 'Doris'); }
        }




    } else {
        // STANDARD BOX
        stdBox.style.display = 'flex';
        
        // --- NEW: TUTORIAL EXCEPTION ---
        // If this is the intro/tutorial, add 'no-lock' class so player can move.
        if (isIntro) stdBox.classList.add('no-lock');
        else stdBox.classList.remove('no-lock');
        // -------------------------------

        setTimeout(() => stdBox.style.opacity = 1, 10);
        stdName.innerText = name;
        stdText.innerHTML = txt; 
    }
    



    // Auto-close timer
    if(S.chatTo) clearTimeout(S.chatTo);
    S.chatTo = setTimeout(() => { 
        stdBox.style.opacity = 0; spBox.style.opacity = 0;
        setTimeout(() => { stdBox.style.display = 'none'; spBox.style.display = 'none'; }, 200);
    }, 3500 + txt.length * 50); 
}








// --- HIGH FIDELITY STATUE RENDERER (V3: High Contrast & Solid Wings) ---
function drawHighResStatue(ctx, x, y, active) {
    // 1. Setup Palette
    // RUINS FLOOR is #616161. 
    // We use #b0bec5 (Blue Grey) for the statue so it pops out.
    const P = active ? {
        base: '#ffffff',    // Pure White
        mid:  '#e0e0e0',    // Light Grey
        dark: '#bdbdbd',    // Shading
        deep: '#757575',    // Outlines
        accent: '#ffd700'   // Gold
    } : {
        base: '#b0bec5',    // Blue-Grey Stone (Contrast vs Floor)
        mid:  '#78909c',    // Darker Blue-Grey
        dark: '#546e7a',    // Deep Shadow
        deep: '#37474f',    // Outline
        accent: '#558b2f'   // Moss
    };

    ctx.save();
    
    // 2. Position & Scale 
    ctx.translate(x + 25, y + 45); 
    ctx.scale(1.0, 1.0); 

    // --- A. THE PEDESTAL (Grounding) ---
    // Dark base to separate from floor
    ctx.fillStyle = '#263238'; ctx.fillRect(-35, 0, 70, 10);
    ctx.fillStyle = '#455a64'; ctx.fillRect(-30, -10, 60, 10);
    
    // --- B. THE WINGS (Redesigned: Solid Folded Stone) ---
    // No longer thin lines. These are massive slabs.
    const drawWing = (dir) => {
        ctx.save();
        ctx.scale(dir, 1);
        ctx.fillStyle = P.mid;
        
        ctx.beginPath();
        // Start behind shoulder
        ctx.moveTo(15, -60); 
        // Curve up and out (The "Shoulder" of the wing)
        ctx.quadraticCurveTo(40, -90, 60, -50); 
        // The long feathers dragging down
        ctx.lineTo(55, -10); 
        // Curve back in to body
        ctx.quadraticCurveTo(40, 0, 15, -30); 
        ctx.fill();

        // Feather Texture (Carved Lines)
        ctx.strokeStyle = P.dark; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(25, -60); ctx.quadraticCurveTo(45, -70, 50, -40); // Top layer
        ctx.moveTo(25, -50); ctx.quadraticCurveTo(40, -50, 45, -20); // Mid layer
        ctx.stroke();

        ctx.restore();
    };
    // Draw behind body
    drawWing(1); drawWing(-1); 

    // --- C. THE BODY (Draped Toga) ---
    ctx.fillStyle = P.base;
    ctx.beginPath();
    // Wider stance to look heavy
    ctx.moveTo(-18, -65); // Neck
    ctx.lineTo(-24, -10); // Waist
    ctx.lineTo(-32, 10);  // Base Flare Left
    ctx.lineTo(32, 10);   // Base Flare Right
    ctx.lineTo(24, -10);  // Waist
    ctx.lineTo(18, -65);  // Neck
    ctx.fill();

    // Fabric Folds (Shadows)
    ctx.fillStyle = P.dark;
    ctx.beginPath(); 
    ctx.moveTo(0, -60); 
    ctx.quadraticCurveTo(-15, -30, 8, 10); // Main diagonal fold
    ctx.lineTo(14, 10); 
    ctx.quadraticCurveTo(-8, -30, 8, -60); 
    ctx.fill();
    
    // Sash
    ctx.fillStyle = P.mid; ctx.fillRect(-22, -25, 44, 8);

    // --- D. THE HEAD (Big & Detailed) ---
    // Neck
    ctx.fillStyle = P.dark; ctx.fillRect(-9, -75, 18, 12);
    
    // Face Mass
    ctx.fillStyle = P.base;
    ctx.beginPath();
    ctx.moveTo(-15, -92); 
    ctx.lineTo(-15, -78); // Cheek
    ctx.quadraticCurveTo(0, -70, 15, -78); // Chin
    ctx.lineTo(15, -92); 
    ctx.quadraticCurveTo(0, -108, -15, -92); // Forehead
    ctx.fill();

    // Nose (Shadow Triangle)
    ctx.fillStyle = P.dark;
    ctx.beginPath(); ctx.moveTo(-2, -90); ctx.lineTo(-5, -84); ctx.lineTo(0, -81); ctx.lineTo(3, -84); ctx.fill();

    // Eye Sockets
    ctx.fillStyle = P.dark;
    ctx.beginPath(); ctx.ellipse(-7, -88, 4, 3, 0.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(7, -88, 4, 3, -0.2, 0, Math.PI*2); ctx.fill();

    // Eyelids/Pupils
    if(active) {
        ctx.fillStyle = '#fff'; // Whites
        ctx.fillRect(-8, -89, 2, 2); ctx.fillRect(6, -89, 2, 2);
    }

    // Mouth
    ctx.fillStyle = P.deep; ctx.fillRect(-5, -79, 10, 1); 

    // Hair (Carved Stone Curls)
    ctx.fillStyle = P.mid;
    for(let i=0; i<6; i++) { 
        ctx.beginPath(); ctx.arc(-16 + (i*6.4), -102, 7, 0, Math.PI*2); ctx.fill(); 
    }
    // Sideburns
    ctx.beginPath(); ctx.arc(-16, -90, 6, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(16, -90, 6, 0, Math.PI*2); ctx.fill();

    // --- E. ARMS (Praying) ---
    ctx.fillStyle = P.base;
    // Shoulders
    ctx.beginPath(); ctx.arc(-20, -60, 12, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(20, -60, 12, 0, Math.PI*2); ctx.fill();
    
    // Forearms
    ctx.beginPath(); ctx.moveTo(-20, -60); ctx.lineTo(-5, -45); ctx.lineTo(0, -55); ctx.fill();
    ctx.beginPath(); ctx.moveTo(20, -60); ctx.lineTo(5, -45); ctx.lineTo(0, -55); ctx.fill();
    
    // Hands
    ctx.fillStyle = P.mid;
    ctx.beginPath(); ctx.arc(0, -45, 6, 0, Math.PI*2); ctx.fill();

    // --- F. EFFECTS ---
    if(!active) {
        // High Contrast Moss
        ctx.fillStyle = P.accent; 
        ctx.beginPath(); ctx.arc(-15, -60, 5, 0, Math.PI*2); ctx.fill(); 
        ctx.beginPath(); ctx.ellipse(18, 5, 10, 4, 0, 0, Math.PI*2); ctx.fill();
        
        // Deep Cracks (Dark Grey)
        ctx.strokeStyle = '#263238'; ctx.lineWidth = 1; 
        ctx.beginPath(); ctx.moveTo(-12, -10); ctx.lineTo(-8, -20); ctx.lineTo(-12, -25); ctx.stroke(); 
    } else {
        // Halo
        ctx.strokeStyle = P.accent; ctx.lineWidth = 2; 
        ctx.beginPath(); ctx.ellipse(0, -110, 22, 6, 0, 0, Math.PI*2); ctx.stroke();
        
        // Aura
        let pulse = Math.sin(Date.now()/300) * 2;
        ctx.fillStyle = 'rgba(255, 215, 0, 0.15)';
        ctx.beginPath(); ctx.ellipse(0, -45, 45 + pulse, 70, 0, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
}





</script>
</body>
</html>